// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	aws "github.com/opengovern/og-describer-template/aws/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: AccessAnalyzerAnalyzer =============================

type AccessAnalyzerAnalyzer struct {
	Description   aws.AccessAnalyzerAnalyzerDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type AccessAnalyzerAnalyzerHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  AccessAnalyzerAnalyzer `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type AccessAnalyzerAnalyzerHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []AccessAnalyzerAnalyzerHit `json:"hits"`
}

type AccessAnalyzerAnalyzerSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  AccessAnalyzerAnalyzerHits `json:"hits"`
}

type AccessAnalyzerAnalyzerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessAnalyzerAnalyzerPaginator(filters []essdk.BoolFilter, limit *int64) (AccessAnalyzerAnalyzerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_accessanalyzer_analyzer", filters, limit)
	if err != nil {
		return AccessAnalyzerAnalyzerPaginator{}, err
	}

	p := AccessAnalyzerAnalyzerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessAnalyzerAnalyzerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessAnalyzerAnalyzerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessAnalyzerAnalyzerPaginator) NextPage(ctx context.Context) ([]AccessAnalyzerAnalyzer, error) {
	var response AccessAnalyzerAnalyzerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessAnalyzerAnalyzer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessAnalyzerAnalyzerFilters = map[string]string{
	"arn":                       "description.Analyzer.Arn",
	"created_at":                "description.Analyzer.CreatedAt",
	"findings":                  "description.Findings",
	"og_account_id":             "metadata.SourceID",
	"last_resource_analyzed":    "description.Analyzer.LastResourceAnalyzed",
	"last_resource_analyzed_at": "description.Analyzer.LastResourceAnalyzedAt",
	"name":                      "description.Analyzer.Name",
	"status":                    "description.Analyzer.Status",
	"status_reason":             "description.Analyzer.StatusReason",
	"tags":                      "description.Analyzer.Tags",
	"title":                     "description.Analyzer.Name",
	"type":                      "description.Analyzer.Type",
}

func ListAccessAnalyzerAnalyzer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessAnalyzerAnalyzer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessAnalyzerAnalyzerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessAnalyzerAnalyzerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzer NewAccessAnalyzerAnalyzerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessAnalyzerAnalyzerFilters = map[string]string{
	"arn":                       "description.Analyzer.Arn",
	"created_at":                "description.Analyzer.CreatedAt",
	"findings":                  "description.Findings",
	"og_account_id":             "metadata.SourceID",
	"last_resource_analyzed":    "description.Analyzer.LastResourceAnalyzed",
	"last_resource_analyzed_at": "description.Analyzer.LastResourceAnalyzedAt",
	"name":                      "description.Analyzer.Name",
	"status":                    "description.Analyzer.Status",
	"status_reason":             "description.Analyzer.StatusReason",
	"tags":                      "description.Analyzer.Tags",
	"title":                     "description.Analyzer.Name",
	"type":                      "description.Analyzer.Type",
}

func GetAccessAnalyzerAnalyzer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessAnalyzerAnalyzer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessAnalyzerAnalyzerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessAnalyzerAnalyzerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessAnalyzerAnalyzer =============================

// ==========================  START: AccessAnalyzerAnalyzerFinding =============================

type AccessAnalyzerAnalyzerFinding struct {
	Description   aws.AccessAnalyzerAnalyzerFindingDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type AccessAnalyzerAnalyzerFindingHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  AccessAnalyzerAnalyzerFinding `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type AccessAnalyzerAnalyzerFindingHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []AccessAnalyzerAnalyzerFindingHit `json:"hits"`
}

type AccessAnalyzerAnalyzerFindingSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  AccessAnalyzerAnalyzerFindingHits `json:"hits"`
}

type AccessAnalyzerAnalyzerFindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessAnalyzerAnalyzerFindingPaginator(filters []essdk.BoolFilter, limit *int64) (AccessAnalyzerAnalyzerFindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_accessanalyzer_finding", filters, limit)
	if err != nil {
		return AccessAnalyzerAnalyzerFindingPaginator{}, err
	}

	p := AccessAnalyzerAnalyzerFindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessAnalyzerAnalyzerFindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessAnalyzerAnalyzerFindingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessAnalyzerAnalyzerFindingPaginator) NextPage(ctx context.Context) ([]AccessAnalyzerAnalyzerFinding, error) {
	var response AccessAnalyzerAnalyzerFindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessAnalyzerAnalyzerFinding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessAnalyzerAnalyzerFindingFilters = map[string]string{
	"access_analyzer_arn":    "description.AnalyzerArn",
	"action":                 "description.Finding.Action",
	"analyzed_at":            "description.Finding.AnalyzedAt",
	"condition":              "description.Finding.Condition",
	"created_at":             "description.Finding.CreatedAt",
	"error":                  "description.Finding.Error",
	"id":                     "description.Finding.Id",
	"is_public":              "description.Finding.IsPublic",
	"principal":              "description.Finding.Principal",
	"resource":               "description.Finding.Resource",
	"resource_owner_account": "description.Finding.ResourceOwnerAccount",
	"resource_type":          "description.Finding.ResourceType",
	"sources":                "description.Finding.Sources",
	"status":                 "description.Finding.Status",
	"title":                  "description.Finding.Id",
	"updated_at":             "description.Finding.UpdatedAt",
}

func ListAccessAnalyzerAnalyzerFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessAnalyzerAnalyzerFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzerFinding NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzerFinding NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzerFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzerFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzerFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessAnalyzerAnalyzerFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessAnalyzerAnalyzerFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzerFinding NewAccessAnalyzerAnalyzerFindingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessAnalyzerAnalyzerFinding paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessAnalyzerAnalyzerFindingFilters = map[string]string{
	"access_analyzer_arn":    "description.AnalyzerArn",
	"action":                 "description.Finding.Action",
	"analyzed_at":            "description.Finding.AnalyzedAt",
	"condition":              "description.Finding.Condition",
	"created_at":             "description.Finding.CreatedAt",
	"error":                  "description.Finding.Error",
	"id":                     "description.Finding.Id",
	"is_public":              "description.Finding.IsPublic",
	"principal":              "description.Finding.Principal",
	"resource":               "description.Finding.Resource",
	"resource_owner_account": "description.Finding.ResourceOwnerAccount",
	"resource_type":          "description.Finding.ResourceType",
	"sources":                "description.Finding.Sources",
	"status":                 "description.Finding.Status",
	"title":                  "description.Finding.Id",
	"updated_at":             "description.Finding.UpdatedAt",
}

func GetAccessAnalyzerAnalyzerFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessAnalyzerAnalyzerFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessAnalyzerAnalyzerFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessAnalyzerAnalyzerFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessAnalyzerAnalyzerFinding =============================

// ==========================  START: ApiGatewayStage =============================

type ApiGatewayStage struct {
	Description   aws.ApiGatewayStageDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type ApiGatewayStageHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  ApiGatewayStage `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type ApiGatewayStageHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []ApiGatewayStageHit `json:"hits"`
}

type ApiGatewayStageSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  ApiGatewayStageHits `json:"hits"`
}

type ApiGatewayStagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayStagePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayStagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_stage", filters, limit)
	if err != nil {
		return ApiGatewayStagePaginator{}, err
	}

	p := ApiGatewayStagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayStagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayStagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayStagePaginator) NextPage(ctx context.Context) ([]ApiGatewayStage, error) {
	var response ApiGatewayStageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayStage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayStageFilters = map[string]string{
	"access_log_settings":   "description.Stage.AccessLogSettings",
	"arn":                   "arn",
	"cache_cluster_enabled": "description.Stage.CacheClusterEnabled",
	"cache_cluster_size":    "description.Stage.CacheClusterSize",
	"cache_cluster_status":  "description.Stage.CacheClusterStatus",
	"canary_settings":       "description.Stage.CanarySettings",
	"client_certificate_id": "description.Stage.ClientCertificateId",
	"created_date":          "description.Stage.CreatedDate",
	"deployment_id":         "description.Stage.DeploymentId",
	"description":           "description.Stage.Description",
	"documentation_version": "description.Stage.DocumentationVersion",
	"og_account_id":         "metadata.SourceID",
	"last_updated_date":     "description.Stage.LastUpdatedDate",
	"method_settings":       "description.Stage.MethodSettings",
	"name":                  "description.Stage.StageName",
	"rest_api_id":           "description.RestApiId",
	"tags":                  "description.Stage.Tags",
	"title":                 "description.Stage.StageName",
	"tracing_enabled":       "description.Stage.TracingEnabled",
	"variables":             "description.Stage.Variables",
	"web_acl_arn":           "description.Stage.WebAclArn",
}

func ListApiGatewayStage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayStage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayStage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayStage NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayStage GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayStage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayStage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayStagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayStageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayStage NewApiGatewayStagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayStage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayStageFilters = map[string]string{
	"access_log_settings":   "description.Stage.AccessLogSettings",
	"arn":                   "arn",
	"cache_cluster_enabled": "description.Stage.CacheClusterEnabled",
	"cache_cluster_size":    "description.Stage.CacheClusterSize",
	"cache_cluster_status":  "description.Stage.CacheClusterStatus",
	"canary_settings":       "description.Stage.CanarySettings",
	"client_certificate_id": "description.Stage.ClientCertificateId",
	"created_date":          "description.Stage.CreatedDate",
	"deployment_id":         "description.Stage.DeploymentId",
	"description":           "description.Stage.Description",
	"documentation_version": "description.Stage.DocumentationVersion",
	"og_account_id":         "metadata.SourceID",
	"last_updated_date":     "description.Stage.LastUpdatedDate",
	"method_settings":       "description.Stage.MethodSettings",
	"name":                  "description.Stage.StageName",
	"rest_api_id":           "description.RestApiId",
	"tags":                  "description.Stage.Tags",
	"title":                 "description.Stage.StageName",
	"tracing_enabled":       "description.Stage.TracingEnabled",
	"variables":             "description.Stage.Variables",
	"web_acl_arn":           "description.Stage.WebAclArn",
}

func GetApiGatewayStage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayStage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayStagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayStageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayStage =============================

// ==========================  START: ApiGatewayV2Stage =============================

type ApiGatewayV2Stage struct {
	Description   aws.ApiGatewayV2StageDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ApiGatewayV2StageHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ApiGatewayV2Stage `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ApiGatewayV2StageHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ApiGatewayV2StageHit `json:"hits"`
}

type ApiGatewayV2StageSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ApiGatewayV2StageHits `json:"hits"`
}

type ApiGatewayV2StagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2StagePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2StagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_stage", filters, limit)
	if err != nil {
		return ApiGatewayV2StagePaginator{}, err
	}

	p := ApiGatewayV2StagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2StagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2StagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayV2StagePaginator) NextPage(ctx context.Context) ([]ApiGatewayV2Stage, error) {
	var response ApiGatewayV2StageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2Stage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2StageFilters = map[string]string{
	"access_log_settings":                    "description.Stage.AccessLogSettings",
	"api_gateway_managed":                    "description.Stage.ApiGatewayManaged",
	"api_id":                                 "description.ApiId",
	"auto_deploy":                            "description.Stage.AutoDeploy",
	"client_certificate_id":                  "description.Stage.ClientCertificateId",
	"created_date":                           "description.Stage.CreatedDate",
	"default_route_data_trace_enabled":       "description.Stage.DefaultRouteSettings.DataTraceEnabled",
	"default_route_detailed_metrics_enabled": "description.Stage.DefaultRouteSettings.DetailedMetricsEnabled",
	"default_route_logging_level":            "description.Stage.DefaultRouteSettings.LoggingLevel",
	"default_route_throttling_burst_limit":   "description.Stage.DefaultRouteSettings.ThrottlingBurstLimit",
	"default_route_throttling_rate_limit":    "description.Stage.DefaultRouteSettings.ThrottlingRateLimit",
	"deployment_id":                          "description.Stage.DeploymentId",
	"description":                            "description.Stage.Description",
	"og_account_id":                          "metadata.SourceID",
	"last_deployment_status_message":         "description.Stage.LastDeploymentStatusMessage",
	"last_updated_date":                      "description.Stage.LastUpdatedDate",
	"stage_name":                             "description.Stage.StageName",
	"stage_variables":                        "description.Stage.StageVariables",
	"tags":                                   "description.Stage.Tags",
	"title":                                  "description.Stage.StageName",
}

func ListApiGatewayV2Stage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2Stage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Stage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Stage NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Stage GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Stage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Stage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayV2StagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayV2StageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Stage NewApiGatewayV2StagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayV2Stage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayV2StageFilters = map[string]string{
	"access_log_settings":                    "description.Stage.AccessLogSettings",
	"api_gateway_managed":                    "description.Stage.ApiGatewayManaged",
	"api_id":                                 "description.ApiId",
	"auto_deploy":                            "description.Stage.AutoDeploy",
	"client_certificate_id":                  "description.Stage.ClientCertificateId",
	"created_date":                           "description.Stage.CreatedDate",
	"default_route_data_trace_enabled":       "description.Stage.DefaultRouteSettings.DataTraceEnabled",
	"default_route_detailed_metrics_enabled": "description.Stage.DefaultRouteSettings.DetailedMetricsEnabled",
	"default_route_logging_level":            "description.Stage.DefaultRouteSettings.LoggingLevel",
	"default_route_throttling_burst_limit":   "description.Stage.DefaultRouteSettings.ThrottlingBurstLimit",
	"default_route_throttling_rate_limit":    "description.Stage.DefaultRouteSettings.ThrottlingRateLimit",
	"deployment_id":                          "description.Stage.DeploymentId",
	"description":                            "description.Stage.Description",
	"og_account_id":                          "metadata.SourceID",
	"last_deployment_status_message":         "description.Stage.LastDeploymentStatusMessage",
	"last_updated_date":                      "description.Stage.LastUpdatedDate",
	"name":                                   "description.Stage.StageName",
	"stage_name":                             "description.Stage.StageName",
	"stage_variables":                        "description.Stage.StageVariables",
	"tags":                                   "description.Stage.Tags",
	"title":                                  "description.Stage.StageName",
}

func GetApiGatewayV2Stage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2Stage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2StagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayV2StageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2Stage =============================

// ==========================  START: ApiGatewayRestAPI =============================

type ApiGatewayRestAPI struct {
	Description   aws.ApiGatewayRestAPIDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ApiGatewayRestAPIHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ApiGatewayRestAPI `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ApiGatewayRestAPIHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ApiGatewayRestAPIHit `json:"hits"`
}

type ApiGatewayRestAPISearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ApiGatewayRestAPIHits `json:"hits"`
}

type ApiGatewayRestAPIPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayRestAPIPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayRestAPIPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_restapi", filters, limit)
	if err != nil {
		return ApiGatewayRestAPIPaginator{}, err
	}

	p := ApiGatewayRestAPIPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayRestAPIPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayRestAPIPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayRestAPIPaginator) NextPage(ctx context.Context) ([]ApiGatewayRestAPI, error) {
	var response ApiGatewayRestAPISearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayRestAPI
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayRestAPIFilters = map[string]string{
	"api_id":                       "description.RestAPI.Id",
	"api_key_source":               "description.RestAPI.ApiKeySource",
	"binary_media_types":           "description.RestAPI.BinaryMediaTypes",
	"created_date":                 "description.RestAPI.CreatedDate",
	"description":                  "description.RestAPI.Description",
	"endpoint_configuration_types": "description.RestAPI.EndpointConfiguration.Types",
	"endpoint_configuration_vpc_endpoint_ids": "description.RestAPI.EndpointConfiguration.VpcEndpointIds",
	"og_account_id":            "metadata.SourceID",
	"minimum_compression_size": "description.RestAPI.MinimumCompressionSize",
	"name":                     "description.RestAPI.Name",
	"tags":                     "description.RestAPI.Tags",
	"title":                    "description.RestAPI.Name",
	"version":                  "description.RestAPI.Version",
	"warnings":                 "description.RestAPI.Warnings",
}

func ListApiGatewayRestAPI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayRestAPI")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayRestAPI NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayRestAPI NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayRestAPI GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayRestAPI GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayRestAPI GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayRestAPIPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayRestAPIFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayRestAPI NewApiGatewayRestAPIPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayRestAPI paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayRestAPIFilters = map[string]string{
	"api_id":                       "description.RestAPI.Id",
	"api_key_source":               "description.RestAPI.ApiKeySource",
	"binary_media_types":           "description.RestAPI.BinaryMediaTypes",
	"created_date":                 "description.RestAPI.CreatedDate",
	"description":                  "description.RestAPI.Description",
	"endpoint_configuration_types": "description.RestAPI.EndpointConfiguration.Types",
	"endpoint_configuration_vpc_endpoint_ids": "description.RestAPI.EndpointConfiguration.VpcEndpointIds",
	"og_account_id":            "metadata.SourceID",
	"minimum_compression_size": "description.RestAPI.MinimumCompressionSize",
	"name":                     "description.RestAPI.Name",
	"tags":                     "description.RestAPI.Tags",
	"title":                    "description.RestAPI.Name",
	"version":                  "description.RestAPI.Version",
	"warnings":                 "description.RestAPI.Warnings",
}

func GetApiGatewayRestAPI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayRestAPI")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayRestAPIPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayRestAPIFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayRestAPI =============================

// ==========================  START: ApiGatewayApiKey =============================

type ApiGatewayApiKey struct {
	Description   aws.ApiGatewayApiKeyDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type ApiGatewayApiKeyHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ApiGatewayApiKey `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ApiGatewayApiKeyHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ApiGatewayApiKeyHit `json:"hits"`
}

type ApiGatewayApiKeySearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ApiGatewayApiKeyHits `json:"hits"`
}

type ApiGatewayApiKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayApiKeyPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayApiKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_apikey", filters, limit)
	if err != nil {
		return ApiGatewayApiKeyPaginator{}, err
	}

	p := ApiGatewayApiKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayApiKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayApiKeyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayApiKeyPaginator) NextPage(ctx context.Context) ([]ApiGatewayApiKey, error) {
	var response ApiGatewayApiKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayApiKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayApiKeyFilters = map[string]string{
	"created_date":      "description.ApiKey.CreatedDate",
	"customer_id":       "description.ApiKey.CustomerId",
	"description":       "description.ApiKey.Description",
	"enabled":           "description.ApiKey.Enabled",
	"id":                "description.ApiKey.Id",
	"og_account_id":     "metadata.SourceID",
	"last_updated_date": "description.ApiKey.LastUpdatedDate",
	"name":              "description.ApiKey.Name",
	"tags_src":          "tags",
	"title":             "name",
	"value":             "description.ApiKey.Value",
}

func ListApiGatewayApiKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayApiKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayApiKey NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayApiKey NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayApiKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayApiKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayApiKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayApiKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayApiKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayApiKey NewApiGatewayApiKeyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayApiKey paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayApiKeyFilters = map[string]string{
	"created_date":      "description.ApiKey.CreatedDate",
	"customer_id":       "description.ApiKey.CustomerId",
	"description":       "description.ApiKey.Description",
	"enabled":           "description.ApiKey.Enabled",
	"id":                "description.ApiKey.Id",
	"og_account_id":     "metadata.SourceID",
	"last_updated_date": "description.ApiKey.LastUpdatedDate",
	"name":              "description.ApiKey.Name",
	"tags_src":          "tags",
	"title":             "name",
	"value":             "description.ApiKey.Value",
}

func GetApiGatewayApiKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayApiKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayApiKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayApiKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayApiKey =============================

// ==========================  START: ApiGatewayUsagePlan =============================

type ApiGatewayUsagePlan struct {
	Description   aws.ApiGatewayUsagePlanDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type ApiGatewayUsagePlanHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ApiGatewayUsagePlan `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ApiGatewayUsagePlanHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ApiGatewayUsagePlanHit `json:"hits"`
}

type ApiGatewayUsagePlanSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ApiGatewayUsagePlanHits `json:"hits"`
}

type ApiGatewayUsagePlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayUsagePlanPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayUsagePlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_usageplan", filters, limit)
	if err != nil {
		return ApiGatewayUsagePlanPaginator{}, err
	}

	p := ApiGatewayUsagePlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayUsagePlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayUsagePlanPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayUsagePlanPaginator) NextPage(ctx context.Context) ([]ApiGatewayUsagePlan, error) {
	var response ApiGatewayUsagePlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayUsagePlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayUsagePlanFilters = map[string]string{
	"api_stages":    "description.UsagePlan.ApiStages",
	"description":   "description.UsagePlan.Description",
	"id":            "description.UsagePlan.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.UsagePlan.Name",
	"product_code":  "description.UsagePlan.ProductCode",
	"quota":         "description.UsagePlan.Quota",
	"tags":          "description.UsagePlan.Tags",
	"throttle":      "description.UsagePlan.Throttle",
	"title":         "description.UsagePlan.Name",
}

func ListApiGatewayUsagePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayUsagePlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayUsagePlan NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayUsagePlan NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayUsagePlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayUsagePlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayUsagePlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayUsagePlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayUsagePlanFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayUsagePlan NewApiGatewayUsagePlanPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayUsagePlan paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayUsagePlanFilters = map[string]string{
	"api_stages":    "description.UsagePlan.ApiStages",
	"description":   "description.UsagePlan.Description",
	"id":            "description.UsagePlan.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.UsagePlan.Name",
	"product_code":  "description.UsagePlan.ProductCode",
	"quota":         "description.UsagePlan.Quota",
	"tags":          "description.UsagePlan.Tags",
	"throttle":      "description.UsagePlan.Throttle",
	"title":         "description.UsagePlan.Name",
}

func GetApiGatewayUsagePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayUsagePlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayUsagePlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayUsagePlanFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayUsagePlan =============================

// ==========================  START: ApiGatewayAuthorizer =============================

type ApiGatewayAuthorizer struct {
	Description   aws.ApiGatewayAuthorizerDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ApiGatewayAuthorizerHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ApiGatewayAuthorizer `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ApiGatewayAuthorizerHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ApiGatewayAuthorizerHit `json:"hits"`
}

type ApiGatewayAuthorizerSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ApiGatewayAuthorizerHits `json:"hits"`
}

type ApiGatewayAuthorizerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayAuthorizerPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayAuthorizerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_authorizer", filters, limit)
	if err != nil {
		return ApiGatewayAuthorizerPaginator{}, err
	}

	p := ApiGatewayAuthorizerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayAuthorizerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayAuthorizerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayAuthorizerPaginator) NextPage(ctx context.Context) ([]ApiGatewayAuthorizer, error) {
	var response ApiGatewayAuthorizerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayAuthorizer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayAuthorizerFilters = map[string]string{
	"auth_type":                      "description.Authorizer.AuthType",
	"authorizer_credentials":         "description.Authorizer.AuthorizerCredentials",
	"authorizer_uri":                 "description.Authorizer.AuthorizerUri",
	"id":                             "description.Authorizer.Id",
	"identity_source":                "description.Authorizer.IdentitySource",
	"identity_validation_expression": "description.Authorizer.IdentityValidationExpression",
	"og_account_id":                  "metadata.SourceID",
	"name":                           "description.Authorizer.Name",
	"provider_arns":                  "description.Authorizer.ProviderARNs",
	"rest_api_id":                    "description.RestApiId",
	"title":                          "description.Authorizer.Name",
}

func ListApiGatewayAuthorizer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayAuthorizer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayAuthorizer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayAuthorizer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayAuthorizer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayAuthorizer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayAuthorizer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayAuthorizerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayAuthorizerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayAuthorizer NewApiGatewayAuthorizerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayAuthorizer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayAuthorizerFilters = map[string]string{
	"auth_type":                      "description.Authorizer.AuthType",
	"authorizer_credentials":         "description.Authorizer.AuthorizerCredentials",
	"authorizer_uri":                 "description.Authorizer.AuthorizerUri",
	"id":                             "description.Authorizer.Id",
	"identity_source":                "description.Authorizer.IdentitySource",
	"identity_validation_expression": "description.Authorizer.IdentityValidationExpression",
	"og_account_id":                  "metadata.SourceID",
	"name":                           "description.Authorizer.Name",
	"provider_arns":                  "description.Authorizer.ProviderARNs",
	"rest_api_id":                    "description.RestApiId",
	"title":                          "description.Authorizer.Name",
}

func GetApiGatewayAuthorizer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayAuthorizer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayAuthorizerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayAuthorizerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayAuthorizer =============================

// ==========================  START: ApiGatewayV2API =============================

type ApiGatewayV2API struct {
	Description   aws.ApiGatewayV2APIDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type ApiGatewayV2APIHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  ApiGatewayV2API `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type ApiGatewayV2APIHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []ApiGatewayV2APIHit `json:"hits"`
}

type ApiGatewayV2APISearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  ApiGatewayV2APIHits `json:"hits"`
}

type ApiGatewayV2APIPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2APIPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2APIPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_api", filters, limit)
	if err != nil {
		return ApiGatewayV2APIPaginator{}, err
	}

	p := ApiGatewayV2APIPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2APIPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2APIPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayV2APIPaginator) NextPage(ctx context.Context) ([]ApiGatewayV2API, error) {
	var response ApiGatewayV2APISearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2API
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2APIFilters = map[string]string{
	"api_endpoint":                 "description.API.ApiEndpoint",
	"api_id":                       "description.API.ApiId",
	"api_key_selection_expression": "description.API.ApiKeySelectionExpression",
	"created_date":                 "description.API.CreatedDate",
	"disable_execute_api_endpoint": "description.API.DisableExecuteApiEndpoint",
	"og_account_id":                "metadata.SourceID",
	"name":                         "description.API.Name",
	"protocol_type":                "description.API.ProtocolType",
	"route_selection_expression":   "description.API.RouteSelectionExpression",
	"tags":                         "description.API.Tags",
	"title":                        "description.API.Name",
}

func ListApiGatewayV2API(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2API")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2API NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2API NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2API GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2API GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2API GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayV2APIPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayV2APIFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2API NewApiGatewayV2APIPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayV2API paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayV2APIFilters = map[string]string{
	"api_endpoint":                 "description.API.ApiEndpoint",
	"api_id":                       "description.API.ApiId",
	"api_key_selection_expression": "description.API.ApiKeySelectionExpression",
	"created_date":                 "description.API.CreatedDate",
	"disable_execute_api_endpoint": "description.API.DisableExecuteApiEndpoint",
	"og_account_id":                "metadata.SourceID",
	"name":                         "description.API.Name",
	"protocol_type":                "description.API.ProtocolType",
	"route_selection_expression":   "description.API.RouteSelectionExpression",
	"tags":                         "description.API.Tags",
	"title":                        "description.API.Name",
}

func GetApiGatewayV2API(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2API")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2APIPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayV2APIFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2API =============================

// ==========================  START: ApiGatewayV2DomainName =============================

type ApiGatewayV2DomainName struct {
	Description   aws.ApiGatewayV2DomainNameDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ApiGatewayV2DomainNameHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ApiGatewayV2DomainName `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ApiGatewayV2DomainNameHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ApiGatewayV2DomainNameHit `json:"hits"`
}

type ApiGatewayV2DomainNameSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ApiGatewayV2DomainNameHits `json:"hits"`
}

type ApiGatewayV2DomainNamePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2DomainNamePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2DomainNamePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_domainname", filters, limit)
	if err != nil {
		return ApiGatewayV2DomainNamePaginator{}, err
	}

	p := ApiGatewayV2DomainNamePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2DomainNamePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2DomainNamePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayV2DomainNamePaginator) NextPage(ctx context.Context) ([]ApiGatewayV2DomainName, error) {
	var response ApiGatewayV2DomainNameSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2DomainName
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2DomainNameFilters = map[string]string{
	"api_mapping_selection_expression": "description.ApiMappingSelectionExpression",
	"domain_name":                      "description.DomainName.DomainName",
	"domain_name_configurations":       "description.DomainName.DomainNameConfigurations",
	"og_account_id":                    "metadata.SourceID",
	"mutual_tls_authentication":        "description.DomainName.MutualTlsAuthentication",
	"tags":                             "description.DomainName.Tags",
	"title":                            "description.DomainName.DomainName",
}

func ListApiGatewayV2DomainName(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2DomainName")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2DomainName NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2DomainName NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2DomainName GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2DomainName GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2DomainName GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayV2DomainNamePaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayV2DomainNameFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2DomainName NewApiGatewayV2DomainNamePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayV2DomainName paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayV2DomainNameFilters = map[string]string{
	"api_mapping_selection_expression": "description.ApiMappingSelectionExpression",
	"domain_name":                      "description.DomainName.DomainName",
	"domain_name_configurations":       "description.DomainName.DomainNameConfigurations",
	"og_account_id":                    "metadata.SourceID",
	"mutual_tls_authentication":        "description.DomainName.MutualTlsAuthentication",
	"tags":                             "description.DomainName.Tags",
	"title":                            "description.DomainName.DomainName",
}

func GetApiGatewayV2DomainName(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2DomainName")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2DomainNamePaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayV2DomainNameFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2DomainName =============================

// ==========================  START: ApiGatewayDomainName =============================

type ApiGatewayDomainName struct {
	Description   aws.ApiGatewayDomainNameDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ApiGatewayDomainNameHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ApiGatewayDomainName `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ApiGatewayDomainNameHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ApiGatewayDomainNameHit `json:"hits"`
}

type ApiGatewayDomainNameSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ApiGatewayDomainNameHits `json:"hits"`
}

type ApiGatewayDomainNamePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayDomainNamePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayDomainNamePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigateway_domainname", filters, limit)
	if err != nil {
		return ApiGatewayDomainNamePaginator{}, err
	}

	p := ApiGatewayDomainNamePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayDomainNamePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayDomainNamePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayDomainNamePaginator) NextPage(ctx context.Context) ([]ApiGatewayDomainName, error) {
	var response ApiGatewayDomainNameSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayDomainName
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayDomainNameFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"title":         "domainname",
}

func ListApiGatewayDomainName(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayDomainName")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayDomainName NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayDomainName NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayDomainName GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayDomainName GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayDomainName GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayDomainNamePaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayDomainNameFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayDomainName NewApiGatewayDomainNamePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayDomainName paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayDomainNameFilters = map[string]string{
	"domain_name":   "description.DomainName.DomainName",
	"og_account_id": "metadata.SourceID",
	"title":         "domainname",
}

func GetApiGatewayDomainName(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayDomainName")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayDomainNamePaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayDomainNameFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayDomainName =============================

// ==========================  START: ApiGatewayV2Route =============================

type ApiGatewayV2Route struct {
	Description   aws.ApiGatewayV2RouteDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ApiGatewayV2RouteHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ApiGatewayV2Route `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ApiGatewayV2RouteHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ApiGatewayV2RouteHit `json:"hits"`
}

type ApiGatewayV2RouteSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ApiGatewayV2RouteHits `json:"hits"`
}

type ApiGatewayV2RoutePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2RoutePaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2RoutePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_route", filters, limit)
	if err != nil {
		return ApiGatewayV2RoutePaginator{}, err
	}

	p := ApiGatewayV2RoutePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2RoutePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2RoutePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayV2RoutePaginator) NextPage(ctx context.Context) ([]ApiGatewayV2Route, error) {
	var response ApiGatewayV2RouteSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2Route
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2RouteFilters = map[string]string{
	"api_gateway_managed":                 "description.Route.ApiGatewayManaged",
	"api_key_required":                    "description.Route.ApiKeyRequired",
	"authorization_scopes":                "description.Route.AuthorizationScopes",
	"authorization_type":                  "description.Route.AuthorizationType",
	"authorizer_id":                       "description.Route.AuthorizerId",
	"og_account_id":                       "metadata.SourceID",
	"model_selection_expression":          "description.Route.ModelSelectionExpression",
	"operation_name":                      "description.Route.OperationName",
	"request_models":                      "description.Route.RequestModels",
	"request_parameters":                  "description.Route.RequestParameters",
	"route_id":                            "description.Route.RouteId",
	"route_key":                           "description.Route.RouteKey",
	"route_response_selection_expression": "description.Route.RouteResponseSelectionExpression",
	"target":                              "description.Route.Target",
	"title":                               "description.Route.RouteId",
}

func ListApiGatewayV2Route(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2Route")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Route NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Route NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Route GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Route GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Route GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayV2RoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayV2RouteFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Route NewApiGatewayV2RoutePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayV2Route paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayV2RouteFilters = map[string]string{
	"api_gateway_managed":                 "description.Route.ApiGatewayManaged",
	"api_key_required":                    "description.Route.ApiKeyRequired",
	"authorization_scopes":                "description.Route.AuthorizationScopes",
	"authorization_type":                  "description.Route.AuthorizationType",
	"authorizer_id":                       "description.Route.AuthorizerId",
	"domain_name":                         "description.DomainName.DomainName",
	"og_account_id":                       "metadata.SourceID",
	"model_selection_expression":          "description.Route.ModelSelectionExpression",
	"operation_name":                      "description.Route.OperationName",
	"request_models":                      "description.Route.RequestModels",
	"request_parameters":                  "description.Route.RequestParameters",
	"route_id":                            "description.Route.RouteId",
	"route_key":                           "description.Route.RouteKey",
	"route_response_selection_expression": "description.Route.RouteResponseSelectionExpression",
	"target":                              "description.Route.Target",
	"title":                               "description.Route.RouteId",
}

func GetApiGatewayV2Route(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2Route")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2RoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayV2RouteFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2Route =============================

// ==========================  START: ApiGatewayV2Integration =============================

type ApiGatewayV2Integration struct {
	Description   aws.ApiGatewayV2IntegrationDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type ApiGatewayV2IntegrationHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  ApiGatewayV2Integration `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type ApiGatewayV2IntegrationHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []ApiGatewayV2IntegrationHit `json:"hits"`
}

type ApiGatewayV2IntegrationSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  ApiGatewayV2IntegrationHits `json:"hits"`
}

type ApiGatewayV2IntegrationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiGatewayV2IntegrationPaginator(filters []essdk.BoolFilter, limit *int64) (ApiGatewayV2IntegrationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_apigatewayv2_integration", filters, limit)
	if err != nil {
		return ApiGatewayV2IntegrationPaginator{}, err
	}

	p := ApiGatewayV2IntegrationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiGatewayV2IntegrationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiGatewayV2IntegrationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiGatewayV2IntegrationPaginator) NextPage(ctx context.Context) ([]ApiGatewayV2Integration, error) {
	var response ApiGatewayV2IntegrationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiGatewayV2Integration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiGatewayV2IntegrationFilters = map[string]string{
	"api_gateway_managed":       "description.Integration.ApiGatewayManaged",
	"api_id":                    "description.ApiId",
	"connection_id":             "description.Integration.ConnectionId",
	"connection_type":           "description.Integration.ConnectionType",
	"content_handling_strategy": "description.Integration.ContentHandlingStrategy",
	"credentials_arn":           "description.Integration.CredentialsArn",
	"description":               "description.Integration.Description",
	"integration_id":            "description.Integration.IntegrationId",
	"integration_method":        "description.Integration.IntegrationMethod",
	"integration_response_selection_expression": "description.Integration.IntegrationResponseSelectionExpression",
	"integration_subtype":                       "description.Integration.IntegrationSubtype",
	"integration_type":                          "description.Integration.IntegrationType",
	"integration_uri":                           "description.Integration.IntegrationUri",
	"og_account_id":                             "metadata.SourceID",
	"passthrough_behavior":                      "description.Integration.PassthroughBehavior",
	"payload_format_version":                    "description.Integration.PayloadFormatVersion",
	"request_parameters":                        "description.Integration.RequestParameters",
	"request_templates":                         "description.Integration.RequestTemplates",
	"response_parameters":                       "description.Integration.ResponseParameters",
	"template_selection_expression":             "description.Integration.TemplateSelectionExpression",
	"timeout_in_millis":                         "description.Integration.TimeoutInMillis",
	"title":                                     "description.Integration.IntegrationId",
	"tls_config":                                "description.Integration.TlsConfig",
}

func ListApiGatewayV2Integration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiGatewayV2Integration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Integration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Integration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Integration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Integration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Integration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiGatewayV2IntegrationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiGatewayV2IntegrationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiGatewayV2Integration NewApiGatewayV2IntegrationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiGatewayV2Integration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiGatewayV2IntegrationFilters = map[string]string{
	"api_gateway_managed":       "description.Integration.ApiGatewayManaged",
	"api_id":                    "description.ApiId",
	"connection_id":             "description.Integration.ConnectionId",
	"connection_type":           "description.Integration.ConnectionType",
	"content_handling_strategy": "description.Integration.ContentHandlingStrategy",
	"credentials_arn":           "description.Integration.CredentialsArn",
	"description":               "description.Integration.Description",
	"integration_id":            "description.Integration.IntegrationId",
	"integration_method":        "description.Integration.IntegrationMethod",
	"integration_response_selection_expression": "description.Integration.IntegrationResponseSelectionExpression",
	"integration_subtype":                       "description.Integration.IntegrationSubtype",
	"integration_type":                          "description.Integration.IntegrationType",
	"integration_uri":                           "description.Integration.IntegrationUri",
	"og_account_id":                             "metadata.SourceID",
	"passthrough_behavior":                      "description.Integration.PassthroughBehavior",
	"payload_format_version":                    "description.Integration.PayloadFormatVersion",
	"request_parameters":                        "description.Integration.RequestParameters",
	"request_templates":                         "description.Integration.RequestTemplates",
	"response_parameters":                       "description.Integration.ResponseParameters",
	"template_selection_expression":             "description.Integration.TemplateSelectionExpression",
	"timeout_in_millis":                         "description.Integration.TimeoutInMillis",
	"title":                                     "description.Integration.IntegrationId",
	"tls_config":                                "description.Integration.TlsConfig",
}

func GetApiGatewayV2Integration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiGatewayV2Integration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiGatewayV2IntegrationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiGatewayV2IntegrationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiGatewayV2Integration =============================

// ==========================  START: ElasticBeanstalkEnvironment =============================

type ElasticBeanstalkEnvironment struct {
	Description   aws.ElasticBeanstalkEnvironmentDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ElasticBeanstalkEnvironmentHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ElasticBeanstalkEnvironment `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ElasticBeanstalkEnvironmentHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ElasticBeanstalkEnvironmentHit `json:"hits"`
}

type ElasticBeanstalkEnvironmentSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ElasticBeanstalkEnvironmentHits `json:"hits"`
}

type ElasticBeanstalkEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticBeanstalkEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticBeanstalkEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticbeanstalk_environment", filters, limit)
	if err != nil {
		return ElasticBeanstalkEnvironmentPaginator{}, err
	}

	p := ElasticBeanstalkEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticBeanstalkEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticBeanstalkEnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticBeanstalkEnvironmentPaginator) NextPage(ctx context.Context) ([]ElasticBeanstalkEnvironment, error) {
	var response ElasticBeanstalkEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticBeanstalkEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticBeanstalkEnvironmentFilters = map[string]string{
	"abortable_operation_in_progress": "description.EnvironmentDescription.AbortableOperationInProgress",
	"application_name":                "description.EnvironmentDescription.ApplicationName",
	"arn":                             "description.EnvironmentDescription.EnvironmentArn",
	"cname":                           "description.EnvironmentDescription.CNAME",
	"configuration_settings":          "description.ConfigurationSetting",
	"date_created":                    "description.EnvironmentDescription.DateCreated",
	"date_updated":                    "description.EnvironmentDescription.DateUpdated",
	"description":                     "description.EnvironmentDescription",
	"endpoint_url":                    "description.EnvironmentDescription.EndpointURL",
	"environment_id":                  "description.EnvironmentDescription.EnvironmentId",
	"environment_links":               "description.EnvironmentDescription.EnvironmentLinks",
	"environment_name":                "description.EnvironmentDescription.EnvironmentName",
	"health":                          "description.EnvironmentDescription.Health",
	"health_status":                   "description.EnvironmentDescription.HealthStatus",
	"og_account_id":                   "metadata.SourceID",
	"managed_actions":                 "description.ManagedAction",
	"operations_role":                 "description.EnvironmentDescription.OperationsRole",
	"platform_arn":                    "description.EnvironmentDescription.PlatformArn",
	"resources":                       "description.EnvironmentDescription.Resources",
	"solution_stack_name":             "description.EnvironmentDescription.SolutionStackName",
	"status":                          "description.EnvironmentDescription.Status",
	"tags_src":                        "description.Tags",
	"template_name":                   "description.EnvironmentDescription.TemplateName",
	"tier":                            "description.EnvironmentDescription.Tier",
	"title":                           "description.EnvironmentDescription.EnvironmentName",
	"version_label":                   "description.EnvironmentDescription.VersionLabel",
}

func ListElasticBeanstalkEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticBeanstalkEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticBeanstalkEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticBeanstalkEnvironmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkEnvironment NewElasticBeanstalkEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticBeanstalkEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticBeanstalkEnvironmentFilters = map[string]string{
	"abortable_operation_in_progress": "description.EnvironmentDescription.AbortableOperationInProgress",
	"application_name":                "description.EnvironmentDescription.ApplicationName",
	"arn":                             "description.EnvironmentDescription.EnvironmentArn",
	"cname":                           "description.EnvironmentDescription.CNAME",
	"configuration_settings":          "description.ConfigurationSetting",
	"date_created":                    "description.EnvironmentDescription.DateCreated",
	"date_updated":                    "description.EnvironmentDescription.DateUpdated",
	"description":                     "description.EnvironmentDescription",
	"endpoint_url":                    "description.EnvironmentDescription.EndpointURL",
	"environment_id":                  "description.EnvironmentDescription.EnvironmentId",
	"environment_links":               "description.EnvironmentDescription.EnvironmentLinks",
	"environment_name":                "description.EnvironmentDescription.EnvironmentName",
	"health":                          "description.EnvironmentDescription.Health",
	"health_status":                   "description.EnvironmentDescription.HealthStatus",
	"og_account_id":                   "metadata.SourceID",
	"managed_actions":                 "description.ManagedAction",
	"operations_role":                 "description.EnvironmentDescription.OperationsRole",
	"platform_arn":                    "description.EnvironmentDescription.PlatformArn",
	"resources":                       "description.EnvironmentDescription.Resources",
	"solution_stack_name":             "description.EnvironmentDescription.SolutionStackName",
	"status":                          "description.EnvironmentDescription.Status",
	"tags_src":                        "description.Tags",
	"template_name":                   "description.EnvironmentDescription.TemplateName",
	"tier":                            "description.EnvironmentDescription.Tier",
	"title":                           "description.EnvironmentDescription.EnvironmentName",
	"version_label":                   "description.EnvironmentDescription.VersionLabel",
}

func GetElasticBeanstalkEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticBeanstalkEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticBeanstalkEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticBeanstalkEnvironmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticBeanstalkEnvironment =============================

// ==========================  START: ElasticBeanstalkApplication =============================

type ElasticBeanstalkApplication struct {
	Description   aws.ElasticBeanstalkApplicationDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ElasticBeanstalkApplicationHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ElasticBeanstalkApplication `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ElasticBeanstalkApplicationHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ElasticBeanstalkApplicationHit `json:"hits"`
}

type ElasticBeanstalkApplicationSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ElasticBeanstalkApplicationHits `json:"hits"`
}

type ElasticBeanstalkApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticBeanstalkApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticBeanstalkApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticbeanstalk_application", filters, limit)
	if err != nil {
		return ElasticBeanstalkApplicationPaginator{}, err
	}

	p := ElasticBeanstalkApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticBeanstalkApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticBeanstalkApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticBeanstalkApplicationPaginator) NextPage(ctx context.Context) ([]ElasticBeanstalkApplication, error) {
	var response ElasticBeanstalkApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticBeanstalkApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticBeanstalkApplicationFilters = map[string]string{
	"arn":                       "description.Application.ApplicationArn",
	"configuration_templates":   "description.Application.ConfigurationTemplates",
	"date_created":              "description.Application.DateCreated",
	"date_updated":              "description.Application.DateUpdated",
	"description":               "description.Application.Description",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.Application.ApplicationName",
	"resource_lifecycle_config": "description.Application.ResourceLifecycleConfig",
	"tags_src":                  "description.Tags",
	"title":                     "description.Application.ApplicationName",
	"versions":                  "description.Application.Versions",
}

func ListElasticBeanstalkApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticBeanstalkApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticBeanstalkApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticBeanstalkApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplication NewElasticBeanstalkApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticBeanstalkApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticBeanstalkApplicationFilters = map[string]string{
	"arn":                       "description.Application.ApplicationArn",
	"configuration_templates":   "description.Application.ConfigurationTemplates",
	"date_created":              "description.Application.DateCreated",
	"date_updated":              "description.Application.DateUpdated",
	"description":               "description.Application.Description",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.Application.ApplicationName",
	"resource_lifecycle_config": "description.Application.ResourceLifecycleConfig",
	"tags_src":                  "description.Tags",
	"title":                     "description.Application.ApplicationName",
	"versions":                  "description.Application.Versions",
}

func GetElasticBeanstalkApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticBeanstalkApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticBeanstalkApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticBeanstalkApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticBeanstalkApplication =============================

// ==========================  START: ElasticBeanstalkApplicationVersion =============================

type ElasticBeanstalkApplicationVersion struct {
	Description   aws.ElasticBeanstalkApplicationVersionDescription `json:"description"`
	Metadata      aws.Metadata                                      `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type ElasticBeanstalkApplicationVersionHit struct {
	ID      string                             `json:"_id"`
	Score   float64                            `json:"_score"`
	Index   string                             `json:"_index"`
	Type    string                             `json:"_type"`
	Version int64                              `json:"_version,omitempty"`
	Source  ElasticBeanstalkApplicationVersion `json:"_source"`
	Sort    []interface{}                      `json:"sort"`
}

type ElasticBeanstalkApplicationVersionHits struct {
	Total essdk.SearchTotal                       `json:"total"`
	Hits  []ElasticBeanstalkApplicationVersionHit `json:"hits"`
}

type ElasticBeanstalkApplicationVersionSearchResponse struct {
	PitID string                                 `json:"pit_id"`
	Hits  ElasticBeanstalkApplicationVersionHits `json:"hits"`
}

type ElasticBeanstalkApplicationVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticBeanstalkApplicationVersionPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticBeanstalkApplicationVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticbeanstalk_applicationversion", filters, limit)
	if err != nil {
		return ElasticBeanstalkApplicationVersionPaginator{}, err
	}

	p := ElasticBeanstalkApplicationVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticBeanstalkApplicationVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticBeanstalkApplicationVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticBeanstalkApplicationVersionPaginator) NextPage(ctx context.Context) ([]ElasticBeanstalkApplicationVersion, error) {
	var response ElasticBeanstalkApplicationVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticBeanstalkApplicationVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticBeanstalkApplicationVersionFilters = map[string]string{
	"application_name":         "description.ApplicationVersion.ApplicationName",
	"application_version_arn":  "description.ApplicationVersion.ApplicationVersionArn",
	"build_arn":                "description.ApplicationVersion.BuildArn",
	"date_created":             "description.ApplicationVersion.DateCreated",
	"date_updated":             "description.ApplicationVersion.DateUpdated",
	"description":              "description.ApplicationVersion.Description",
	"source_build_information": "description.ApplicationVersion.SourceBuildInformation",
	"source_bundle":            "description.ApplicationVersion.SourceBundle",
	"status":                   "description.ApplicationVersion.Status",
	"tags_src":                 "description.Tags",
	"title":                    "description.ApplicationVersion.VersionLabel",
	"version_label":            "description.ApplicationVersion.VersionLabel",
}

func ListElasticBeanstalkApplicationVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticBeanstalkApplicationVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplicationVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplicationVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplicationVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplicationVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplicationVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticBeanstalkApplicationVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticBeanstalkApplicationVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticBeanstalkApplicationVersion NewElasticBeanstalkApplicationVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticBeanstalkApplicationVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticBeanstalkApplicationVersionFilters = map[string]string{
	"application_name":         "description.ApplicationVersion.ApplicationName",
	"application_version_arn":  "description.ApplicationVersion.ApplicationVersionArn",
	"build_arn":                "description.ApplicationVersion.BuildArn",
	"date_created":             "description.ApplicationVersion.DateCreated",
	"date_updated":             "description.ApplicationVersion.DateUpdated",
	"description":              "description.ApplicationVersion.Description",
	"source_build_information": "description.ApplicationVersion.SourceBuildInformation",
	"source_bundle":            "description.ApplicationVersion.SourceBundle",
	"status":                   "description.ApplicationVersion.Status",
	"tags_src":                 "description.Tags",
	"title":                    "description.ApplicationVersion.VersionLabel",
	"version_label":            "description.ApplicationVersion.VersionLabel",
}

func GetElasticBeanstalkApplicationVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticBeanstalkApplicationVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticBeanstalkApplicationVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticBeanstalkApplicationVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticBeanstalkApplicationVersion =============================

// ==========================  START: ElastiCacheReplicationGroup =============================

type ElastiCacheReplicationGroup struct {
	Description   aws.ElastiCacheReplicationGroupDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ElastiCacheReplicationGroupHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ElastiCacheReplicationGroup `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ElastiCacheReplicationGroupHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ElastiCacheReplicationGroupHit `json:"hits"`
}

type ElastiCacheReplicationGroupSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ElastiCacheReplicationGroupHits `json:"hits"`
}

type ElastiCacheReplicationGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheReplicationGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheReplicationGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_replicationgroup", filters, limit)
	if err != nil {
		return ElastiCacheReplicationGroupPaginator{}, err
	}

	p := ElastiCacheReplicationGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheReplicationGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheReplicationGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElastiCacheReplicationGroupPaginator) NextPage(ctx context.Context) ([]ElastiCacheReplicationGroup, error) {
	var response ElastiCacheReplicationGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheReplicationGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheReplicationGroupFilters = map[string]string{
	"arn":                           "description.ReplicationGroup.ARN",
	"at_rest_encryption_enabled":    "description.ReplicationGroup.AtRestEncryptionEnabled",
	"auth_token_enabled":            "description.ReplicationGroup.AuthTokenEnabled",
	"auth_token_last_modified_date": "description.ReplicationGroup.AuthTokenLastModifiedDate",
	"automatic_failover":            "description.ReplicationGroup.AutomaticFailover",
	"cache_node_type":               "description.ReplicationGroup.CacheNodeType",
	"cluster_enabled":               "description.ReplicationGroup.ClusterEnabled",
	"configuration_endpoint":        "description.ReplicationGroup.ConfigurationEndpoint",
	"description":                   "description.ReplicationGroup.Description",
	"global_replication_group_info": "description.ReplicationGroup.GlobalReplicationGroupInfo",
	"og_account_id":                 "metadata.SourceID",
	"kms_key_id":                    "description.ReplicationGroup.KmsKeyId",
	"member_clusters":               "description.ReplicationGroup.MemberClusters",
	"member_clusters_outpost_arns":  "description.ReplicationGroup.MemberClustersOutpostArns",
	"multi_az":                      "description.ReplicationGroup.MultiAZ",
	"node_groups":                   "description.ReplicationGroup.NodeGroups",
	"pending_modified_values":       "description.ReplicationGroup.PendingModifiedValues",
	"replication_group_id":          "description.ReplicationGroup.ReplicationGroupId",
	"snapshot_retention_limit":      "description.ReplicationGroup.SnapshotRetentionLimit",
	"snapshot_window":               "description.ReplicationGroup.SnapshotWindow",
	"snapshotting_cluster_id":       "description.ReplicationGroup.SnapshottingClusterId",
	"status":                        "description.ReplicationGroup.Status",
	"title":                         "description.ReplicationGroup.ReplicationGroupId",
	"transit_encryption_enabled":    "description.ReplicationGroup.TransitEncryptionEnabled",
	"user_group_ids":                "description.ReplicationGroup.UserGroupIds",
}

func ListElastiCacheReplicationGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheReplicationGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReplicationGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReplicationGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReplicationGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReplicationGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReplicationGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElastiCacheReplicationGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElastiCacheReplicationGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReplicationGroup NewElastiCacheReplicationGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElastiCacheReplicationGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElastiCacheReplicationGroupFilters = map[string]string{
	"arn":                           "description.ReplicationGroup.ARN",
	"at_rest_encryption_enabled":    "description.ReplicationGroup.AtRestEncryptionEnabled",
	"auth_token_enabled":            "description.ReplicationGroup.AuthTokenEnabled",
	"auth_token_last_modified_date": "description.ReplicationGroup.AuthTokenLastModifiedDate",
	"automatic_failover":            "description.ReplicationGroup.AutomaticFailover",
	"cache_node_type":               "description.ReplicationGroup.CacheNodeType",
	"cluster_enabled":               "description.ReplicationGroup.ClusterEnabled",
	"configuration_endpoint":        "description.ReplicationGroup.ConfigurationEndpoint",
	"description":                   "description.ReplicationGroup.Description",
	"global_replication_group_info": "description.ReplicationGroup.GlobalReplicationGroupInfo",
	"og_account_id":                 "metadata.SourceID",
	"kms_key_id":                    "description.ReplicationGroup.KmsKeyId",
	"member_clusters":               "description.ReplicationGroup.MemberClusters",
	"member_clusters_outpost_arns":  "description.ReplicationGroup.MemberClustersOutpostArns",
	"multi_az":                      "description.ReplicationGroup.MultiAZ",
	"node_groups":                   "description.ReplicationGroup.NodeGroups",
	"pending_modified_values":       "description.ReplicationGroup.PendingModifiedValues",
	"replication_group_id":          "description.ReplicationGroup.ReplicationGroupId",
	"snapshot_retention_limit":      "description.ReplicationGroup.SnapshotRetentionLimit",
	"snapshot_window":               "description.ReplicationGroup.SnapshotWindow",
	"snapshotting_cluster_id":       "description.ReplicationGroup.SnapshottingClusterId",
	"status":                        "description.ReplicationGroup.Status",
	"title":                         "description.ReplicationGroup.ReplicationGroupId",
	"transit_encryption_enabled":    "description.ReplicationGroup.TransitEncryptionEnabled",
	"user_group_ids":                "description.ReplicationGroup.UserGroupIds",
}

func GetElastiCacheReplicationGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheReplicationGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElastiCacheReplicationGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElastiCacheReplicationGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElastiCacheReplicationGroup =============================

// ==========================  START: ElastiCacheCluster =============================

type ElastiCacheCluster struct {
	Description   aws.ElastiCacheClusterDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type ElastiCacheClusterHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ElastiCacheCluster `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ElastiCacheClusterHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []ElastiCacheClusterHit `json:"hits"`
}

type ElastiCacheClusterSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ElastiCacheClusterHits `json:"hits"`
}

type ElastiCacheClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheClusterPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_cluster", filters, limit)
	if err != nil {
		return ElastiCacheClusterPaginator{}, err
	}

	p := ElastiCacheClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElastiCacheClusterPaginator) NextPage(ctx context.Context) ([]ElastiCacheCluster, error) {
	var response ElastiCacheClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheClusterFilters = map[string]string{
	"arn":                                    "description.Cluster.ARN",
	"at_rest_encryption_enabled":             "description.Cluster.AtRestEncryptionEnabled",
	"auth_token_enabled":                     "description.Cluster.AuthTokenEnabled",
	"auth_token_last_modified_date":          "description.Cluster.AuthTokenLastModifiedDate",
	"auto_minor_version_upgrade":             "description.Cluster.AutoMinorVersionUpgrade",
	"cache_cluster_create_time":              "description.Cluster.CacheClusterCreateTime",
	"cache_cluster_id":                       "description.Cluster.CacheClusterId",
	"cache_cluster_status":                   "description.Cluster.CacheClusterStatus",
	"cache_node_type":                        "description.Cluster.CacheNodeType",
	"cache_nodes":                            "description.Cluster.CacheNodes",
	"cache_parameter_group":                  "description.Cluster.CacheParameterGroup",
	"cache_security_groups":                  "description.Cluster.CacheSecurityGroups",
	"cache_subnet_group_name":                "description.Cluster.CacheSubnetGroupName",
	"client_download_landing_page":           "description.Cluster.ClientDownloadLandingPage",
	"configuration_endpoint":                 "description.Cluster.ConfigurationEndpoint",
	"engine":                                 "description.Cluster.Engine",
	"engine_version":                         "description.Cluster.EngineVersion",
	"ip_discovery":                           "description.Cluster.IpDiscovery",
	"og_account_id":                          "metadata.SourceID",
	"log_delivery_configurations":            "description.Cluster.LogDeliveryConfigurations",
	"network_type":                           "description.Cluster.NetworkType",
	"notification_configuration":             "description.Cluster.NotificationConfiguration",
	"num_cache_nodes":                        "description.Cluster.NumCacheNodes",
	"pending_modified_values":                "description.Cluster.PendingModifiedValues",
	"preferred_availability_zone":            "description.Cluster.PreferredAvailabilityZone",
	"preferred_maintenance_window":           "description.Cluster.PreferredMaintenanceWindow",
	"preferred_outpost_arn":                  "description.Cluster.PreferredOutpostArn",
	"replication_group_id":                   "description.Cluster.ReplicationGroupId",
	"replication_group_log_delivery_enabled": "description.Cluster.ReplicationGroupLogDeliveryEnabled",
	"security_groups":                        "description.Cluster.SecurityGroups",
	"snapshot_retention_limit":               "description.Cluster.SnapshotRetentionLimit",
	"snapshot_window":                        "description.Cluster.SnapshotWindow",
	"tags_src":                               "description.TagList",
	"title":                                  "description.Cluster.CacheClusterId",
	"transit_encryption_enabled":             "description.Cluster.TransitEncryptionEnabled",
	"transit_encryption_mode":                "description.Cluster.TransitEncryptionMode",
}

func ListElastiCacheCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElastiCacheClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElastiCacheClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheCluster NewElastiCacheClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElastiCacheCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElastiCacheClusterFilters = map[string]string{
	"arn":                                    "description.Cluster.ARN",
	"at_rest_encryption_enabled":             "description.Cluster.AtRestEncryptionEnabled",
	"auth_token_enabled":                     "description.Cluster.AuthTokenEnabled",
	"auth_token_last_modified_date":          "description.Cluster.AuthTokenLastModifiedDate",
	"auto_minor_version_upgrade":             "description.Cluster.AutoMinorVersionUpgrade",
	"cache_cluster_create_time":              "description.Cluster.CacheClusterCreateTime",
	"cache_cluster_id":                       "description.Cluster.CacheClusterId",
	"cache_cluster_status":                   "description.Cluster.CacheClusterStatus",
	"cache_node_type":                        "description.Cluster.CacheNodeType",
	"cache_nodes":                            "description.Cluster.CacheNodes",
	"cache_parameter_group":                  "description.Cluster.CacheParameterGroup",
	"cache_security_groups":                  "description.Cluster.CacheSecurityGroups",
	"cache_subnet_group_name":                "description.Cluster.CacheSubnetGroupName",
	"client_download_landing_page":           "description.Cluster.ClientDownloadLandingPage",
	"configuration_endpoint":                 "description.Cluster.ConfigurationEndpoint",
	"engine":                                 "description.Cluster.Engine",
	"engine_version":                         "description.Cluster.EngineVersion",
	"ip_discovery":                           "description.Cluster.IpDiscovery",
	"og_account_id":                          "metadata.SourceID",
	"log_delivery_configurations":            "description.Cluster.LogDeliveryConfigurations",
	"network_type":                           "description.Cluster.NetworkType",
	"notification_configuration":             "description.Cluster.NotificationConfiguration",
	"num_cache_nodes":                        "description.Cluster.NumCacheNodes",
	"pending_modified_values":                "description.Cluster.PendingModifiedValues",
	"preferred_availability_zone":            "description.Cluster.PreferredAvailabilityZone",
	"preferred_maintenance_window":           "description.Cluster.PreferredMaintenanceWindow",
	"preferred_outpost_arn":                  "description.Cluster.PreferredOutpostArn",
	"replication_group_id":                   "description.Cluster.ReplicationGroupId",
	"replication_group_log_delivery_enabled": "description.Cluster.ReplicationGroupLogDeliveryEnabled",
	"security_groups":                        "description.Cluster.SecurityGroups",
	"snapshot_retention_limit":               "description.Cluster.SnapshotRetentionLimit",
	"snapshot_window":                        "description.Cluster.SnapshotWindow",
	"tags_src":                               "description.TagList",
	"title":                                  "description.Cluster.CacheClusterId",
	"transit_encryption_enabled":             "description.Cluster.TransitEncryptionEnabled",
	"transit_encryption_mode":                "description.Cluster.TransitEncryptionMode",
}

func GetElastiCacheCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElastiCacheClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElastiCacheClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElastiCacheCluster =============================

// ==========================  START: ElastiCacheParameterGroup =============================

type ElastiCacheParameterGroup struct {
	Description   aws.ElastiCacheParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type ElastiCacheParameterGroupHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  ElastiCacheParameterGroup `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type ElastiCacheParameterGroupHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []ElastiCacheParameterGroupHit `json:"hits"`
}

type ElastiCacheParameterGroupSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  ElastiCacheParameterGroupHits `json:"hits"`
}

type ElastiCacheParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_parametergroup", filters, limit)
	if err != nil {
		return ElastiCacheParameterGroupPaginator{}, err
	}

	p := ElastiCacheParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheParameterGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElastiCacheParameterGroupPaginator) NextPage(ctx context.Context) ([]ElastiCacheParameterGroup, error) {
	var response ElastiCacheParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheParameterGroupFilters = map[string]string{
	"cache_parameter_group_family": "description.ParameterGroup.CacheParameterGroupFamily",
	"cache_parameter_group_name":   "description.ParameterGroup.CacheParameterGroupName",
	"description":                  "description.ParameterGroup.Description",
	"is_global":                    "description.ParameterGroup.IsGlobal",
	"og_account_id":                "metadata.SourceID",
	"title":                        "description.ParameterGroup.CacheParameterGroupName",
}

func ListElastiCacheParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheParameterGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheParameterGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElastiCacheParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElastiCacheParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheParameterGroup NewElastiCacheParameterGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElastiCacheParameterGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElastiCacheParameterGroupFilters = map[string]string{
	"cache_parameter_group_family": "description.ParameterGroup.CacheParameterGroupFamily",
	"cache_parameter_group_name":   "description.ParameterGroup.CacheParameterGroupName",
	"description":                  "description.ParameterGroup.Description",
	"is_global":                    "description.ParameterGroup.IsGlobal",
	"og_account_id":                "metadata.SourceID",
	"title":                        "description.ParameterGroup.CacheParameterGroupName",
}

func GetElastiCacheParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElastiCacheParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElastiCacheParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElastiCacheParameterGroup =============================

// ==========================  START: ElastiCacheReservedCacheNode =============================

type ElastiCacheReservedCacheNode struct {
	Description   aws.ElastiCacheReservedCacheNodeDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type ElastiCacheReservedCacheNodeHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  ElastiCacheReservedCacheNode `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type ElastiCacheReservedCacheNodeHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []ElastiCacheReservedCacheNodeHit `json:"hits"`
}

type ElastiCacheReservedCacheNodeSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  ElastiCacheReservedCacheNodeHits `json:"hits"`
}

type ElastiCacheReservedCacheNodePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheReservedCacheNodePaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheReservedCacheNodePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_reservedcachenode", filters, limit)
	if err != nil {
		return ElastiCacheReservedCacheNodePaginator{}, err
	}

	p := ElastiCacheReservedCacheNodePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheReservedCacheNodePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheReservedCacheNodePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElastiCacheReservedCacheNodePaginator) NextPage(ctx context.Context) ([]ElastiCacheReservedCacheNode, error) {
	var response ElastiCacheReservedCacheNodeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheReservedCacheNode
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheReservedCacheNodeFilters = map[string]string{
	"arn":                              "description.ReservedCacheNode.ReservationARN",
	"cache_node_count":                 "description.ReservedCacheNode.CacheNodeCount",
	"cache_node_type":                  "description.ReservedCacheNode.CacheNodeType",
	"duration":                         "description.ReservedCacheNode.Duration",
	"fixed_price":                      "description.ReservedCacheNode.FixedPrice",
	"og_account_id":                    "metadata.SourceID",
	"offering_type":                    "description.ReservedCacheNode.OfferingType",
	"product_description":              "description.ReservedCacheNode.ProductDescription",
	"recurring_charges":                "description.ReservedCacheNode.RecurringCharges",
	"reserved_cache_node_id":           "description.ReservedCacheNode.ReservedCacheNodeId",
	"reserved_cache_nodes_offering_id": "description.ReservedCacheNode.ReservedCacheNodesOfferingId",
	"start_time":                       "description.ReservedCacheNode.StartTime",
	"state":                            "description.ReservedCacheNode.State",
	"title":                            "description.ReservedCacheNode.ReservedCacheNodeId",
	"usage_price":                      "description.ReservedCacheNode.UsagePrice",
}

func ListElastiCacheReservedCacheNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheReservedCacheNode")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReservedCacheNode NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReservedCacheNode NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReservedCacheNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReservedCacheNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReservedCacheNode GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElastiCacheReservedCacheNodePaginator(essdk.BuildFilter(ctx, d.QueryContext, listElastiCacheReservedCacheNodeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheReservedCacheNode NewElastiCacheReservedCacheNodePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElastiCacheReservedCacheNode paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElastiCacheReservedCacheNodeFilters = map[string]string{
	"arn":                              "description.ReservedCacheNode.ReservationARN",
	"cache_node_count":                 "description.ReservedCacheNode.CacheNodeCount",
	"cache_node_type":                  "description.ReservedCacheNode.CacheNodeType",
	"duration":                         "description.ReservedCacheNode.Duration",
	"fixed_price":                      "description.ReservedCacheNode.FixedPrice",
	"og_account_id":                    "metadata.SourceID",
	"offering_type":                    "description.ReservedCacheNode.OfferingType",
	"product_description":              "description.ReservedCacheNode.ProductDescription",
	"recurring_charges":                "description.ReservedCacheNode.RecurringCharges",
	"reserved_cache_node_id":           "description.ReservedCacheNode.ReservedCacheNodeId",
	"reserved_cache_nodes_offering_id": "description.ReservedCacheNode.ReservedCacheNodesOfferingId",
	"start_time":                       "description.ReservedCacheNode.StartTime",
	"state":                            "description.ReservedCacheNode.State",
	"title":                            "description.ReservedCacheNode.ReservedCacheNodeId",
	"usage_price":                      "description.ReservedCacheNode.UsagePrice",
}

func GetElastiCacheReservedCacheNode(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheReservedCacheNode")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElastiCacheReservedCacheNodePaginator(essdk.BuildFilter(ctx, d.QueryContext, getElastiCacheReservedCacheNodeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElastiCacheReservedCacheNode =============================

// ==========================  START: ElastiCacheSubnetGroup =============================

type ElastiCacheSubnetGroup struct {
	Description   aws.ElastiCacheSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ElastiCacheSubnetGroupHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ElastiCacheSubnetGroup `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ElastiCacheSubnetGroupHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ElastiCacheSubnetGroupHit `json:"hits"`
}

type ElastiCacheSubnetGroupSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ElastiCacheSubnetGroupHits `json:"hits"`
}

type ElastiCacheSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElastiCacheSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElastiCacheSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticache_subnetgroup", filters, limit)
	if err != nil {
		return ElastiCacheSubnetGroupPaginator{}, err
	}

	p := ElastiCacheSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElastiCacheSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElastiCacheSubnetGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElastiCacheSubnetGroupPaginator) NextPage(ctx context.Context) ([]ElastiCacheSubnetGroup, error) {
	var response ElastiCacheSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElastiCacheSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElastiCacheSubnetGroupFilters = map[string]string{
	"arn":                            "description.SubnetGroup.ARN",
	"cache_subnet_group_description": "description.SubnetGroup.CacheSubnetGroupDescription",
	"cache_subnet_group_name":        "description.SubnetGroup.CacheSubnetGroupName",
	"og_account_id":                  "metadata.SourceID",
	"subnets":                        "description.SubnetGroup.Subnets",
	"title":                          "description.SubnetGroup.CacheSubnetGroupName",
	"vpc_id":                         "description.SubnetGroup.VpcId",
}

func ListElastiCacheSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElastiCacheSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheSubnetGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheSubnetGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElastiCacheSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElastiCacheSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElastiCacheSubnetGroup NewElastiCacheSubnetGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElastiCacheSubnetGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElastiCacheSubnetGroupFilters = map[string]string{
	"arn":                            "description.SubnetGroup.ARN",
	"cache_subnet_group_description": "description.SubnetGroup.CacheSubnetGroupDescription",
	"cache_subnet_group_name":        "description.SubnetGroup.CacheSubnetGroupName",
	"og_account_id":                  "metadata.SourceID",
	"subnets":                        "description.SubnetGroup.Subnets",
	"title":                          "description.SubnetGroup.CacheSubnetGroupName",
	"vpc_id":                         "description.SubnetGroup.VpcId",
}

func GetElastiCacheSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElastiCacheSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElastiCacheSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElastiCacheSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElastiCacheSubnetGroup =============================

// ==========================  START: ESDomain =============================

type ESDomain struct {
	Description   aws.ESDomainDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type ESDomainHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ESDomain      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ESDomainHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ESDomainHit     `json:"hits"`
}

type ESDomainSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ESDomainHits `json:"hits"`
}

type ESDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewESDomainPaginator(filters []essdk.BoolFilter, limit *int64) (ESDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticsearch_domain", filters, limit)
	if err != nil {
		return ESDomainPaginator{}, err
	}

	p := ESDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ESDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ESDomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ESDomainPaginator) NextPage(ctx context.Context) ([]ESDomain, error) {
	var response ESDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ESDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listESDomainFilters = map[string]string{
	"access_policies":              "description.Domain.AccessPolicies",
	"advanced_options":             "description.Domain.AdvancedOptions",
	"advanced_security_options":    "description.Domain.AdvancedSecurityOptions",
	"arn":                          "description.Domain.ARN",
	"auto_tune_options":            "description.Domain.AutoTuneOptions",
	"cognito_options":              "description.Domain.CognitoOptions",
	"created":                      "description.Domain.Created",
	"deleted":                      "description.Domain.Deleted",
	"domain_endpoint_options":      "description.Domain.DomainEndpointOptions",
	"domain_id":                    "description.Domain.DomainId",
	"domain_name":                  "description.Domain.DomainName",
	"ebs_options":                  "description.Domain.EBSOptions",
	"elasticsearch_cluster_config": "description.Domain.ElasticsearchClusterConfig",
	"elasticsearch_version":        "description.Domain.ElasticsearchVersion",
	"enabled":                      "description.Domain.NodeToNodeEncryptionOptions.Enabled",
	"encryption_at_rest_options":   "description.Domain.EncryptionAtRestOptions",
	"endpoint":                     "description.Domain.Endpoint",
	"endpoints":                    "description.Domain.Endpoints",
	"og_account_id":                "metadata.SourceID",
	"log_publishing_options":       "description.Domain.LogPublishingOptions",
	"processing":                   "description.Domain.Processing",
	"service_software_options":     "description.Domain.ServiceSoftwareOptions",
	"snapshot_options":             "description.Domain.SnapshotOptions",
	"tags_src":                     "description.Tags",
	"title":                        "description.Domain.DomainName",
	"upgrade_processing":           "description.Domain.UpgradeProcessing",
	"vpc_options":                  "description.Domain.VPCOptions",
}

func ListESDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListESDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListESDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListESDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListESDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListESDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListESDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewESDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listESDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListESDomain NewESDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListESDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getESDomainFilters = map[string]string{
	"access_policies":              "description.Domain.AccessPolicies",
	"advanced_options":             "description.Domain.AdvancedOptions",
	"advanced_security_options":    "description.Domain.AdvancedSecurityOptions",
	"arn":                          "description.Domain.ARN",
	"auto_tune_options":            "description.Domain.AutoTuneOptions",
	"cognito_options":              "description.Domain.CognitoOptions",
	"created":                      "description.Domain.Created",
	"deleted":                      "description.Domain.Deleted",
	"domain_endpoint_options":      "description.Domain.DomainEndpointOptions",
	"domain_id":                    "description.Domain.DomainId",
	"domain_name":                  "description.Domain.DomainName",
	"ebs_options":                  "description.Domain.EBSOptions",
	"elasticsearch_cluster_config": "description.Domain.ElasticsearchClusterConfig",
	"elasticsearch_version":        "description.Domain.ElasticsearchVersion",
	"enabled":                      "description.Domain.NodeToNodeEncryptionOptions.Enabled",
	"encryption_at_rest_options":   "description.Domain.EncryptionAtRestOptions",
	"endpoint":                     "description.Domain.Endpoint",
	"endpoints":                    "description.Domain.Endpoints",
	"og_account_id":                "metadata.SourceID",
	"log_publishing_options":       "description.Domain.LogPublishingOptions",
	"processing":                   "description.Domain.Processing",
	"service_software_options":     "description.Domain.ServiceSoftwareOptions",
	"snapshot_options":             "description.Domain.SnapshotOptions",
	"tags_src":                     "description.Tags",
	"title":                        "description.Domain.DomainName",
	"upgrade_processing":           "description.Domain.UpgradeProcessing",
	"vpc_options":                  "description.Domain.VPCOptions",
}

func GetESDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetESDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewESDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getESDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ESDomain =============================

// ==========================  START: EMRCluster =============================

type EMRCluster struct {
	Description   aws.EMRClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EMRClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EMRCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EMRClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EMRClusterHit   `json:"hits"`
}

type EMRClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EMRClusterHits `json:"hits"`
}

type EMRClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRClusterPaginator(filters []essdk.BoolFilter, limit *int64) (EMRClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_cluster", filters, limit)
	if err != nil {
		return EMRClusterPaginator{}, err
	}

	p := EMRClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EMRClusterPaginator) NextPage(ctx context.Context) ([]EMRCluster, error) {
	var response EMRClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRClusterFilters = map[string]string{
	"applications":              "description.Cluster.Applications",
	"auto_scaling_role":         "description.Cluster.AutoScalingRole",
	"auto_terminate":            "description.Cluster.AutoTerminate",
	"cluster_arn":               "description.Cluster.ClusterArn",
	"configurations":            "description.Cluster.Configurations",
	"custom_ami_id":             "description.Cluster.CustomAmiId",
	"ebs_root_volume_size":      "description.Cluster.EbsRootVolumeSize",
	"ec2_instance_attributes":   "description.Cluster.Ec2InstanceAttributes",
	"id":                        "description.Cluster.Id",
	"instance_collection_type":  "description.Cluster.InstanceCollectionType",
	"og_account_id":             "metadata.SourceID",
	"kerberos_attributes":       "description.Cluster.KerberosAttributes",
	"log_encryption_kms_key_id": "description.Cluster.LogEncryptionKmsKeyId",
	"log_uri":                   "description.Cluster.LogUri",
	"master_public_dns_name":    "description.Cluster.MasterPublicDnsName",
	"name":                      "description.Cluster.Name",
	"normalized_instance_hours": "description.Cluster.NormalizedInstanceHours",
	"outpost_arn":               "description.Cluster.OutpostArn",
	"placement_groups":          "description.Cluster.PlacementGroups",
	"release_label":             "description.Cluster.ReleaseLabel",
	"repo_upgrade_on_boot":      "description.Cluster.RepoUpgradeOnBoot",
	"requested_ami_version":     "description.Cluster.RequestedAmiVersion",
	"running_ami_version":       "description.Cluster.RunningAmiVersion",
	"scale_down_behavior":       "description.Cluster.ScaleDownBehavior",
	"security_configuration":    "description.Cluster.SecurityConfiguration",
	"service_role":              "description.Cluster.ServiceRole",
	"state":                     "description.Cluster.Status.State",
	"status":                    "description.Cluster.Status",
	"step_concurrency_level":    "description.Cluster.StepConcurrencyLevel",
	"tags_src":                  "description.Cluster.Tags",
	"termination_protected":     "description.Cluster.TerminationProtected",
	"title":                     "description.Cluster.Name",
	"visible_to_all_users":      "description.Cluster.VisibleToAllUsers",
}

func ListEMRCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEMRClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEMRClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRCluster NewEMRClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEMRCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEMRClusterFilters = map[string]string{
	"applications":              "description.Cluster.Applications",
	"auto_scaling_role":         "description.Cluster.AutoScalingRole",
	"auto_terminate":            "description.Cluster.AutoTerminate",
	"cluster_arn":               "description.Cluster.ClusterArn",
	"configurations":            "description.Cluster.Configurations",
	"custom_ami_id":             "description.Cluster.CustomAmiId",
	"ebs_root_volume_size":      "description.Cluster.EbsRootVolumeSize",
	"ec2_instance_attributes":   "description.Cluster.Ec2InstanceAttributes",
	"id":                        "description.Cluster.Id",
	"instance_collection_type":  "description.Cluster.InstanceCollectionType",
	"og_account_id":             "metadata.SourceID",
	"kerberos_attributes":       "description.Cluster.KerberosAttributes",
	"log_encryption_kms_key_id": "description.Cluster.LogEncryptionKmsKeyId",
	"log_uri":                   "description.Cluster.LogUri",
	"master_public_dns_name":    "description.Cluster.MasterPublicDnsName",
	"name":                      "description.Cluster.Name",
	"normalized_instance_hours": "description.Cluster.NormalizedInstanceHours",
	"outpost_arn":               "description.Cluster.OutpostArn",
	"placement_groups":          "description.Cluster.PlacementGroups",
	"release_label":             "description.Cluster.ReleaseLabel",
	"repo_upgrade_on_boot":      "description.Cluster.RepoUpgradeOnBoot",
	"requested_ami_version":     "description.Cluster.RequestedAmiVersion",
	"running_ami_version":       "description.Cluster.RunningAmiVersion",
	"scale_down_behavior":       "description.Cluster.ScaleDownBehavior",
	"security_configuration":    "description.Cluster.SecurityConfiguration",
	"service_role":              "description.Cluster.ServiceRole",
	"state":                     "description.Cluster.Status.State",
	"status":                    "description.Cluster.Status",
	"step_concurrency_level":    "description.Cluster.StepConcurrencyLevel",
	"tags_src":                  "description.Cluster.Tags",
	"termination_protected":     "description.Cluster.TerminationProtected",
	"title":                     "description.Cluster.Name",
	"visible_to_all_users":      "description.Cluster.VisibleToAllUsers",
}

func GetEMRCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEMRClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEMRClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EMRCluster =============================

// ==========================  START: EMRInstance =============================

type EMRInstance struct {
	Description   aws.EMRInstanceDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type EMRInstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EMRInstance   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EMRInstanceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EMRInstanceHit  `json:"hits"`
}

type EMRInstanceSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  EMRInstanceHits `json:"hits"`
}

type EMRInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRInstancePaginator(filters []essdk.BoolFilter, limit *int64) (EMRInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_instance", filters, limit)
	if err != nil {
		return EMRInstancePaginator{}, err
	}

	p := EMRInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EMRInstancePaginator) NextPage(ctx context.Context) ([]EMRInstance, error) {
	var response EMRInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRInstanceFilters = map[string]string{
	"cluster_id":          "description.ClusterID",
	"ebs_volumes":         "description.Instance.EbsVolumes",
	"ec2_instance_id":     "description.Instance.Ec2InstanceId",
	"id":                  "description.Instance.Id",
	"instance_fleet_id":   "description.Instance.InstanceFleetId",
	"instance_group_id":   "description.Instance.InstanceGroupId",
	"instance_type":       "description.Instance.InstanceType",
	"og_account_id":       "metadata.SourceID",
	"market":              "description.Instance.Market",
	"private_dns_name":    "description.Instance.PrivateDnsName",
	"private_ip_address":  "description.Instance.PrivateIpAddress",
	"public_dns_name":     "description.Instance.PublicDnsName",
	"public_ip_address":   "description.Instance.PublicIpAddress",
	"state":               "description.Instance.Status.State",
	"state_change_reason": "description.Instance.Status.StateChangeReason",
	"status_timeline":     "description.Instance.Status.Timeline",
	"title":               "description.Instance.Id",
}

func ListEMRInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEMRInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEMRInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstance NewEMRInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEMRInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEMRInstanceFilters = map[string]string{
	"cluster_id":          "description.ClusterID",
	"ebs_volumes":         "description.Instance.EbsVolumes",
	"ec2_instance_id":     "description.Instance.Ec2InstanceId",
	"id":                  "description.Instance.Id",
	"instance_fleet_id":   "description.Instance.InstanceFleetId",
	"instance_group_id":   "description.Instance.InstanceGroupId",
	"instance_type":       "description.Instance.InstanceType",
	"og_account_id":       "metadata.SourceID",
	"market":              "description.Instance.Market",
	"private_dns_name":    "description.Instance.PrivateDnsName",
	"private_ip_address":  "description.Instance.PrivateIpAddress",
	"public_dns_name":     "description.Instance.PublicDnsName",
	"public_ip_address":   "description.Instance.PublicIpAddress",
	"state":               "description.Instance.Status.State",
	"state_change_reason": "description.Instance.Status.StateChangeReason",
	"status_timeline":     "description.Instance.Status.Timeline",
	"title":               "description.Instance.Id",
}

func GetEMRInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEMRInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEMRInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EMRInstance =============================

// ==========================  START: EMRInstanceFleet =============================

type EMRInstanceFleet struct {
	Description   aws.EMRInstanceFleetDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EMRInstanceFleetHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EMRInstanceFleet `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EMRInstanceFleetHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EMRInstanceFleetHit `json:"hits"`
}

type EMRInstanceFleetSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EMRInstanceFleetHits `json:"hits"`
}

type EMRInstanceFleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRInstanceFleetPaginator(filters []essdk.BoolFilter, limit *int64) (EMRInstanceFleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_instancefleet", filters, limit)
	if err != nil {
		return EMRInstanceFleetPaginator{}, err
	}

	p := EMRInstanceFleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRInstanceFleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRInstanceFleetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EMRInstanceFleetPaginator) NextPage(ctx context.Context) ([]EMRInstanceFleet, error) {
	var response EMRInstanceFleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRInstanceFleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRInstanceFleetFilters = map[string]string{
	"cluster_id":                     "description.ClusterID",
	"id":                             "description.InstanceFleet.Id",
	"instance_fleet_type":            "description.InstanceFleet.InstanceFleetType",
	"instance_type_specifications":   "description.InstanceFleet.InstanceTypeSpecifications",
	"og_account_id":                  "metadata.SourceID",
	"launch_specifications":          "description.InstanceFleet.LaunchSpecifications",
	"name":                           "description.InstanceFleet.Name",
	"provisioned_on_demand_capacity": "description.InstanceFleet.ProvisionedOnDemandCapacity",
	"provisioned_spot_capacity":      "description.InstanceFleet.ProvisionedSpotCapacity",
	"state":                          "description.InstanceFleet.Status.State",
	"state_change_reason":            "description.InstanceFleet.Status.StateChangeReason",
	"status_timeline":                "description.InstanceFleet.Status.Timeline",
	"target_on_demand_capacity":      "description.InstanceFleet.TargetOnDemandCapacity",
	"target_spot_capacity":           "description.InstanceFleet.TargetSpotCapacity",
}

func ListEMRInstanceFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRInstanceFleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceFleet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceFleet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEMRInstanceFleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEMRInstanceFleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceFleet NewEMRInstanceFleetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEMRInstanceFleet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEMRInstanceFleetFilters = map[string]string{
	"cluster_id":                     "description.ClusterID",
	"id":                             "description.InstanceFleet.Id",
	"instance_fleet_type":            "description.InstanceFleet.InstanceFleetType",
	"instance_type_specifications":   "description.InstanceFleet.InstanceTypeSpecifications",
	"og_account_id":                  "metadata.SourceID",
	"launch_specifications":          "description.InstanceFleet.LaunchSpecifications",
	"name":                           "description.InstanceFleet.Name",
	"provisioned_on_demand_capacity": "description.InstanceFleet.ProvisionedOnDemandCapacity",
	"provisioned_spot_capacity":      "description.InstanceFleet.ProvisionedSpotCapacity",
	"state":                          "description.InstanceFleet.Status.State",
	"state_change_reason":            "description.InstanceFleet.Status.StateChangeReason",
	"status_timeline":                "description.InstanceFleet.Status.Timeline",
	"target_on_demand_capacity":      "description.InstanceFleet.TargetOnDemandCapacity",
	"target_spot_capacity":           "description.InstanceFleet.TargetSpotCapacity",
}

func GetEMRInstanceFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRInstanceFleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEMRInstanceFleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEMRInstanceFleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EMRInstanceFleet =============================

// ==========================  START: EMRInstanceGroup =============================

type EMRInstanceGroup struct {
	Description   aws.EMRInstanceGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EMRInstanceGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EMRInstanceGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EMRInstanceGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EMRInstanceGroupHit `json:"hits"`
}

type EMRInstanceGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EMRInstanceGroupHits `json:"hits"`
}

type EMRInstanceGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRInstanceGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EMRInstanceGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_instancegroup", filters, limit)
	if err != nil {
		return EMRInstanceGroupPaginator{}, err
	}

	p := EMRInstanceGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRInstanceGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRInstanceGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EMRInstanceGroupPaginator) NextPage(ctx context.Context) ([]EMRInstanceGroup, error) {
	var response EMRInstanceGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRInstanceGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRInstanceGroupFilters = map[string]string{
	"arn":                    "arn",
	"autoscaling_policy":     "description.InstanceGroup.AutoScalingPolicy",
	"bid_price":              "description.InstanceGroup.BidPrice",
	"cluster_id":             "description.ClusterID",
	"configurations":         "description.InstanceGroup.Configurations",
	"configurations_version": "description.InstanceGroup.ConfigurationsVersion",
	"ebs_block_devices":      "description.InstanceGroup.EbsBlockDevices",
	"ebs_optimized":          "description.InstanceGroup.EbsOptimized",
	"id":                     "description.InstanceGroup.Id",
	"instance_group_type":    "description.InstanceGroup.InstanceGroupType",
	"instance_type":          "description.InstanceGroup.InstanceType",
	"og_account_id":          "metadata.SourceID",
	"last_successfully_applied_configurations":         "description.InstanceGroup.LastSuccessfullyAppliedConfigurations",
	"last_successfully_applied_configurations_version": "description.InstanceGroup.LastSuccessfullyAppliedConfigurationsVersion",
	"market":                   "description.InstanceGroup.Market",
	"name":                     "description.InstanceGroup.Name",
	"requested_instance_count": "description.InstanceGroup.RequestedInstanceCount",
	"running_instance_count":   "description.InstanceGroup.RunningInstanceCount",
	"shrink_policy":            "description.InstanceGroup.ShrinkPolicy",
	"state":                    "description.InstanceGroup.Status.State",
	"state_change_reason":      "description.InstanceGroup.Status.StateChangeReason",
	"status_timeline":          "description.InstanceGroup.Status.Timeline",
}

func ListEMRInstanceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRInstanceGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEMRInstanceGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEMRInstanceGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRInstanceGroup NewEMRInstanceGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEMRInstanceGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEMRInstanceGroupFilters = map[string]string{
	"arn":                    "arn",
	"autoscaling_policy":     "description.InstanceGroup.AutoScalingPolicy",
	"bid_price":              "description.InstanceGroup.BidPrice",
	"cluster_id":             "description.ClusterID",
	"configurations":         "description.InstanceGroup.Configurations",
	"configurations_version": "description.InstanceGroup.ConfigurationsVersion",
	"ebs_block_devices":      "description.InstanceGroup.EbsBlockDevices",
	"ebs_optimized":          "description.InstanceGroup.EbsOptimized",
	"id":                     "description.InstanceGroup.Id",
	"instance_group_type":    "description.InstanceGroup.InstanceGroupType",
	"instance_type":          "description.InstanceGroup.InstanceType",
	"og_account_id":          "metadata.SourceID",
	"last_successfully_applied_configurations":         "description.InstanceGroup.LastSuccessfullyAppliedConfigurations",
	"last_successfully_applied_configurations_version": "description.InstanceGroup.LastSuccessfullyAppliedConfigurationsVersion",
	"market":                   "description.InstanceGroup.Market",
	"name":                     "description.InstanceGroup.Name",
	"requested_instance_count": "description.InstanceGroup.RequestedInstanceCount",
	"running_instance_count":   "description.InstanceGroup.RunningInstanceCount",
	"shrink_policy":            "description.InstanceGroup.ShrinkPolicy",
	"state":                    "description.InstanceGroup.Status.State",
	"state_change_reason":      "description.InstanceGroup.Status.StateChangeReason",
	"status_timeline":          "description.InstanceGroup.Status.Timeline",
}

func GetEMRInstanceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRInstanceGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEMRInstanceGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEMRInstanceGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EMRInstanceGroup =============================

// ==========================  START: EMRBlockPublicAccessConfiguration =============================

type EMRBlockPublicAccessConfiguration struct {
	Description   aws.EMRBlockPublicAccessConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                     `json:"metadata"`
	ResourceJobID int                                              `json:"resource_job_id"`
	SourceJobID   int                                              `json:"source_job_id"`
	ResourceType  string                                           `json:"resource_type"`
	SourceType    string                                           `json:"source_type"`
	ID            string                                           `json:"id"`
	ARN           string                                           `json:"arn"`
	SourceID      string                                           `json:"source_id"`
}

type EMRBlockPublicAccessConfigurationHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  EMRBlockPublicAccessConfiguration `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type EMRBlockPublicAccessConfigurationHits struct {
	Total essdk.SearchTotal                      `json:"total"`
	Hits  []EMRBlockPublicAccessConfigurationHit `json:"hits"`
}

type EMRBlockPublicAccessConfigurationSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  EMRBlockPublicAccessConfigurationHits `json:"hits"`
}

type EMRBlockPublicAccessConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEMRBlockPublicAccessConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (EMRBlockPublicAccessConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_emr_blockpublicaccessconfiguration", filters, limit)
	if err != nil {
		return EMRBlockPublicAccessConfigurationPaginator{}, err
	}

	p := EMRBlockPublicAccessConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EMRBlockPublicAccessConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EMRBlockPublicAccessConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EMRBlockPublicAccessConfigurationPaginator) NextPage(ctx context.Context) ([]EMRBlockPublicAccessConfiguration, error) {
	var response EMRBlockPublicAccessConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EMRBlockPublicAccessConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEMRBlockPublicAccessConfigurationFilters = map[string]string{
	"block_public_security_group_rules":           "description.Configuration.BlockPublicSecurityGroupRules",
	"classification":                              "description.Configuration.Classification",
	"created_by_arn":                              "description.ConfigurationMetadata.CreatedByArn",
	"creation_date":                               "description.ConfigurationMetadata.CreationDateTime",
	"og_account_id":                               "metadata.SourceID",
	"permitted_public_security_group_rule_ranges": "description.Configuration.PermittedPublicSecurityGroupRuleRanges",
}

func ListEMRBlockPublicAccessConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEMRBlockPublicAccessConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRBlockPublicAccessConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRBlockPublicAccessConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRBlockPublicAccessConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRBlockPublicAccessConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRBlockPublicAccessConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEMRBlockPublicAccessConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEMRBlockPublicAccessConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEMRBlockPublicAccessConfiguration NewEMRBlockPublicAccessConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEMRBlockPublicAccessConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEMRBlockPublicAccessConfigurationFilters = map[string]string{
	"block_public_security_group_rules":           "description.Configuration.BlockPublicSecurityGroupRules",
	"classification":                              "description.Configuration.Classification",
	"created_by_arn":                              "description.ConfigurationMetadata.CreatedByArn",
	"creation_date":                               "description.ConfigurationMetadata.CreationDateTime",
	"og_account_id":                               "metadata.SourceID",
	"permitted_public_security_group_rule_ranges": "description.Configuration.PermittedPublicSecurityGroupRuleRanges",
}

func GetEMRBlockPublicAccessConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEMRBlockPublicAccessConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEMRBlockPublicAccessConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEMRBlockPublicAccessConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EMRBlockPublicAccessConfiguration =============================

// ==========================  START: GuardDutyFinding =============================

type GuardDutyFinding struct {
	Description   aws.GuardDutyFindingDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type GuardDutyFindingHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  GuardDutyFinding `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type GuardDutyFindingHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []GuardDutyFindingHit `json:"hits"`
}

type GuardDutyFindingSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  GuardDutyFindingHits `json:"hits"`
}

type GuardDutyFindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyFindingPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyFindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_finding", filters, limit)
	if err != nil {
		return GuardDutyFindingPaginator{}, err
	}

	p := GuardDutyFindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyFindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyFindingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GuardDutyFindingPaginator) NextPage(ctx context.Context) ([]GuardDutyFinding, error) {
	var response GuardDutyFindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyFinding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyFindingFilters = map[string]string{
	"arn":            "description.Finding.Arn",
	"confidence":     "description.Finding.Confidence",
	"created_at":     "description.Finding.CreatedAt",
	"description":    "description.Finding.Description",
	"detector_id":    "description.Finding.Service.DetectorId",
	"id":             "description.Finding.Id",
	"og_account_id":  "metadata.SourceID",
	"name":           "description.Finding.Title",
	"resource":       "description.Finding.Resource",
	"schema_version": "description.Finding.SchemaVersion",
	"service":        "description.Finding.Service",
	"severity":       "description.Finding.Severity",
	"title":          "description.Finding.Title",
	"type":           "description.Finding.Type",
	"updated_at":     "description.Finding.UpdatedAt",
}

func ListGuardDutyFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFinding NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFinding NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGuardDutyFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGuardDutyFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFinding NewGuardDutyFindingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGuardDutyFinding paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGuardDutyFindingFilters = map[string]string{
	"arn":            "description.Finding.Arn",
	"confidence":     "description.Finding.Confidence",
	"created_at":     "description.Finding.CreatedAt",
	"description":    "description.Finding.Description",
	"detector_id":    "description.Finding.Service.DetectorId",
	"id":             "description.Finding.Id",
	"og_account_id":  "metadata.SourceID",
	"name":           "description.Finding.Title",
	"resource":       "description.Finding.Resource",
	"schema_version": "description.Finding.SchemaVersion",
	"service":        "description.Finding.Service",
	"severity":       "description.Finding.Severity",
	"title":          "description.Finding.Title",
	"type":           "description.Finding.Type",
	"updated_at":     "description.Finding.UpdatedAt",
}

func GetGuardDutyFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGuardDutyFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGuardDutyFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GuardDutyFinding =============================

// ==========================  START: GuardDutyDetector =============================

type GuardDutyDetector struct {
	Description   aws.GuardDutyDetectorDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type GuardDutyDetectorHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  GuardDutyDetector `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type GuardDutyDetectorHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []GuardDutyDetectorHit `json:"hits"`
}

type GuardDutyDetectorSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  GuardDutyDetectorHits `json:"hits"`
}

type GuardDutyDetectorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyDetectorPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyDetectorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_detector", filters, limit)
	if err != nil {
		return GuardDutyDetectorPaginator{}, err
	}

	p := GuardDutyDetectorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyDetectorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyDetectorPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GuardDutyDetectorPaginator) NextPage(ctx context.Context) ([]GuardDutyDetector, error) {
	var response GuardDutyDetectorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyDetector
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyDetectorFilters = map[string]string{
	"arn":                          "arn",
	"created_at":                   "description.Detector.CreatedAt",
	"data_sources":                 "description.Detector.DataSources",
	"detector_id":                  "description.DetectorId",
	"features":                     "description.Detector.Features",
	"finding_publishing_frequency": "description.Detector.FindingPublishingFrequency",
	"og_account_id":                "metadata.SourceID",
	"service_role":                 "description.Detector.ServiceRole",
	"status":                       "description.Detector.Status",
	"tags":                         "description.Detector.Tags",
	"title":                        "description.DetectorId",
	"updated_at":                   "description.Detector.UpdatedAt",
}

func ListGuardDutyDetector(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyDetector")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyDetector NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyDetector NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyDetector GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyDetector GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyDetector GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGuardDutyDetectorPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGuardDutyDetectorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyDetector NewGuardDutyDetectorPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGuardDutyDetector paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGuardDutyDetectorFilters = map[string]string{
	"arn":                          "arn",
	"created_at":                   "description.Detector.CreatedAt",
	"data_sources":                 "description.Detector.DataSources",
	"detector_id":                  "description.DetectorId",
	"features":                     "description.Detector.Features",
	"finding_publishing_frequency": "description.Detector.FindingPublishingFrequency",
	"og_account_id":                "metadata.SourceID",
	"service_role":                 "description.Detector.ServiceRole",
	"status":                       "description.Detector.Status",
	"tags":                         "description.Detector.Tags",
	"title":                        "description.DetectorId",
	"updated_at":                   "description.Detector.UpdatedAt",
}

func GetGuardDutyDetector(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyDetector")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGuardDutyDetectorPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGuardDutyDetectorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GuardDutyDetector =============================

// ==========================  START: GuardDutyFilter =============================

type GuardDutyFilter struct {
	Description   aws.GuardDutyFilterDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type GuardDutyFilterHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  GuardDutyFilter `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type GuardDutyFilterHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []GuardDutyFilterHit `json:"hits"`
}

type GuardDutyFilterSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  GuardDutyFilterHits `json:"hits"`
}

type GuardDutyFilterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyFilterPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyFilterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_filter", filters, limit)
	if err != nil {
		return GuardDutyFilterPaginator{}, err
	}

	p := GuardDutyFilterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyFilterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyFilterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GuardDutyFilterPaginator) NextPage(ctx context.Context) ([]GuardDutyFilter, error) {
	var response GuardDutyFilterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyFilter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyFilterFilters = map[string]string{
	"action":           "description.Filter.Action",
	"description":      "description.Filter.Description",
	"detector_id":      "description.DetectorId",
	"finding_criteria": "description.Filter.FindingCriteria",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Filter.Name",
	"rank":             "description.Filter.Rank",
	"tags":             "description.Filter.Tags",
	"title":            "description.Filter.Name",
}

func ListGuardDutyFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyFilter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFilter NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFilter NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGuardDutyFilterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGuardDutyFilterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyFilter NewGuardDutyFilterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGuardDutyFilter paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGuardDutyFilterFilters = map[string]string{
	"action":           "description.Filter.Action",
	"description":      "description.Filter.Description",
	"detector_id":      "description.DetectorId",
	"finding_criteria": "description.Filter.FindingCriteria",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Filter.Name",
	"rank":             "description.Filter.Rank",
	"tags":             "description.Filter.Tags",
	"title":            "description.Filter.Name",
}

func GetGuardDutyFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyFilter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGuardDutyFilterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGuardDutyFilterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GuardDutyFilter =============================

// ==========================  START: GuardDutyIPSet =============================

type GuardDutyIPSet struct {
	Description   aws.GuardDutyIPSetDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type GuardDutyIPSetHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  GuardDutyIPSet `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type GuardDutyIPSetHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []GuardDutyIPSetHit `json:"hits"`
}

type GuardDutyIPSetSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  GuardDutyIPSetHits `json:"hits"`
}

type GuardDutyIPSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyIPSetPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyIPSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_ipset", filters, limit)
	if err != nil {
		return GuardDutyIPSetPaginator{}, err
	}

	p := GuardDutyIPSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyIPSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyIPSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GuardDutyIPSetPaginator) NextPage(ctx context.Context) ([]GuardDutyIPSet, error) {
	var response GuardDutyIPSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyIPSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyIPSetFilters = map[string]string{
	"detector_id":   "description.DetectorId",
	"format":        "description.IPSet.Format",
	"ipset_id":      "description.IPSetId",
	"og_account_id": "metadata.SourceID",
	"location":      "description.IPSet.Location",
	"name":          "description.IPSet.Name",
	"status":        "description.IPSet.Status",
	"tags":          "description.IPSet.Tags",
	"title":         "description.IPSet.Name",
}

func ListGuardDutyIPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyIPSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyIPSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyIPSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyIPSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyIPSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyIPSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGuardDutyIPSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGuardDutyIPSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyIPSet NewGuardDutyIPSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGuardDutyIPSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGuardDutyIPSetFilters = map[string]string{
	"detector_id":   "description.DetectorId",
	"format":        "description.IPSet.Format",
	"ipset_id":      "description.IPSetId",
	"og_account_id": "metadata.SourceID",
	"location":      "description.IPSet.Location",
	"name":          "description.IPSet.Name",
	"status":        "description.IPSet.Status",
	"tags":          "description.IPSet.Tags",
	"title":         "description.IPSet.Name",
}

func GetGuardDutyIPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyIPSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGuardDutyIPSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGuardDutyIPSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GuardDutyIPSet =============================

// ==========================  START: GuardDutyMember =============================

type GuardDutyMember struct {
	Description   aws.GuardDutyMemberDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type GuardDutyMemberHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  GuardDutyMember `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type GuardDutyMemberHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []GuardDutyMemberHit `json:"hits"`
}

type GuardDutyMemberSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  GuardDutyMemberHits `json:"hits"`
}

type GuardDutyMemberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyMemberPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyMemberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_member", filters, limit)
	if err != nil {
		return GuardDutyMemberPaginator{}, err
	}

	p := GuardDutyMemberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyMemberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyMemberPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GuardDutyMemberPaginator) NextPage(ctx context.Context) ([]GuardDutyMember, error) {
	var response GuardDutyMemberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyMember
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyMemberFilters = map[string]string{
	"detector_id":         "description.Member.DetectorId",
	"email":               "description.Member.Email",
	"invited_at":          "description.Member.InvitedAt",
	"og_account_id":       "metadata.SourceID",
	"master_id":           "description.Member.MasterId",
	"member_account_id":   "description.Member.AccountId",
	"relationship_status": "description.Member.RelationshipStatus",
	"title":               "description.Member.AccountId",
	"updated_at":          "description.Member.UpdatedAt",
}

func ListGuardDutyMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyMember")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyMember NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyMember NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGuardDutyMemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGuardDutyMemberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyMember NewGuardDutyMemberPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGuardDutyMember paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGuardDutyMemberFilters = map[string]string{
	"detector_id":         "description.Member.DetectorId",
	"email":               "description.Member.Email",
	"invited_at":          "description.Member.InvitedAt",
	"og_account_id":       "metadata.SourceID",
	"master_id":           "description.Member.MasterId",
	"member_account_id":   "description.Member.AccountId",
	"relationship_status": "description.Member.RelationshipStatus",
	"title":               "description.Member.AccountId",
	"updated_at":          "description.Member.UpdatedAt",
}

func GetGuardDutyMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyMember")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGuardDutyMemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGuardDutyMemberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GuardDutyMember =============================

// ==========================  START: GuardDutyPublishingDestination =============================

type GuardDutyPublishingDestination struct {
	Description   aws.GuardDutyPublishingDestinationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type GuardDutyPublishingDestinationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  GuardDutyPublishingDestination `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type GuardDutyPublishingDestinationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []GuardDutyPublishingDestinationHit `json:"hits"`
}

type GuardDutyPublishingDestinationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  GuardDutyPublishingDestinationHits `json:"hits"`
}

type GuardDutyPublishingDestinationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyPublishingDestinationPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyPublishingDestinationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_publishingdestination", filters, limit)
	if err != nil {
		return GuardDutyPublishingDestinationPaginator{}, err
	}

	p := GuardDutyPublishingDestinationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyPublishingDestinationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyPublishingDestinationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GuardDutyPublishingDestinationPaginator) NextPage(ctx context.Context) ([]GuardDutyPublishingDestination, error) {
	var response GuardDutyPublishingDestinationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyPublishingDestination
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyPublishingDestinationFilters = map[string]string{
	"destination_arn":  "description.PublishingDestination.DestinationProperties.DestinationArn",
	"destination_id":   "description.PublishingDestination.DestinationId",
	"destination_type": "description.PublishingDestination.DestinationType",
	"detector_id":      "description.DetectorId",
	"og_account_id":    "metadata.SourceID",
	"kms_key_arn":      "description.PublishingDestination.DestinationProperties.KmsKeyArn",
	"status":           "description.PublishingDestination.Status",
	"title":            "description.PublishingDestination.DestinationId",
}

func ListGuardDutyPublishingDestination(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyPublishingDestination")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyPublishingDestination NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyPublishingDestination NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyPublishingDestination GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyPublishingDestination GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyPublishingDestination GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGuardDutyPublishingDestinationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGuardDutyPublishingDestinationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyPublishingDestination NewGuardDutyPublishingDestinationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGuardDutyPublishingDestination paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGuardDutyPublishingDestinationFilters = map[string]string{
	"destination_arn":  "description.PublishingDestination.DestinationProperties.DestinationArn",
	"destination_id":   "description.PublishingDestination.DestinationId",
	"destination_type": "description.PublishingDestination.DestinationType",
	"detector_id":      "description.DetectorId",
	"og_account_id":    "metadata.SourceID",
	"kms_key_arn":      "description.PublishingDestination.DestinationProperties.KmsKeyArn",
	"status":           "description.PublishingDestination.Status",
	"title":            "description.PublishingDestination.DestinationId",
}

func GetGuardDutyPublishingDestination(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyPublishingDestination")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGuardDutyPublishingDestinationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGuardDutyPublishingDestinationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GuardDutyPublishingDestination =============================

// ==========================  START: GuardDutyThreatIntelSet =============================

type GuardDutyThreatIntelSet struct {
	Description   aws.GuardDutyThreatIntelSetDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type GuardDutyThreatIntelSetHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  GuardDutyThreatIntelSet `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type GuardDutyThreatIntelSetHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []GuardDutyThreatIntelSetHit `json:"hits"`
}

type GuardDutyThreatIntelSetSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  GuardDutyThreatIntelSetHits `json:"hits"`
}

type GuardDutyThreatIntelSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGuardDutyThreatIntelSetPaginator(filters []essdk.BoolFilter, limit *int64) (GuardDutyThreatIntelSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_guardduty_threatintelset", filters, limit)
	if err != nil {
		return GuardDutyThreatIntelSetPaginator{}, err
	}

	p := GuardDutyThreatIntelSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GuardDutyThreatIntelSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GuardDutyThreatIntelSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GuardDutyThreatIntelSetPaginator) NextPage(ctx context.Context) ([]GuardDutyThreatIntelSet, error) {
	var response GuardDutyThreatIntelSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GuardDutyThreatIntelSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGuardDutyThreatIntelSetFilters = map[string]string{
	"detector_id":         "description.DetectorId",
	"format":              "description.ThreatIntelSet.Format",
	"og_account_id":       "metadata.SourceID",
	"location":            "description.ThreatIntelSet.Location",
	"name":                "description.ThreatIntelSet.Name",
	"status":              "description.ThreatIntelSet.Status",
	"tags":                "description.ThreatIntelSet.Tags",
	"threat_intel_set_id": "description.ThreatIntelSetID",
	"title":               "description.ThreatIntelSet.Name",
}

func ListGuardDutyThreatIntelSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGuardDutyThreatIntelSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyThreatIntelSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyThreatIntelSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyThreatIntelSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyThreatIntelSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyThreatIntelSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGuardDutyThreatIntelSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGuardDutyThreatIntelSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGuardDutyThreatIntelSet NewGuardDutyThreatIntelSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGuardDutyThreatIntelSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGuardDutyThreatIntelSetFilters = map[string]string{
	"detector_id":         "description.DetectorId",
	"format":              "description.ThreatIntelSet.Format",
	"og_account_id":       "metadata.SourceID",
	"location":            "description.ThreatIntelSet.Location",
	"name":                "description.ThreatIntelSet.Name",
	"status":              "description.ThreatIntelSet.Status",
	"tags":                "description.ThreatIntelSet.Tags",
	"threat_intel_set_id": "description.ThreatIntelSetID",
	"title":               "description.ThreatIntelSet.Name",
}

func GetGuardDutyThreatIntelSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGuardDutyThreatIntelSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGuardDutyThreatIntelSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGuardDutyThreatIntelSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GuardDutyThreatIntelSet =============================

// ==========================  START: BackupPlan =============================

type BackupPlan struct {
	Description   aws.BackupPlanDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type BackupPlanHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BackupPlan    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BackupPlanHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BackupPlanHit   `json:"hits"`
}

type BackupPlanSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  BackupPlanHits `json:"hits"`
}

type BackupPlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupPlanPaginator(filters []essdk.BoolFilter, limit *int64) (BackupPlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_plan", filters, limit)
	if err != nil {
		return BackupPlanPaginator{}, err
	}

	p := BackupPlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupPlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupPlanPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupPlanPaginator) NextPage(ctx context.Context) ([]BackupPlan, error) {
	var response BackupPlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupPlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupPlanFilters = map[string]string{
	"advanced_backup_settings": "description.BackupPlan.AdvancedBackupSettings",
	"arn":                      "description.BackupPlan.BackupPlanArn",
	"backup_plan":              "description.BackupPlan",
	"backup_plan_id":           "description.BackupPlan.BackupPlanId",
	"creation_date":            "description.BackupPlan.CreationDate",
	"creator_request_id":       "description.BackupPlan.CreatorRequestId",
	"deletion_date":            "description.BackupPlan.DeletionDate",
	"og_account_id":            "metadata.SourceID",
	"last_execution_date":      "description.BackupPlan.LastExecutionDate",
	"name":                     "description.BackupPlan.BackupPlanName",
	"rules":                    "description.PlanDetails.Rules",
	"title":                    "description.BackupPlan.BackupPlanName",
	"version_id":               "description.BackupPlan.VersionId",
}

func ListBackupPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupPlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupPlan NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupPlan NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupPlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupPlanFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupPlan NewBackupPlanPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupPlan paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupPlanFilters = map[string]string{
	"advanced_backup_settings": "description.BackupPlan.AdvancedBackupSettings",
	"arn":                      "description.BackupPlan.BackupPlanArn",
	"backup_plan":              "description.BackupPlan",
	"backup_plan_id":           "description.BackupPlan.BackupPlanId",
	"creation_date":            "description.BackupPlan.CreationDate",
	"creator_request_id":       "description.BackupPlan.CreatorRequestId",
	"deletion_date":            "description.BackupPlan.DeletionDate",
	"og_account_id":            "metadata.SourceID",
	"last_execution_date":      "description.BackupPlan.LastExecutionDate",
	"name":                     "description.BackupPlan.BackupPlanName",
	"rules":                    "description.PlanDetails.Rules",
	"title":                    "description.BackupPlan.BackupPlanName",
	"version_id":               "description.BackupPlan.VersionId",
}

func GetBackupPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupPlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupPlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupPlanFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupPlan =============================

// ==========================  START: BackupSelection =============================

type BackupSelection struct {
	Description   aws.BackupSelectionDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type BackupSelectionHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  BackupSelection `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type BackupSelectionHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []BackupSelectionHit `json:"hits"`
}

type BackupSelectionSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  BackupSelectionHits `json:"hits"`
}

type BackupSelectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupSelectionPaginator(filters []essdk.BoolFilter, limit *int64) (BackupSelectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_selection", filters, limit)
	if err != nil {
		return BackupSelectionPaginator{}, err
	}

	p := BackupSelectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupSelectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupSelectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupSelectionPaginator) NextPage(ctx context.Context) ([]BackupSelection, error) {
	var response BackupSelectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupSelection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupSelectionFilters = map[string]string{
	"arn":                "arn",
	"backup_plan_id":     "description.BackupSelection.BackupPlanId",
	"creation_date":      "description.BackupSelection.CreationDate",
	"creator_request_id": "description.BackupSelection.CreatorRequestId",
	"iam_role_arn":       "description.BackupSelection.IamRoleArn",
	"og_account_id":      "metadata.SourceID",
	"list_of_tags":       "description.ListOfTags",
	"resources":          "description.Resources",
	"selection_id":       "description.BackupSelection.SelectionId",
	"selection_name":     "description.BackupSelection.SelectionName",
	"title":              "description.BackupSelection.SelectionName",
}

func ListBackupSelection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupSelection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupSelection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupSelection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupSelection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupSelection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupSelection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupSelectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupSelectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupSelection NewBackupSelectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupSelection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupSelectionFilters = map[string]string{
	"arn":                "arn",
	"backup_plan_id":     "description.BackupSelection.BackupPlanId",
	"creation_date":      "description.BackupSelection.CreationDate",
	"creator_request_id": "description.BackupSelection.CreatorRequestId",
	"iam_role_arn":       "description.BackupSelection.IamRoleArn",
	"og_account_id":      "metadata.SourceID",
	"list_of_tags":       "description.ListOfTags",
	"resources":          "description.Resources",
	"selection_id":       "description.BackupSelection.SelectionId",
	"selection_name":     "description.BackupSelection.SelectionName",
	"title":              "description.BackupSelection.SelectionName",
}

func GetBackupSelection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupSelection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupSelectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupSelectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupSelection =============================

// ==========================  START: BackupVault =============================

type BackupVault struct {
	Description   aws.BackupVaultDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type BackupVaultHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BackupVault   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BackupVaultHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BackupVaultHit  `json:"hits"`
}

type BackupVaultSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  BackupVaultHits `json:"hits"`
}

type BackupVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupVaultPaginator(filters []essdk.BoolFilter, limit *int64) (BackupVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_vault", filters, limit)
	if err != nil {
		return BackupVaultPaginator{}, err
	}

	p := BackupVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupVaultPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupVaultPaginator) NextPage(ctx context.Context) ([]BackupVault, error) {
	var response BackupVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupVaultFilters = map[string]string{
	"arn":                       "description.BackupVault.BackupVaultArn",
	"backup_vault_events":       "description.BackupVaultEvents",
	"creation_date":             "description.BackupVault.CreationDate",
	"creator_request_id":        "description.BackupVault.CreatorRequestId",
	"encryption_key_arn":        "description.BackupVault.EncryptionKeyArn",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.BackupVault.BackupVaultName",
	"number_of_recovery_points": "description.BackupVault.NumberOfRecoveryPoints",
	"policy":                    "description.Policy",
	"sns_topic_arn":             "description.SNSTopicArn",
	"tags":                      "description.Tags",
	"title":                     "description.BackupVault.BackupVaultName",
}

func ListBackupVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupVault")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupVault NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupVault NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupVaultFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupVault NewBackupVaultPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupVault paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupVaultFilters = map[string]string{
	"arn":                       "description.BackupVault.BackupVaultArn",
	"backup_vault_events":       "description.BackupVaultEvents",
	"creation_date":             "description.BackupVault.CreationDate",
	"creator_request_id":        "description.BackupVault.CreatorRequestId",
	"encryption_key_arn":        "description.BackupVault.EncryptionKeyArn",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.BackupVault.BackupVaultName",
	"number_of_recovery_points": "description.BackupVault.NumberOfRecoveryPoints",
	"policy":                    "description.Policy",
	"sns_topic_arn":             "description.SNSTopicArn",
	"tags":                      "description.Tags",
	"title":                     "description.BackupVault.BackupVaultName",
}

func GetBackupVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupVault")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupVaultFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupVault =============================

// ==========================  START: BackupRecoveryPoint =============================

type BackupRecoveryPoint struct {
	Description   aws.BackupRecoveryPointDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type BackupRecoveryPointHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  BackupRecoveryPoint `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type BackupRecoveryPointHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []BackupRecoveryPointHit `json:"hits"`
}

type BackupRecoveryPointSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  BackupRecoveryPointHits `json:"hits"`
}

type BackupRecoveryPointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupRecoveryPointPaginator(filters []essdk.BoolFilter, limit *int64) (BackupRecoveryPointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_recoverypoint", filters, limit)
	if err != nil {
		return BackupRecoveryPointPaginator{}, err
	}

	p := BackupRecoveryPointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupRecoveryPointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupRecoveryPointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupRecoveryPointPaginator) NextPage(ctx context.Context) ([]BackupRecoveryPoint, error) {
	var response BackupRecoveryPointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupRecoveryPoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupRecoveryPointFilters = map[string]string{
	"backup_size_in_bytes":    "description.RecoveryPoint.BackupSizeInBytes",
	"backup_vault_arn":        "description.RecoveryPoint.BackupVaultArn",
	"backup_vault_name":       "description.RecoveryPoint.BackupVaultName",
	"calculated_lifecycle":    "description.RecoveryPoint.CalculatedLifecycle",
	"completion_date":         "description.RecoveryPoint.CompletionDate",
	"created_by":              "description.RecoveryPoint.CreatedBy",
	"creation_date":           "description.RecoveryPoint.CreationDate",
	"encryption_key_arn":      "description.RecoveryPoint.EncryptionKeyArn",
	"iam_role_arn":            "description.RecoveryPoint.IamRoleArn",
	"is_encrypted":            "description.RecoveryPoint.IsEncrypted",
	"og_account_id":           "metadata.SourceID",
	"last_restore_time":       "description.RecoveryPoint.LastRestoreTime",
	"lifecycle":               "description.RecoveryPoint.Lifecycle",
	"recovery_point_arn":      "description.RecoveryPoint.RecoveryPointArn",
	"resource_arn":            "description.RecoveryPoint.ResourceArn",
	"resource_type":           "description.RecoveryPoint.ResourceType",
	"source_backup_vault_arn": "description.RecoveryPoint.SourceBackupVaultArn",
	"status":                  "description.RecoveryPoint.Status",
	"status_message":          "description.RecoveryPoint.StatusMessage",
	"storage_class":           "description.RecoveryPoint.StorageClass",
	"tags":                    "description.Tags",
}

func ListBackupRecoveryPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupRecoveryPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRecoveryPoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRecoveryPoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRecoveryPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRecoveryPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRecoveryPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupRecoveryPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupRecoveryPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRecoveryPoint NewBackupRecoveryPointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupRecoveryPoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupRecoveryPointFilters = map[string]string{
	"backup_size_in_bytes":    "description.RecoveryPoint.BackupSizeInBytes",
	"backup_vault_arn":        "description.RecoveryPoint.BackupVaultArn",
	"backup_vault_name":       "description.RecoveryPoint.BackupVaultName",
	"calculated_lifecycle":    "description.RecoveryPoint.CalculatedLifecycle",
	"completion_date":         "description.RecoveryPoint.CompletionDate",
	"created_by":              "description.RecoveryPoint.CreatedBy",
	"creation_date":           "description.RecoveryPoint.CreationDate",
	"encryption_key_arn":      "description.RecoveryPoint.EncryptionKeyArn",
	"iam_role_arn":            "description.RecoveryPoint.IamRoleArn",
	"is_encrypted":            "description.RecoveryPoint.IsEncrypted",
	"og_account_id":           "metadata.SourceID",
	"last_restore_time":       "description.RecoveryPoint.LastRestoreTime",
	"lifecycle":               "description.RecoveryPoint.Lifecycle",
	"recovery_point_arn":      "description.RecoveryPoint.RecoveryPointArn",
	"resource_arn":            "description.RecoveryPoint.ResourceArn",
	"resource_type":           "description.RecoveryPoint.ResourceType",
	"source_backup_vault_arn": "description.RecoveryPoint.SourceBackupVaultArn",
	"status":                  "description.RecoveryPoint.Status",
	"status_message":          "description.RecoveryPoint.StatusMessage",
	"storage_class":           "description.RecoveryPoint.StorageClass",
	"tags":                    "description.Tags",
}

func GetBackupRecoveryPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupRecoveryPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupRecoveryPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupRecoveryPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupRecoveryPoint =============================

// ==========================  START: BackupProtectedResource =============================

type BackupProtectedResource struct {
	Description   aws.BackupProtectedResourceDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type BackupProtectedResourceHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  BackupProtectedResource `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type BackupProtectedResourceHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []BackupProtectedResourceHit `json:"hits"`
}

type BackupProtectedResourceSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  BackupProtectedResourceHits `json:"hits"`
}

type BackupProtectedResourcePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupProtectedResourcePaginator(filters []essdk.BoolFilter, limit *int64) (BackupProtectedResourcePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_protectedresource", filters, limit)
	if err != nil {
		return BackupProtectedResourcePaginator{}, err
	}

	p := BackupProtectedResourcePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupProtectedResourcePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupProtectedResourcePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupProtectedResourcePaginator) NextPage(ctx context.Context) ([]BackupProtectedResource, error) {
	var response BackupProtectedResourceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupProtectedResource
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupProtectedResourceFilters = map[string]string{
	"og_account_id":    "metadata.SourceID",
	"last_backup_time": "description.ProtectedResource.LastBackupTime",
	"resource_arn":     "description.ProtectedResource.ResourceArn",
	"resource_type":    "description.ProtectedResource.ResourceType",
}

func ListBackupProtectedResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupProtectedResource")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupProtectedResource NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupProtectedResource NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupProtectedResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupProtectedResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupProtectedResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupProtectedResourcePaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupProtectedResourceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupProtectedResource NewBackupProtectedResourcePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupProtectedResource paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupProtectedResourceFilters = map[string]string{
	"og_account_id":    "metadata.SourceID",
	"last_backup_time": "description.ProtectedResource.LastBackupTime",
	"resource_arn":     "description.ProtectedResource.ResourceArn",
	"resource_type":    "description.ProtectedResource.ResourceType",
}

func GetBackupProtectedResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupProtectedResource")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupProtectedResourcePaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupProtectedResourceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupProtectedResource =============================

// ==========================  START: BackupFramework =============================

type BackupFramework struct {
	Description   aws.BackupFrameworkDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type BackupFrameworkHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  BackupFramework `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type BackupFrameworkHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []BackupFrameworkHit `json:"hits"`
}

type BackupFrameworkSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  BackupFrameworkHits `json:"hits"`
}

type BackupFrameworkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupFrameworkPaginator(filters []essdk.BoolFilter, limit *int64) (BackupFrameworkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_framework", filters, limit)
	if err != nil {
		return BackupFrameworkPaginator{}, err
	}

	p := BackupFrameworkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupFrameworkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupFrameworkPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupFrameworkPaginator) NextPage(ctx context.Context) ([]BackupFramework, error) {
	var response BackupFrameworkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupFramework
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupFrameworkFilters = map[string]string{
	"arn":                   "description.Framework.FrameworkArn",
	"creation_time":         "description.Framework.CreationTime",
	"deployment_status":     "description.Framework.DeploymentStatus",
	"framework_controls":    "description.Framework.FrameworkControls",
	"framework_description": "description.Framework.FrameworkDescription",
	"framework_name":        "description.Framework.FrameworkName",
	"framework_status":      "description.Framework.FrameworkStatus",
	"og_account_id":         "metadata.SourceID",
	"tags":                  "description.Tags",
	"title":                 "description.Framework.FrameworkName",
}

func ListBackupFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupFramework")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupFramework NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupFramework NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupFramework GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupFramework GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupFramework GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupFrameworkPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupFrameworkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupFramework NewBackupFrameworkPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupFramework paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupFrameworkFilters = map[string]string{
	"arn":                   "description.Framework.FrameworkArn",
	"creation_time":         "description.Framework.CreationTime",
	"deployment_status":     "description.Framework.DeploymentStatus",
	"framework_controls":    "description.Framework.FrameworkControls",
	"framework_description": "description.Framework.FrameworkDescription",
	"framework_name":        "description.Framework.FrameworkName",
	"framework_status":      "description.Framework.FrameworkStatus",
	"og_account_id":         "metadata.SourceID",
	"tags":                  "description.Tags",
	"title":                 "description.Framework.FrameworkName",
}

func GetBackupFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupFramework")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupFrameworkPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupFrameworkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupFramework =============================

// ==========================  START: BackupLegalHold =============================

type BackupLegalHold struct {
	Description   aws.BackupLegalHoldDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type BackupLegalHoldHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  BackupLegalHold `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type BackupLegalHoldHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []BackupLegalHoldHit `json:"hits"`
}

type BackupLegalHoldSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  BackupLegalHoldHits `json:"hits"`
}

type BackupLegalHoldPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupLegalHoldPaginator(filters []essdk.BoolFilter, limit *int64) (BackupLegalHoldPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_legalhold", filters, limit)
	if err != nil {
		return BackupLegalHoldPaginator{}, err
	}

	p := BackupLegalHoldPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupLegalHoldPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupLegalHoldPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupLegalHoldPaginator) NextPage(ctx context.Context) ([]BackupLegalHold, error) {
	var response BackupLegalHoldSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupLegalHold
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupLegalHoldFilters = map[string]string{
	"arn":                      "description.LegalHold.LegalHoldArn",
	"cancellation_date":        "description.LegalHold.CancellationDate",
	"creation_date":            "description.LegalHold.CreationDate",
	"description":              "description.LegalHold.Description",
	"og_account_id":            "metadata.SourceID",
	"legal_hold_id":            "description.LegalHold.LegalHoldId",
	"recovery_point_selection": "description.LegalHold.RecoveryPointSelection",
	"retain_record_until":      "description.LegalHold.RetainRecordUntil",
	"status":                   "description.LegalHold.Status",
	"title":                    "description.LegalHold.Title",
}

func ListBackupLegalHold(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupLegalHold")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupLegalHold NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupLegalHold NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupLegalHold GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupLegalHold GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupLegalHold GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupLegalHoldPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupLegalHoldFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupLegalHold NewBackupLegalHoldPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupLegalHold paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupLegalHoldFilters = map[string]string{
	"arn":                      "description.LegalHold.LegalHoldArn",
	"cancellation_date":        "description.LegalHold.CancellationDate",
	"creation_date":            "description.LegalHold.CreationDate",
	"description":              "description.LegalHold.Description",
	"og_account_id":            "metadata.SourceID",
	"legal_hold_id":            "description.Framework.LegalHoldId",
	"recovery_point_selection": "description.LegalHold.RecoveryPointSelection",
	"retain_record_until":      "description.LegalHold.RetainRecordUntil",
	"status":                   "description.LegalHold.Status",
	"title":                    "description.LegalHold.Title",
}

func GetBackupLegalHold(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupLegalHold")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupLegalHoldPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupLegalHoldFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupLegalHold =============================

// ==========================  START: BackupReportPlan =============================

type BackupReportPlan struct {
	Description   aws.BackupReportPlanDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type BackupReportPlanHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  BackupReportPlan `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type BackupReportPlanHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []BackupReportPlanHit `json:"hits"`
}

type BackupReportPlanSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  BackupReportPlanHits `json:"hits"`
}

type BackupReportPlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupReportPlanPaginator(filters []essdk.BoolFilter, limit *int64) (BackupReportPlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_reportplan", filters, limit)
	if err != nil {
		return BackupReportPlanPaginator{}, err
	}

	p := BackupReportPlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupReportPlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupReportPlanPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupReportPlanPaginator) NextPage(ctx context.Context) ([]BackupReportPlan, error) {
	var response BackupReportPlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupReportPlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupReportPlanFilters = map[string]string{
	"arn":                            "description.ReportPlan.ReportPlanArn",
	"creation_time":                  "description.ReportPlan.CreationTime",
	"deployment_status":              "description.ReportPlan.DeploymentStatus",
	"description":                    "description.ReportPlan.ReportPlanDescription",
	"og_account_id":                  "metadata.SourceID",
	"last_attempted_execution_time":  "description.ReportPlan.LastAttemptedExecutionTime",
	"last_successful_execution_time": "description.ReportPlan.LastSuccessfulExecutionTime",
	"report_delivery_channel":        "description.ReportPlan.ReportDeliveryChannel",
	"report_plan_name":               "description.ReportPlan.ReportPlanName",
	"report_setting":                 "description.ReportPlan.ReportSetting",
	"title":                          "description.ReportPlan.ReportPlanName",
}

func ListBackupReportPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupReportPlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupReportPlan NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupReportPlan NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupReportPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupReportPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupReportPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupReportPlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupReportPlanFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupReportPlan NewBackupReportPlanPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupReportPlan paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupReportPlanFilters = map[string]string{
	"arn":                            "description.ReportPlan.ReportPlanArn",
	"creation_time":                  "description.ReportPlan.CreationTime",
	"deployment_status":              "description.ReportPlan.DeploymentStatus",
	"description":                    "description.ReportPlan.ReportPlanDescription",
	"framework_name":                 "description.Framework.FrameworkName",
	"og_account_id":                  "metadata.SourceID",
	"last_attempted_execution_time":  "description.ReportPlan.LastAttemptedExecutionTime",
	"last_successful_execution_time": "description.ReportPlan.LastSuccessfulExecutionTime",
	"report_delivery_channel":        "description.ReportPlan.ReportDeliveryChannel",
	"report_plan_name":               "description.ReportPlan.ReportPlanName",
	"report_setting":                 "description.ReportPlan.ReportSetting",
	"title":                          "description.ReportPlan.ReportPlanName",
}

func GetBackupReportPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupReportPlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupReportPlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupReportPlanFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupReportPlan =============================

// ==========================  START: BackupRegionSetting =============================

type BackupRegionSetting struct {
	Description   aws.BackupRegionSettingDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type BackupRegionSettingHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  BackupRegionSetting `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type BackupRegionSettingHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []BackupRegionSettingHit `json:"hits"`
}

type BackupRegionSettingSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  BackupRegionSettingHits `json:"hits"`
}

type BackupRegionSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBackupRegionSettingPaginator(filters []essdk.BoolFilter, limit *int64) (BackupRegionSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_backup_regionsetting", filters, limit)
	if err != nil {
		return BackupRegionSettingPaginator{}, err
	}

	p := BackupRegionSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BackupRegionSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BackupRegionSettingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BackupRegionSettingPaginator) NextPage(ctx context.Context) ([]BackupRegionSetting, error) {
	var response BackupRegionSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BackupRegionSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBackupRegionSettingFilters = map[string]string{
	"og_account_id":                       "metadata.SourceID",
	"region":                              "description.Region",
	"resource_type_management_preference": "description.ResourceTypeManagementPreference",
	"resource_type_opt_in_preference":     "description.ResourceTypeOptInPreference",
}

func ListBackupRegionSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBackupRegionSetting")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRegionSetting NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRegionSetting NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRegionSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRegionSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRegionSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBackupRegionSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBackupRegionSettingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBackupRegionSetting NewBackupRegionSettingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBackupRegionSetting paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBackupRegionSettingFilters = map[string]string{
	"framework_name":                      "description.Framework.FrameworkName",
	"og_account_id":                       "metadata.SourceID",
	"region":                              "description.Region",
	"resource_type_management_preference": "description.ResourceTypeManagementPreference",
	"resource_type_opt_in_preference":     "description.ResourceTypeOptInPreference",
}

func GetBackupRegionSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBackupRegionSetting")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBackupRegionSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBackupRegionSettingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BackupRegionSetting =============================

// ==========================  START: CloudFrontDistribution =============================

type CloudFrontDistribution struct {
	Description   aws.CloudFrontDistributionDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CloudFrontDistributionHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CloudFrontDistribution `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CloudFrontDistributionHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CloudFrontDistributionHit `json:"hits"`
}

type CloudFrontDistributionSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CloudFrontDistributionHits `json:"hits"`
}

type CloudFrontDistributionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontDistributionPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontDistributionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_distribution", filters, limit)
	if err != nil {
		return CloudFrontDistributionPaginator{}, err
	}

	p := CloudFrontDistributionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontDistributionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontDistributionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontDistributionPaginator) NextPage(ctx context.Context) ([]CloudFrontDistribution, error) {
	var response CloudFrontDistributionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontDistribution
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontDistributionFilters = map[string]string{
	"active_trusted_key_groups":        "description.Distribution.ActiveTrustedKeyGroups",
	"active_trusted_signers":           "description.Distribution.ActiveTrustedSigners",
	"alias_icp_recordals":              "description.Distribution.AliasICPRecordals",
	"aliases":                          "description.Distribution.DistributionConfig.Aliases",
	"arn":                              "description.Distribution.ARN",
	"cache_behaviors":                  "description.Distribution.DistributionConfig.CacheBehaviors",
	"caller_reference":                 "description.Distribution.DistributionConfig.CallerReference",
	"comment":                          "description.Distribution.DistributionConfig.Comment",
	"custom_error_responses":           "description.Distribution.DistributionConfig.CustomErrorResponses",
	"default_cache_behavior":           "description.Distribution.DistributionConfig.DefaultCacheBehavior",
	"default_root_object":              "description.Distribution.DistributionConfig.DefaultRootObject",
	"domain_name":                      "description.Distribution.DomainName",
	"e_tag":                            "description.ETag",
	"enabled":                          "description.Distribution.DistributionConfig.Enabled",
	"http_version":                     "description.Distribution.DistributionConfig.HttpVersion",
	"id":                               "description.Distribution.Id",
	"in_progress_invalidation_batches": "description.Distribution.InProgressInvalidationBatches",
	"is_ipv6_enabled":                  "description.Distribution.DistributionConfig.IsIPV6Enabled",
	"og_account_id":                    "metadata.SourceID",
	"last_modified_time":               "description.Distribution.LastModifiedTime",
	"logging":                          "description.Distribution.DistributionConfig.Logging",
	"origin_groups":                    "description.Distribution.DistributionConfig.OriginGroups",
	"origins":                          "description.Distribution.DistributionConfig.Origins.Items",
	"price_class":                      "description.Distribution.DistributionConfig.PriceClass",
	"restrictions":                     "description.Distribution.DistributionConfig.Restrictions",
	"status":                           "description.Distribution.Status",
	"tags_src":                         "description.Tags",
	"title":                            "description.Distribution.Id",
	"viewer_certificate":               "description.Distribution.DistributionConfig.ViewerCertificate",
	"web_acl_id":                       "description.Distribution.DistributionConfig.WebACLId",
}

func ListCloudFrontDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontDistribution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontDistribution NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontDistribution NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontDistribution GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontDistribution GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontDistribution GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontDistributionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontDistributionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontDistribution NewCloudFrontDistributionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontDistribution paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontDistributionFilters = map[string]string{
	"active_trusted_key_groups":        "description.Distribution.ActiveTrustedKeyGroups",
	"active_trusted_signers":           "description.Distribution.ActiveTrustedSigners",
	"alias_icp_recordals":              "description.Distribution.AliasICPRecordals",
	"aliases":                          "description.Distribution.DistributionConfig.Aliases",
	"arn":                              "description.Distribution.ARN",
	"cache_behaviors":                  "description.Distribution.DistributionConfig.CacheBehaviors",
	"caller_reference":                 "description.Distribution.DistributionConfig.CallerReference",
	"comment":                          "description.Distribution.DistributionConfig.Comment",
	"custom_error_responses":           "description.Distribution.DistributionConfig.CustomErrorResponses",
	"default_cache_behavior":           "description.Distribution.DistributionConfig.DefaultCacheBehavior",
	"default_root_object":              "description.Distribution.DistributionConfig.DefaultRootObject",
	"domain_name":                      "description.Distribution.DomainName",
	"e_tag":                            "description.ETag",
	"enabled":                          "description.Distribution.DistributionConfig.Enabled",
	"http_version":                     "description.Distribution.DistributionConfig.HttpVersion",
	"id":                               "description.Distribution.Id",
	"in_progress_invalidation_batches": "description.Distribution.InProgressInvalidationBatches",
	"is_ipv6_enabled":                  "description.Distribution.DistributionConfig.IsIPV6Enabled",
	"og_account_id":                    "metadata.SourceID",
	"last_modified_time":               "description.Distribution.LastModifiedTime",
	"logging":                          "description.Distribution.DistributionConfig.Logging",
	"origin_groups":                    "description.Distribution.DistributionConfig.OriginGroups",
	"origins":                          "description.Distribution.DistributionConfig.Origins.Items",
	"price_class":                      "description.Distribution.DistributionConfig.PriceClass",
	"restrictions":                     "description.Distribution.DistributionConfig.Restrictions",
	"status":                           "description.Distribution.Status",
	"tags_src":                         "description.Tags",
	"title":                            "description.Distribution.Id",
	"viewer_certificate":               "description.Distribution.DistributionConfig.ViewerCertificate",
	"web_acl_id":                       "description.Distribution.DistributionConfig.WebACLId",
}

func GetCloudFrontDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontDistribution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontDistributionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontDistributionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontDistribution =============================

// ==========================  START: CloudFrontStreamingDistribution =============================

type CloudFrontStreamingDistribution struct {
	Description   aws.CloudFrontStreamingDistributionDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CloudFrontStreamingDistributionHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CloudFrontStreamingDistribution `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CloudFrontStreamingDistributionHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CloudFrontStreamingDistributionHit `json:"hits"`
}

type CloudFrontStreamingDistributionSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CloudFrontStreamingDistributionHits `json:"hits"`
}

type CloudFrontStreamingDistributionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontStreamingDistributionPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontStreamingDistributionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_streamingdistribution", filters, limit)
	if err != nil {
		return CloudFrontStreamingDistributionPaginator{}, err
	}

	p := CloudFrontStreamingDistributionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontStreamingDistributionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontStreamingDistributionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontStreamingDistributionPaginator) NextPage(ctx context.Context) ([]CloudFrontStreamingDistribution, error) {
	var response CloudFrontStreamingDistributionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontStreamingDistribution
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontStreamingDistributionFilters = map[string]string{
	"arn":           "description.StreamingDistribution.ARN",
	"id":            "description.StreamingDistribution.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.StreamingDistribution.Name",
	"tags":          "description.StreamingDistribution.Tags",
	"title":         "description.StreamingDistribution.Name",
}

func ListCloudFrontStreamingDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontStreamingDistribution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontStreamingDistribution NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontStreamingDistribution NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontStreamingDistribution GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontStreamingDistribution GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontStreamingDistribution GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontStreamingDistributionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontStreamingDistributionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontStreamingDistribution NewCloudFrontStreamingDistributionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontStreamingDistribution paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontStreamingDistributionFilters = map[string]string{
	"arn":           "description.StreamingDistribution.ARN",
	"id":            "description.StreamingDistribution.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.StreamingDistribution.Name",
	"tags":          "description.StreamingDistribution.Tags",
	"title":         "description.StreamingDistribution.Name",
}

func GetCloudFrontStreamingDistribution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontStreamingDistribution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontStreamingDistributionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontStreamingDistributionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontStreamingDistribution =============================

// ==========================  START: CloudFrontOriginAccessControl =============================

type CloudFrontOriginAccessControl struct {
	Description   aws.CloudFrontOriginAccessControlDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CloudFrontOriginAccessControlHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CloudFrontOriginAccessControl `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CloudFrontOriginAccessControlHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CloudFrontOriginAccessControlHit `json:"hits"`
}

type CloudFrontOriginAccessControlSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CloudFrontOriginAccessControlHits `json:"hits"`
}

type CloudFrontOriginAccessControlPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontOriginAccessControlPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontOriginAccessControlPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_originaccesscontrol", filters, limit)
	if err != nil {
		return CloudFrontOriginAccessControlPaginator{}, err
	}

	p := CloudFrontOriginAccessControlPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontOriginAccessControlPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontOriginAccessControlPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontOriginAccessControlPaginator) NextPage(ctx context.Context) ([]CloudFrontOriginAccessControl, error) {
	var response CloudFrontOriginAccessControlSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontOriginAccessControl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontOriginAccessControlFilters = map[string]string{
	"arn":           "arn",
	"id":            "description.OriginAccessControl.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.OriginAccessControl.Name",
	"title":         "description.OriginAccessControl.Name",
}

func ListCloudFrontOriginAccessControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontOriginAccessControl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessControl NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessControl NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontOriginAccessControlPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontOriginAccessControlFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessControl NewCloudFrontOriginAccessControlPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontOriginAccessControl paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontOriginAccessControlFilters = map[string]string{
	"arn":           "arn",
	"id":            "description.OriginAccessControl.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.OriginAccessControl.Name",
	"title":         "description.OriginAccessControl.Name",
}

func GetCloudFrontOriginAccessControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontOriginAccessControl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontOriginAccessControlPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontOriginAccessControlFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontOriginAccessControl =============================

// ==========================  START: CloudFrontCachePolicy =============================

type CloudFrontCachePolicy struct {
	Description   aws.CloudFrontCachePolicyDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type CloudFrontCachePolicyHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  CloudFrontCachePolicy `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type CloudFrontCachePolicyHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []CloudFrontCachePolicyHit `json:"hits"`
}

type CloudFrontCachePolicySearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  CloudFrontCachePolicyHits `json:"hits"`
}

type CloudFrontCachePolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontCachePolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontCachePolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_cachepolicy", filters, limit)
	if err != nil {
		return CloudFrontCachePolicyPaginator{}, err
	}

	p := CloudFrontCachePolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontCachePolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontCachePolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontCachePolicyPaginator) NextPage(ctx context.Context) ([]CloudFrontCachePolicy, error) {
	var response CloudFrontCachePolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontCachePolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontCachePolicyFilters = map[string]string{
	"comment":            "description.CachePolicy.CachePolicy.CachePolicyConfig.Comment",
	"default_ttl":        "description.CachePolicy.CachePolicy.CachePolicyConfig.DefaultTTL",
	"etag":               "description.CachePolicy.ETag",
	"id":                 "description.CachePolicy.CachePolicy.Id",
	"og_account_id":      "metadata.SourceID",
	"last_modified_time": "description.CachePolicy.CachePolicy.LastModifiedTime",
	"max_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MaxTTL",
	"min_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MinTTL",
	"name":               "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
	"parameters_in_cache_key_and_forwarded_to_origin": "description.CachePolicy.CachePolicy.CachePolicyConfig.ParametersInCacheKeyAndForwardedToOrigin",
	"title": "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
}

func ListCloudFrontCachePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontCachePolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontCachePolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontCachePolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontCachePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontCachePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontCachePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontCachePolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontCachePolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontCachePolicy NewCloudFrontCachePolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontCachePolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontCachePolicyFilters = map[string]string{
	"comment":            "description.CachePolicy.CachePolicy.CachePolicyConfig.Comment",
	"default_ttl":        "description.CachePolicy.CachePolicy.CachePolicyConfig.DefaultTTL",
	"etag":               "description.CachePolicy.ETag",
	"id":                 "description.CachePolicy.Id",
	"og_account_id":      "metadata.SourceID",
	"last_modified_time": "description.CachePolicy.CachePolicy.LastModifiedTime",
	"max_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MaxTTL",
	"min_ttl":            "description.CachePolicy.CachePolicy.CachePolicyConfig.MinTTL",
	"name":               "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
	"parameters_in_cache_key_and_forwarded_to_origin": "description.CachePolicy.CachePolicy.CachePolicyConfig.ParametersInCacheKeyAndForwardedToOrigin",
	"title": "description.CachePolicy.CachePolicy.CachePolicyConfig.Name",
}

func GetCloudFrontCachePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontCachePolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontCachePolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontCachePolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontCachePolicy =============================

// ==========================  START: CloudFrontFunction =============================

type CloudFrontFunction struct {
	Description   aws.CloudFrontFunctionDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type CloudFrontFunctionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  CloudFrontFunction `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type CloudFrontFunctionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []CloudFrontFunctionHit `json:"hits"`
}

type CloudFrontFunctionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  CloudFrontFunctionHits `json:"hits"`
}

type CloudFrontFunctionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontFunctionPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontFunctionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_function", filters, limit)
	if err != nil {
		return CloudFrontFunctionPaginator{}, err
	}

	p := CloudFrontFunctionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontFunctionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontFunctionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontFunctionPaginator) NextPage(ctx context.Context) ([]CloudFrontFunction, error) {
	var response CloudFrontFunctionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontFunction
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontFunctionFilters = map[string]string{
	"arn":               "description.Function.FunctionSummary.FunctionMetadata.FunctionARN",
	"e_tag":             "description.Function.ETag",
	"function_config":   "description.Function.FunctionSummary.FunctionConfig",
	"function_metadata": "description.Function.FunctionSummary.FunctionMetadata",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.Function.FunctionSummary.Name",
	"status":            "description.Function.FunctionSummary.Status",
	"title":             "description.Function.FunctionSummary.Name",
}

func ListCloudFrontFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontFunction")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontFunction NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontFunction NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontFunction GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontFunction GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontFunction GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontFunctionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontFunctionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontFunction NewCloudFrontFunctionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontFunction paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontFunctionFilters = map[string]string{
	"arn":               "description.Function.FunctionSummary.FunctionMetadata.FunctionARN",
	"e_tag":             "description.Function.ETag",
	"function_config":   "description.Function.FunctionSummary.FunctionConfig",
	"function_metadata": "description.Function.FunctionSummary.FunctionMetadata",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.Function.FunctionSummary.Name",
	"status":            "description.Function.FunctionSummary.Status",
	"title":             "description.Function.FunctionSummary.Name",
}

func GetCloudFrontFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontFunction")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontFunctionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontFunctionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontFunction =============================

// ==========================  START: CloudFrontOriginAccessIdentity =============================

type CloudFrontOriginAccessIdentity struct {
	Description   aws.CloudFrontOriginAccessIdentityDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type CloudFrontOriginAccessIdentityHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  CloudFrontOriginAccessIdentity `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type CloudFrontOriginAccessIdentityHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []CloudFrontOriginAccessIdentityHit `json:"hits"`
}

type CloudFrontOriginAccessIdentitySearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  CloudFrontOriginAccessIdentityHits `json:"hits"`
}

type CloudFrontOriginAccessIdentityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontOriginAccessIdentityPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontOriginAccessIdentityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_originaccessidentity", filters, limit)
	if err != nil {
		return CloudFrontOriginAccessIdentityPaginator{}, err
	}

	p := CloudFrontOriginAccessIdentityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontOriginAccessIdentityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontOriginAccessIdentityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontOriginAccessIdentityPaginator) NextPage(ctx context.Context) ([]CloudFrontOriginAccessIdentity, error) {
	var response CloudFrontOriginAccessIdentitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontOriginAccessIdentity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontOriginAccessIdentityFilters = map[string]string{
	"caller_reference":     "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.CallerReference",
	"comment":              "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.Comment",
	"etag":                 "description.OriginAccessIdentity.ETag",
	"id":                   "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.Id",
	"og_account_id":        "metadata.SourceID",
	"s3_canonical_user_id": "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.S3CanonicalUserId",
	"title":                "description.OriginAccessIdentity.ResultMetadata",
}

func ListCloudFrontOriginAccessIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontOriginAccessIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessIdentity NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessIdentity NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontOriginAccessIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontOriginAccessIdentityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginAccessIdentity NewCloudFrontOriginAccessIdentityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontOriginAccessIdentity paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontOriginAccessIdentityFilters = map[string]string{
	"caller_reference":     "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.CallerReference",
	"comment":              "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.CloudFrontOriginAccessIdentityConfig.Comment",
	"etag":                 "description.OriginAccessIdentity.ETag",
	"id":                   "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.Id",
	"og_account_id":        "metadata.SourceID",
	"s3_canonical_user_id": "description.OriginAccessIdentity.CloudFrontOriginAccessIdentity.S3CanonicalUserId",
	"title":                "description.OriginAccessIdentity.ResultMetadata",
}

func GetCloudFrontOriginAccessIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontOriginAccessIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontOriginAccessIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontOriginAccessIdentityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontOriginAccessIdentity =============================

// ==========================  START: CloudFrontOriginRequestPolicy =============================

type CloudFrontOriginRequestPolicy struct {
	Description   aws.CloudFrontOriginRequestPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CloudFrontOriginRequestPolicyHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CloudFrontOriginRequestPolicy `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CloudFrontOriginRequestPolicyHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CloudFrontOriginRequestPolicyHit `json:"hits"`
}

type CloudFrontOriginRequestPolicySearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CloudFrontOriginRequestPolicyHits `json:"hits"`
}

type CloudFrontOriginRequestPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontOriginRequestPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontOriginRequestPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_originrequestpolicy", filters, limit)
	if err != nil {
		return CloudFrontOriginRequestPolicyPaginator{}, err
	}

	p := CloudFrontOriginRequestPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontOriginRequestPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontOriginRequestPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontOriginRequestPolicyPaginator) NextPage(ctx context.Context) ([]CloudFrontOriginRequestPolicy, error) {
	var response CloudFrontOriginRequestPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontOriginRequestPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontOriginRequestPolicyFilters = map[string]string{
	"comment":              "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Comment",
	"cookies_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.CookiesConfig",
	"etag":                 "description.OriginRequestPolicy.ETag",
	"headers_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.HeadersConfig",
	"id":                   "description.OriginRequestPolicy.OriginRequestPolicy.Id",
	"og_account_id":        "metadata.SourceID",
	"last_modified_time":   "description.OriginRequestPolicy.OriginRequestPolicy.LastModifiedTime",
	"name":                 "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
	"query_strings_config": "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.QueryStringsConfig",
	"title":                "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
}

func ListCloudFrontOriginRequestPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontOriginRequestPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginRequestPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginRequestPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginRequestPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginRequestPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginRequestPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontOriginRequestPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontOriginRequestPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontOriginRequestPolicy NewCloudFrontOriginRequestPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontOriginRequestPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontOriginRequestPolicyFilters = map[string]string{
	"comment":              "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Comment",
	"cookies_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.CookiesConfig",
	"etag":                 "description.OriginRequestPolicy.ETag",
	"headers_config":       "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.HeadersConfig",
	"id":                   "description.OriginRequestPolicy.OriginRequestPolicy.Id",
	"og_account_id":        "metadata.SourceID",
	"last_modified_time":   "description.OriginRequestPolicy.OriginRequestPolicy.LastModifiedTime",
	"name":                 "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
	"query_strings_config": "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.QueryStringsConfig",
	"title":                "description.OriginRequestPolicy.OriginRequestPolicy.OriginRequestPolicyConfig.Name",
}

func GetCloudFrontOriginRequestPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontOriginRequestPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontOriginRequestPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontOriginRequestPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontOriginRequestPolicy =============================

// ==========================  START: CloudFrontResponseHeadersPolicy =============================

type CloudFrontResponseHeadersPolicy struct {
	Description   aws.CloudFrontResponseHeadersPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CloudFrontResponseHeadersPolicyHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CloudFrontResponseHeadersPolicy `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CloudFrontResponseHeadersPolicyHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CloudFrontResponseHeadersPolicyHit `json:"hits"`
}

type CloudFrontResponseHeadersPolicySearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CloudFrontResponseHeadersPolicyHits `json:"hits"`
}

type CloudFrontResponseHeadersPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFrontResponseHeadersPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFrontResponseHeadersPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudfront_responseheaderspolicy", filters, limit)
	if err != nil {
		return CloudFrontResponseHeadersPolicyPaginator{}, err
	}

	p := CloudFrontResponseHeadersPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFrontResponseHeadersPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFrontResponseHeadersPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFrontResponseHeadersPolicyPaginator) NextPage(ctx context.Context) ([]CloudFrontResponseHeadersPolicy, error) {
	var response CloudFrontResponseHeadersPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFrontResponseHeadersPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFrontResponseHeadersPolicyFilters = map[string]string{
	"etag":                           "description.ResponseHeadersPolicy.ETag",
	"id":                             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.Id",
	"og_account_id":                  "metadata.SourceID",
	"last_modified_time":             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.LastModifiedTime",
	"name":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"response_headers_policy_config": "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig",
	"title":                          "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"type":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.SecurityHeadersConfig.ContentTypeOptions",
}

func ListCloudFrontResponseHeadersPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFrontResponseHeadersPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontResponseHeadersPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontResponseHeadersPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontResponseHeadersPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontResponseHeadersPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontResponseHeadersPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFrontResponseHeadersPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFrontResponseHeadersPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFrontResponseHeadersPolicy NewCloudFrontResponseHeadersPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFrontResponseHeadersPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFrontResponseHeadersPolicyFilters = map[string]string{
	"etag":                           "description.ResponseHeadersPolicy.ETag",
	"id":                             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.Id",
	"og_account_id":                  "metadata.SourceID",
	"last_modified_time":             "description.ResponseHeadersPolicy.ResponseHeadersPolicy.LastModifiedTime",
	"name":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"response_headers_policy_config": "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig",
	"title":                          "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.Name",
	"type":                           "description.ResponseHeadersPolicy.ResponseHeadersPolicy.ResponseHeadersPolicyConfig.SecurityHeadersConfig.ContentTypeOptions",
}

func GetCloudFrontResponseHeadersPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFrontResponseHeadersPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFrontResponseHeadersPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFrontResponseHeadersPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFrontResponseHeadersPolicy =============================

// ==========================  START: CloudWatchAlarm =============================

type CloudWatchAlarm struct {
	Description   aws.CloudWatchAlarmDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CloudWatchAlarmHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CloudWatchAlarm `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CloudWatchAlarmHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CloudWatchAlarmHit `json:"hits"`
}

type CloudWatchAlarmSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CloudWatchAlarmHits `json:"hits"`
}

type CloudWatchAlarmPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchAlarmPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchAlarmPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_alarm", filters, limit)
	if err != nil {
		return CloudWatchAlarmPaginator{}, err
	}

	p := CloudWatchAlarmPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchAlarmPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchAlarmPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchAlarmPaginator) NextPage(ctx context.Context) ([]CloudWatchAlarm, error) {
	var response CloudWatchAlarmSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchAlarm
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchAlarmFilters = map[string]string{
	"actions_enabled":                       "description.MetricAlarm.ActionsEnabled",
	"alarm_actions":                         "description.MetricAlarm.AlarmActions",
	"alarm_configuration_updated_timestamp": "description.MetricAlarm.AlarmConfigurationUpdatedTimestamp",
	"alarm_description":                     "description.MetricAlarm.AlarmDescription",
	"arn":                                   "description.MetricAlarm.AlarmArn",
	"comparison_operator":                   "description.MetricAlarm.ComparisonOperator",
	"datapoints_to_alarm":                   "description.MetricAlarm.DatapointsToAlarm",
	"dimensions":                            "description.MetricAlarm.Dimensions",
	"evaluate_low_sample_count_percentile":  "description.MetricAlarm.EvaluateLowSampleCountPercentile",
	"evaluation_periods":                    "description.MetricAlarm.EvaluationPeriods",
	"extended_statistic":                    "description.MetricAlarm.ExtendedStatistic",
	"insufficient_data_actions":             "description.MetricAlarm.InsufficientDataActions",
	"og_account_id":                         "metadata.SourceID",
	"metric_name":                           "description.MetricAlarm.MetricName",
	"metrics":                               "description.MetricAlarm.Metrics",
	"name":                                  "description.MetricAlarm.AlarmName",
	"namespace":                             "description.MetricAlarm.Namespace",
	"ok_actions":                            "description.MetricAlarm.OKActions",
	"period":                                "description.MetricAlarm.EvaluationPeriods",
	"state_reason":                          "description.MetricAlarm.StateReason",
	"state_reason_data":                     "description.MetricAlarm.StateReasonData",
	"state_updated_timestamp":               "description.MetricAlarm.StateUpdatedTimestamp",
	"state_value":                           "description.MetricAlarm.StateValue",
	"statistic":                             "description.MetricAlarm.Statistic",
	"tags_src":                              "description.Tags",
	"threshold":                             "description.MetricAlarm.Threshold",
	"threshold_metric_id":                   "description.MetricAlarm.ThresholdMetricId",
	"title":                                 "description.MetricAlarm.AlarmName",
	"treat_missing_data":                    "description.MetricAlarm.TreatMissingData",
	"unit":                                  "description.MetricAlarm.Unit",
}

func ListCloudWatchAlarm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchAlarm")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchAlarm NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchAlarm NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchAlarm GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchAlarm GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchAlarm GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchAlarmPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchAlarmFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchAlarm NewCloudWatchAlarmPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchAlarm paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchAlarmFilters = map[string]string{
	"actions_enabled":                       "description.MetricAlarm.ActionsEnabled",
	"alarm_actions":                         "description.MetricAlarm.AlarmActions",
	"alarm_configuration_updated_timestamp": "description.MetricAlarm.AlarmConfigurationUpdatedTimestamp",
	"alarm_description":                     "description.MetricAlarm.AlarmDescription",
	"arn":                                   "description.MetricAlarm.AlarmArn",
	"comparison_operator":                   "description.MetricAlarm.ComparisonOperator",
	"datapoints_to_alarm":                   "description.MetricAlarm.DatapointsToAlarm",
	"dimensions":                            "description.MetricAlarm.Dimensions",
	"evaluate_low_sample_count_percentile":  "description.MetricAlarm.EvaluateLowSampleCountPercentile",
	"evaluation_periods":                    "description.MetricAlarm.EvaluationPeriods",
	"extended_statistic":                    "description.MetricAlarm.ExtendedStatistic",
	"insufficient_data_actions":             "description.MetricAlarm.InsufficientDataActions",
	"og_account_id":                         "metadata.SourceID",
	"metric_name":                           "description.MetricAlarm.MetricName",
	"metrics":                               "description.MetricAlarm.Metrics",
	"name":                                  "description.MetricAlarm.AlarmName",
	"namespace":                             "description.MetricAlarm.Namespace",
	"ok_actions":                            "description.MetricAlarm.OKActions",
	"period":                                "description.MetricAlarm.EvaluationPeriods",
	"state_reason":                          "description.MetricAlarm.StateReason",
	"state_reason_data":                     "description.MetricAlarm.StateReasonData",
	"state_updated_timestamp":               "description.MetricAlarm.StateUpdatedTimestamp",
	"state_value":                           "description.MetricAlarm.StateValue",
	"statistic":                             "description.MetricAlarm.Statistic",
	"tags_src":                              "description.Tags",
	"threshold":                             "description.MetricAlarm.Threshold",
	"threshold_metric_id":                   "description.MetricAlarm.ThresholdMetricId",
	"title":                                 "description.MetricAlarm.AlarmName",
	"treat_missing_data":                    "description.MetricAlarm.TreatMissingData",
	"unit":                                  "description.MetricAlarm.Unit",
}

func GetCloudWatchAlarm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchAlarm")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchAlarmPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchAlarmFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchAlarm =============================

// ==========================  START: CloudWatchLogEvent =============================

type CloudWatchLogEvent struct {
	Description   aws.CloudWatchLogEventDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type CloudWatchLogEventHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  CloudWatchLogEvent `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type CloudWatchLogEventHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []CloudWatchLogEventHit `json:"hits"`
}

type CloudWatchLogEventSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  CloudWatchLogEventHits `json:"hits"`
}

type CloudWatchLogEventPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogEventPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogEventPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logevent", filters, limit)
	if err != nil {
		return CloudWatchLogEventPaginator{}, err
	}

	p := CloudWatchLogEventPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogEventPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogEventPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchLogEventPaginator) NextPage(ctx context.Context) ([]CloudWatchLogEvent, error) {
	var response CloudWatchLogEventSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogEvent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogEventFilters = map[string]string{
	"event_id":        "description.LogEvent.EventId",
	"og_account_id":   "metadata.SourceID",
	"log_group_name":  "description.LogGroupName",
	"log_stream_name": "description.LogEvent.LogStreamName",
	"timestamp":       "description.LogEvent.Timestamp",
}

func ListCloudWatchLogEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogEvent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogEvent NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogEvent NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchLogEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchLogEventFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogEvent NewCloudWatchLogEventPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchLogEvent paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchLogEventFilters = map[string]string{
	"event_id":        "description.LogEvent.EventId",
	"og_account_id":   "metadata.SourceID",
	"log_group_name":  "description.LogGroupName",
	"log_stream_name": "description.LogEvent.LogStreamName",
}

func GetCloudWatchLogEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogEvent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchLogEventFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogEvent =============================

// ==========================  START: CloudWatchLogResourcePolicy =============================

type CloudWatchLogResourcePolicy struct {
	Description   aws.CloudWatchLogResourcePolicyDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type CloudWatchLogResourcePolicyHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  CloudWatchLogResourcePolicy `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type CloudWatchLogResourcePolicyHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []CloudWatchLogResourcePolicyHit `json:"hits"`
}

type CloudWatchLogResourcePolicySearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  CloudWatchLogResourcePolicyHits `json:"hits"`
}

type CloudWatchLogResourcePolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogResourcePolicyPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogResourcePolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logresourcepolicy", filters, limit)
	if err != nil {
		return CloudWatchLogResourcePolicyPaginator{}, err
	}

	p := CloudWatchLogResourcePolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogResourcePolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogResourcePolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchLogResourcePolicyPaginator) NextPage(ctx context.Context) ([]CloudWatchLogResourcePolicy, error) {
	var response CloudWatchLogResourcePolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogResourcePolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogResourcePolicyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"policy":        "description.ResourcePolicy.PolicyDocument",
	"policy_name":   "description.ResourcePolicy.PolicyName",
	"title":         "description.ResourcePolicy.PolicyName",
}

func ListCloudWatchLogResourcePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogResourcePolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogResourcePolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogResourcePolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogResourcePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogResourcePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogResourcePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchLogResourcePolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchLogResourcePolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogResourcePolicy NewCloudWatchLogResourcePolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchLogResourcePolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchLogResourcePolicyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"policy":        "description.ResourcePolicy.PolicyDocument",
	"policy_name":   "description.ResourcePolicy.PolicyName",
	"title":         "description.ResourcePolicy.PolicyName",
}

func GetCloudWatchLogResourcePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogResourcePolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogResourcePolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchLogResourcePolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogResourcePolicy =============================

// ==========================  START: CloudWatchLogStream =============================

type CloudWatchLogStream struct {
	Description   aws.CloudWatchLogStreamDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type CloudWatchLogStreamHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  CloudWatchLogStream `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type CloudWatchLogStreamHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []CloudWatchLogStreamHit `json:"hits"`
}

type CloudWatchLogStreamSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  CloudWatchLogStreamHits `json:"hits"`
}

type CloudWatchLogStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogStreamPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logstream", filters, limit)
	if err != nil {
		return CloudWatchLogStreamPaginator{}, err
	}

	p := CloudWatchLogStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogStreamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchLogStreamPaginator) NextPage(ctx context.Context) ([]CloudWatchLogStream, error) {
	var response CloudWatchLogStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogStreamFilters = map[string]string{
	"arn":                   "description.LogStream.Arn",
	"og_account_id":         "metadata.SourceID",
	"log_group_name":        "description.LogGroupName",
	"name":                  "description.LogStream.LogStreamName",
	"title":                 "description.LogStream.LogStreamName",
	"upload_sequence_token": "description.LogStream.UploadSequenceToken",
}

func ListCloudWatchLogStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogStream NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogStream NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchLogStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchLogStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogStream NewCloudWatchLogStreamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchLogStream paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchLogStreamFilters = map[string]string{
	"arn":                   "description.LogStream.Arn",
	"og_account_id":         "metadata.SourceID",
	"log_group_name":        "description.LogGroupName",
	"name":                  "description.LogStream.LogStreamName",
	"title":                 "description.LogStream.LogStreamName",
	"upload_sequence_token": "description.LogStream.UploadSequenceToken",
}

func GetCloudWatchLogStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchLogStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogStream =============================

// ==========================  START: CloudWatchLogSubscriptionFilter =============================

type CloudWatchLogSubscriptionFilter struct {
	Description   aws.CloudWatchLogSubscriptionFilterDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CloudWatchLogSubscriptionFilterHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CloudWatchLogSubscriptionFilter `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CloudWatchLogSubscriptionFilterHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CloudWatchLogSubscriptionFilterHit `json:"hits"`
}

type CloudWatchLogSubscriptionFilterSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CloudWatchLogSubscriptionFilterHits `json:"hits"`
}

type CloudWatchLogSubscriptionFilterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogSubscriptionFilterPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogSubscriptionFilterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_logsubscriptionfilter", filters, limit)
	if err != nil {
		return CloudWatchLogSubscriptionFilterPaginator{}, err
	}

	p := CloudWatchLogSubscriptionFilterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogSubscriptionFilterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogSubscriptionFilterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchLogSubscriptionFilterPaginator) NextPage(ctx context.Context) ([]CloudWatchLogSubscriptionFilter, error) {
	var response CloudWatchLogSubscriptionFilterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogSubscriptionFilter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogSubscriptionFilterFilters = map[string]string{
	"destination_arn": "description.SubscriptionFilter.DestinationArn",
	"distribution":    "description.SubscriptionFilter.Distribution",
	"filter_pattern":  "description.SubscriptionFilter.FilterPattern",
	"og_account_id":   "metadata.SourceID",
	"log_group_name":  "description.SubscriptionFilter.LogGroupName",
	"name":            "description.SubscriptionFilter.FilterName",
	"role_arn":        "description.SubscriptionFilter.RoleArn",
	"title":           "description.SubscriptionFilter.FilterName",
}

func ListCloudWatchLogSubscriptionFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogSubscriptionFilter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogSubscriptionFilter NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogSubscriptionFilter NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogSubscriptionFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogSubscriptionFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogSubscriptionFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchLogSubscriptionFilterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchLogSubscriptionFilterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogSubscriptionFilter NewCloudWatchLogSubscriptionFilterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchLogSubscriptionFilter paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchLogSubscriptionFilterFilters = map[string]string{
	"destination_arn": "description.SubscriptionFilter.DestinationArn",
	"distribution":    "description.SubscriptionFilter.Distribution",
	"filter_pattern":  "description.SubscriptionFilter.FilterPattern",
	"og_account_id":   "metadata.SourceID",
	"log_group_name":  "description.SubscriptionFilter.LogGroupName",
	"name":            "description.SubscriptionFilter.FilterName",
	"role_arn":        "description.SubscriptionFilter.RoleArn",
	"title":           "description.SubscriptionFilter.FilterName",
}

func GetCloudWatchLogSubscriptionFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogSubscriptionFilter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogSubscriptionFilterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchLogSubscriptionFilterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogSubscriptionFilter =============================

// ==========================  START: CloudWatchMetric =============================

type CloudWatchMetric struct {
	Description   aws.CloudWatchMetricDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type CloudWatchMetricHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CloudWatchMetric `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CloudWatchMetricHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CloudWatchMetricHit `json:"hits"`
}

type CloudWatchMetricSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CloudWatchMetricHits `json:"hits"`
}

type CloudWatchMetricPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchMetricPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchMetricPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudwatch_metric", filters, limit)
	if err != nil {
		return CloudWatchMetricPaginator{}, err
	}

	p := CloudWatchMetricPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchMetricPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchMetricPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchMetricPaginator) NextPage(ctx context.Context) ([]CloudWatchMetric, error) {
	var response CloudWatchMetricSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchMetric
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchMetricFilters = map[string]string{
	"dimensions":    "description.Metric.Dimensions",
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Metric.MetricName",
	"namespace":     "description.Metric.Namespace",
	"title":         "description.Metric.MetricName",
}

func ListCloudWatchMetric(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchMetric")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchMetric NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchMetric NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchMetric GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchMetric GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchMetric GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchMetricPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchMetricFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchMetric NewCloudWatchMetricPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchMetric paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchMetricFilters = map[string]string{
	"dimensions":    "description.Metric.Dimensions",
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Metric.MetricName",
	"namespace":     "description.Metric.Namespace",
	"title":         "description.Metric.MetricName",
}

func GetCloudWatchMetric(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchMetric")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchMetricPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchMetricFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchMetric =============================

// ==========================  START: CloudWatchLogsLogGroup =============================

type CloudWatchLogsLogGroup struct {
	Description   aws.CloudWatchLogsLogGroupDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CloudWatchLogsLogGroupHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CloudWatchLogsLogGroup `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CloudWatchLogsLogGroupHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CloudWatchLogsLogGroupHit `json:"hits"`
}

type CloudWatchLogsLogGroupSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CloudWatchLogsLogGroupHits `json:"hits"`
}

type CloudWatchLogsLogGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogsLogGroupPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogsLogGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_logs_loggroup", filters, limit)
	if err != nil {
		return CloudWatchLogsLogGroupPaginator{}, err
	}

	p := CloudWatchLogsLogGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogsLogGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogsLogGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchLogsLogGroupPaginator) NextPage(ctx context.Context) ([]CloudWatchLogsLogGroup, error) {
	var response CloudWatchLogsLogGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogsLogGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogsLogGroupFilters = map[string]string{
	"arn":                    "description.LogGroup.Arn",
	"data_protection":        "description.DataProtection",
	"data_protection_policy": "description.DataProtection.PolicyDocument",
	"og_account_id":          "metadata.SourceID",
	"kms_key_id":             "description.LogGroup.KmsKeyId",
	"metric_filter_count":    "description.LogGroup.MetricFilterCount",
	"name":                   "description.LogGroup.LogGroupName",
	"retention_in_days":      "description.LogGroup.RetentionInDays",
	"stored_bytes":           "description.LogGroup.StoredBytes",
	"tags":                   "description.Tags",
	"title":                  "description.LogGroup.LogGroupName",
}

func ListCloudWatchLogsLogGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogsLogGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsLogGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsLogGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsLogGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsLogGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsLogGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchLogsLogGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchLogsLogGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsLogGroup NewCloudWatchLogsLogGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchLogsLogGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchLogsLogGroupFilters = map[string]string{
	"arn":                    "description.LogGroup.Arn",
	"data_protection":        "description.DataProtection",
	"data_protection_policy": "description.DataProtection.PolicyDocument",
	"og_account_id":          "metadata.SourceID",
	"kms_key_id":             "description.LogGroup.KmsKeyId",
	"metric_filter_count":    "description.LogGroup.MetricFilterCount",
	"name":                   "description.LogGroup.LogGroupName",
	"retention_in_days":      "description.LogGroup.RetentionInDays",
	"stored_bytes":           "description.LogGroup.StoredBytes",
	"tags":                   "description.Tags",
	"title":                  "description.LogGroup.LogGroupName",
}

func GetCloudWatchLogsLogGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogsLogGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogsLogGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchLogsLogGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogsLogGroup =============================

// ==========================  START: CloudWatchLogsMetricFilter =============================

type CloudWatchLogsMetricFilter struct {
	Description   aws.CloudWatchLogsMetricFilterDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CloudWatchLogsMetricFilterHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CloudWatchLogsMetricFilter `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CloudWatchLogsMetricFilterHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CloudWatchLogsMetricFilterHit `json:"hits"`
}

type CloudWatchLogsMetricFilterSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CloudWatchLogsMetricFilterHits `json:"hits"`
}

type CloudWatchLogsMetricFilterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudWatchLogsMetricFilterPaginator(filters []essdk.BoolFilter, limit *int64) (CloudWatchLogsMetricFilterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_logs_metricfilter", filters, limit)
	if err != nil {
		return CloudWatchLogsMetricFilterPaginator{}, err
	}

	p := CloudWatchLogsMetricFilterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudWatchLogsMetricFilterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudWatchLogsMetricFilterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudWatchLogsMetricFilterPaginator) NextPage(ctx context.Context) ([]CloudWatchLogsMetricFilter, error) {
	var response CloudWatchLogsMetricFilterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudWatchLogsMetricFilter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudWatchLogsMetricFilterFilters = map[string]string{
	"filter_pattern":                  "description.MetricFilter.FilterPattern",
	"og_account_id":                   "metadata.SourceID",
	"log_group_name":                  "decsription.MetricFilter.LogGroupName",
	"metric_transformation_name":      "decsription.MetricFilter.MetricTransformations.MetricName",
	"metric_transformation_namespace": "decsription.MetricFilter.MetricTransformations.MetricNamespace",
	"name":                            "decsription.MetricFilter.FilterName",
	"title":                           "description.MetricFilter.FilterName",
}

func ListCloudWatchLogsMetricFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudWatchLogsMetricFilter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsMetricFilter NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsMetricFilter NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsMetricFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsMetricFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsMetricFilter GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudWatchLogsMetricFilterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudWatchLogsMetricFilterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudWatchLogsMetricFilter NewCloudWatchLogsMetricFilterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudWatchLogsMetricFilter paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudWatchLogsMetricFilterFilters = map[string]string{
	"filter_pattern": "description.MetricFilter.FilterPattern",
	"og_account_id":  "metadata.SourceID",
	"log_group_name": "description.MetricFilter.LogGroupName",
	"name":           "decsription.MetricFilter.FilterName",
	"title":          "description.MetricFilter.FilterName",
}

func GetCloudWatchLogsMetricFilter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudWatchLogsMetricFilter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudWatchLogsMetricFilterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudWatchLogsMetricFilterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudWatchLogsMetricFilter =============================

// ==========================  START: CodeBuildProject =============================

type CodeBuildProject struct {
	Description   aws.CodeBuildProjectDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type CodeBuildProjectHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CodeBuildProject `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CodeBuildProjectHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CodeBuildProjectHit `json:"hits"`
}

type CodeBuildProjectSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CodeBuildProjectHits `json:"hits"`
}

type CodeBuildProjectPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeBuildProjectPaginator(filters []essdk.BoolFilter, limit *int64) (CodeBuildProjectPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codebuild_project", filters, limit)
	if err != nil {
		return CodeBuildProjectPaginator{}, err
	}

	p := CodeBuildProjectPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeBuildProjectPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeBuildProjectPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeBuildProjectPaginator) NextPage(ctx context.Context) ([]CodeBuildProject, error) {
	var response CodeBuildProjectSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeBuildProject
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeBuildProjectFilters = map[string]string{
	"arn":                       "description.Project.Arn",
	"artifacts":                 "description.Project.Artifacts",
	"badge":                     "description.Project.Badge",
	"build_batch_config":        "description.Project.BuildBatchConfig",
	"cache":                     "description.Project.Cache",
	"concurrent_build_limit":    "description.Project.ConcurrentBuildLimit",
	"created":                   "description.Project.Created",
	"description":               "description.Project.Description",
	"encryption_key":            "description.Project.EncryptionKey",
	"environment":               "description.Project.Environment",
	"file_system_locations":     "description.Project.FileSystemLocations",
	"og_account_id":             "metadata.SourceID",
	"last_modified":             "description.Project.LastModified",
	"logs_config":               "description.Project.LogsConfig",
	"name":                      "description.Project.Name",
	"project_visibility":        "description.Project.ProjectVisibility",
	"queued_timeout_in_minutes": "description.Project.QueuedTimeoutInMinutes",
	"secondary_artifacts":       "description.Project.SecondaryArtifacts",
	"secondary_source_versions": "description.Project.SecondarySourceVersions",
	"secondary_sources":         "description.Project.SecondarySources",
	"service_role":              "description.Project.ServiceRole",
	"source":                    "description.Project.Source",
	"source_version":            "description.Project.SourceVersion",
	"tags_src":                  "description.Project.Tags",
	"timeout_in_minutes":        "description.Project.TimeoutInMinutes",
	"title":                     "description.Project.Name",
	"vpc_config":                "description.Project.VpcConfig",
	"webhook":                   "description.Project.Webhook",
}

func ListCodeBuildProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeBuildProject")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildProject NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildProject NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeBuildProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeBuildProjectFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildProject NewCodeBuildProjectPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeBuildProject paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeBuildProjectFilters = map[string]string{
	"arn":                       "description.Project.Arn",
	"artifacts":                 "description.Project.Artifacts",
	"badge":                     "description.Project.Badge",
	"build_batch_config":        "description.Project.BuildBatchConfig",
	"cache":                     "description.Project.Cache",
	"concurrent_build_limit":    "description.Project.ConcurrentBuildLimit",
	"created":                   "description.Project.Created",
	"description":               "description.Project.Description",
	"encryption_key":            "description.Project.EncryptionKey",
	"environment":               "description.Project.Environment",
	"file_system_locations":     "description.Project.FileSystemLocations",
	"og_account_id":             "metadata.SourceID",
	"last_modified":             "description.Project.LastModified",
	"logs_config":               "description.Project.LogsConfig",
	"name":                      "description.Project.Name",
	"project_visibility":        "description.Project.ProjectVisibility",
	"queued_timeout_in_minutes": "description.Project.QueuedTimeoutInMinutes",
	"secondary_artifacts":       "description.Project.SecondaryArtifacts",
	"secondary_source_versions": "description.Project.SecondarySourceVersions",
	"secondary_sources":         "description.Project.SecondarySources",
	"service_role":              "description.Project.ServiceRole",
	"source":                    "description.Project.Source",
	"source_version":            "description.Project.SourceVersion",
	"tags_src":                  "description.Project.Tags",
	"timeout_in_minutes":        "description.Project.TimeoutInMinutes",
	"title":                     "description.Project.Name",
	"vpc_config":                "description.Project.VpcConfig",
	"webhook":                   "description.Project.Webhook",
}

func GetCodeBuildProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeBuildProject")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeBuildProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeBuildProjectFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeBuildProject =============================

// ==========================  START: CodeBuildSourceCredential =============================

type CodeBuildSourceCredential struct {
	Description   aws.CodeBuildSourceCredentialDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type CodeBuildSourceCredentialHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  CodeBuildSourceCredential `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type CodeBuildSourceCredentialHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []CodeBuildSourceCredentialHit `json:"hits"`
}

type CodeBuildSourceCredentialSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  CodeBuildSourceCredentialHits `json:"hits"`
}

type CodeBuildSourceCredentialPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeBuildSourceCredentialPaginator(filters []essdk.BoolFilter, limit *int64) (CodeBuildSourceCredentialPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codebuild_sourcecredential", filters, limit)
	if err != nil {
		return CodeBuildSourceCredentialPaginator{}, err
	}

	p := CodeBuildSourceCredentialPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeBuildSourceCredentialPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeBuildSourceCredentialPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeBuildSourceCredentialPaginator) NextPage(ctx context.Context) ([]CodeBuildSourceCredential, error) {
	var response CodeBuildSourceCredentialSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeBuildSourceCredential
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeBuildSourceCredentialFilters = map[string]string{
	"arn":           "description.SourceCredentialsInfo.Arn",
	"auth_type":     "description.SourceCredentialsInfo.AuthType",
	"og_account_id": "metadata.SourceID",
	"server_type":   "description.SourceCredentialsInfo.ServerType",
}

func ListCodeBuildSourceCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeBuildSourceCredential")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildSourceCredential NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildSourceCredential NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildSourceCredential GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildSourceCredential GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildSourceCredential GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeBuildSourceCredentialPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeBuildSourceCredentialFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildSourceCredential NewCodeBuildSourceCredentialPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeBuildSourceCredential paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeBuildSourceCredentialFilters = map[string]string{
	"arn":           "description.SourceCredentialsInfo.Arn",
	"auth_type":     "description.SourceCredentialsInfo.AuthType",
	"og_account_id": "metadata.SourceID",
	"server_type":   "description.SourceCredentialsInfo.ServerType",
}

func GetCodeBuildSourceCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeBuildSourceCredential")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeBuildSourceCredentialPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeBuildSourceCredentialFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeBuildSourceCredential =============================

// ==========================  START: CodeBuildBuild =============================

type CodeBuildBuild struct {
	Description   aws.CodeBuildBuildDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type CodeBuildBuildHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  CodeBuildBuild `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type CodeBuildBuildHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []CodeBuildBuildHit `json:"hits"`
}

type CodeBuildBuildSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  CodeBuildBuildHits `json:"hits"`
}

type CodeBuildBuildPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeBuildBuildPaginator(filters []essdk.BoolFilter, limit *int64) (CodeBuildBuildPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codebuild_build", filters, limit)
	if err != nil {
		return CodeBuildBuildPaginator{}, err
	}

	p := CodeBuildBuildPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeBuildBuildPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeBuildBuildPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeBuildBuildPaginator) NextPage(ctx context.Context) ([]CodeBuildBuild, error) {
	var response CodeBuildBuildSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeBuildBuild
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeBuildBuildFilters = map[string]string{
	"arn":                            "description.Build.Arn",
	"artifacts":                      "description.Build.Artifacts",
	"build_batch_arn":                "description.Build.BuildBatchArn",
	"build_complete":                 "description.Build.BuildComplete",
	"build_number":                   "description.Build.BuildNumber",
	"build_status":                   "description.Build.BuildStatus",
	"cache":                          "description.Build.Cache",
	"current_phase":                  "description.Build.CurrentPhase",
	"debug_session":                  "description.Build.DebugSession",
	"encryption_key":                 "description.Build.EncryptionKey",
	"end_time":                       "description.Build.EndTime",
	"environment":                    "description.Build.Environment",
	"exported_environment_variables": "description.Build.ExportedEnvironmentVariables",
	"file_system_locations":          "description.Build.FileSystemLocations",
	"id":                             "description.Build.Id",
	"initiator":                      "description.Build.Initiator",
	"og_account_id":                  "metadata.SourceID",
	"logs":                           "description.Build.Logs",
	"network_interfaces":             "description.Build.NetworkInterface",
	"phases":                         "description.Build.Phases",
	"project_name":                   "description.Build.ProjectName",
	"queued_timeout_in_minutes":      "description.Build.QueuedTimeoutInMinutes",
	"report_arns":                    "description.Build.ReportArns",
	"resolved_source_version":        "description.Build.ResolvedSourceVersion",
	"secondary_artifacts":            "description.Build.SecondaryArtifacts",
	"secondary_source_versions":      "description.Build.SecondarySourceVersions",
	"secondary_sources":              "description.Build.SecondarySources",
	"source":                         "description.Build.Source",
	"source_version":                 "description.Build.SourceVersion",
	"start_time":                     "description.Build.StartTime",
	"timeout_in_minutes":             "description.Build.TimeoutInMinutes",
	"title":                          "description.Build.Arn",
	"vpc_config":                     "description.Build.VpcConfig",
}

func ListCodeBuildBuild(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeBuildBuild")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildBuild NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildBuild NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildBuild GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildBuild GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildBuild GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeBuildBuildPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeBuildBuildFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeBuildBuild NewCodeBuildBuildPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeBuildBuild paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeBuildBuildFilters = map[string]string{
	"arn":                            "description.Build.Arn",
	"artifacts":                      "description.Build.Artifacts",
	"build_batch_arn":                "description.Build.BuildBatchArn",
	"build_complete":                 "description.Build.BuildComplete",
	"build_number":                   "description.Build.BuildNumber",
	"build_status":                   "description.Build.BuildStatus",
	"cache":                          "description.Build.Cache",
	"current_phase":                  "description.Build.CurrentPhase",
	"debug_session":                  "description.Build.DebugSession",
	"encryption_key":                 "description.Build.EncryptionKey",
	"end_time":                       "description.Build.EndTime",
	"environment":                    "description.Build.Environment",
	"exported_environment_variables": "description.Build.ExportedEnvironmentVariables",
	"file_system_locations":          "description.Build.FileSystemLocations",
	"id":                             "description.Build.Id",
	"initiator":                      "description.Build.Initiator",
	"og_account_id":                  "metadata.SourceID",
	"logs":                           "description.Build.Logs",
	"network_interfaces":             "description.Build.NetworkInterface",
	"phases":                         "description.Build.Phases",
	"project_name":                   "description.Build.ProjectName",
	"queued_timeout_in_minutes":      "description.Build.QueuedTimeoutInMinutes",
	"report_arns":                    "description.Build.ReportArns",
	"resolved_source_version":        "description.Build.ResolvedSourceVersion",
	"secondary_artifacts":            "description.Build.SecondaryArtifacts",
	"secondary_source_versions":      "description.Build.SecondarySourceVersions",
	"secondary_sources":              "description.Build.SecondarySources",
	"source":                         "description.Build.Source",
	"source_version":                 "description.Build.SourceVersion",
	"start_time":                     "description.Build.StartTime",
	"timeout_in_minutes":             "description.Build.TimeoutInMinutes",
	"title":                          "description.Build.Arn",
	"vpc_config":                     "description.Build.VpcConfig",
}

func GetCodeBuildBuild(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeBuildBuild")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeBuildBuildPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeBuildBuildFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeBuildBuild =============================

// ==========================  START: ConfigConfigurationRecorder =============================

type ConfigConfigurationRecorder struct {
	Description   aws.ConfigConfigurationRecorderDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ConfigConfigurationRecorderHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  ConfigConfigurationRecorder `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type ConfigConfigurationRecorderHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []ConfigConfigurationRecorderHit `json:"hits"`
}

type ConfigConfigurationRecorderSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  ConfigConfigurationRecorderHits `json:"hits"`
}

type ConfigConfigurationRecorderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigConfigurationRecorderPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigConfigurationRecorderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_configurationrecorder", filters, limit)
	if err != nil {
		return ConfigConfigurationRecorderPaginator{}, err
	}

	p := ConfigConfigurationRecorderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigConfigurationRecorderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigConfigurationRecorderPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ConfigConfigurationRecorderPaginator) NextPage(ctx context.Context) ([]ConfigConfigurationRecorder, error) {
	var response ConfigConfigurationRecorderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigConfigurationRecorder
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigConfigurationRecorderFilters = map[string]string{
	"arn":              "arn",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.ConfigurationRecorder.Name",
	"recording_group":  "description.ConfigurationRecorder.RecordingGroup",
	"role_arn":         "description.ConfigurationRecorder.RoleARN",
	"status":           "description.ConfigurationRecordersStatus",
	"status_recording": "description.ConfigurationRecordersStatus.Recording",
	"title":            "description.ConfigurationRecorder.Name",
}

func ListConfigConfigurationRecorder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigConfigurationRecorder")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConfigurationRecorder NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConfigurationRecorder NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConfigurationRecorder GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConfigurationRecorder GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConfigurationRecorder GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewConfigConfigurationRecorderPaginator(essdk.BuildFilter(ctx, d.QueryContext, listConfigConfigurationRecorderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConfigurationRecorder NewConfigConfigurationRecorderPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListConfigConfigurationRecorder paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getConfigConfigurationRecorderFilters = map[string]string{
	"arn":              "arn",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.ConfigurationRecorder.Name",
	"recording_group":  "description.ConfigurationRecorder.RecordingGroup",
	"role_arn":         "description.ConfigurationRecorder.RoleARN",
	"status":           "description.ConfigurationRecordersStatus",
	"status_recording": "description.ConfigurationRecordersStatus.Recording",
	"title":            "description.ConfigurationRecorder.Name",
}

func GetConfigConfigurationRecorder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigConfigurationRecorder")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewConfigConfigurationRecorderPaginator(essdk.BuildFilter(ctx, d.QueryContext, getConfigConfigurationRecorderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ConfigConfigurationRecorder =============================

// ==========================  START: ConfigAggregationAuthorization =============================

type ConfigAggregationAuthorization struct {
	Description   aws.ConfigAggregationAuthorizationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type ConfigAggregationAuthorizationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  ConfigAggregationAuthorization `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type ConfigAggregationAuthorizationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []ConfigAggregationAuthorizationHit `json:"hits"`
}

type ConfigAggregationAuthorizationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  ConfigAggregationAuthorizationHits `json:"hits"`
}

type ConfigAggregationAuthorizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigAggregationAuthorizationPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigAggregationAuthorizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_aggregationauthorization", filters, limit)
	if err != nil {
		return ConfigAggregationAuthorizationPaginator{}, err
	}

	p := ConfigAggregationAuthorizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigAggregationAuthorizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigAggregationAuthorizationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ConfigAggregationAuthorizationPaginator) NextPage(ctx context.Context) ([]ConfigAggregationAuthorization, error) {
	var response ConfigAggregationAuthorizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigAggregationAuthorization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigAggregationAuthorizationFilters = map[string]string{
	"arn":                   "description.AggregationAuthorization.AggregationAuthorizationArn",
	"authorized_account_id": "description.AggregationAuthorization.AuthorizedAccountId",
	"authorized_aws_region": "description.AggregationAuthorization.AuthorizedAwsRegion",
	"creation_time":         "description.AggregationAuthorization.CreationTime",
	"og_account_id":         "metadata.SourceID",
	"tags_src":              "description.Tags",
	"title":                 "description.AggregationAuthorization.AggregationAuthorizationArn",
}

func ListConfigAggregationAuthorization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigAggregationAuthorization")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigAggregationAuthorization NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigAggregationAuthorization NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigAggregationAuthorization GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigAggregationAuthorization GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigAggregationAuthorization GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewConfigAggregationAuthorizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listConfigAggregationAuthorizationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigAggregationAuthorization NewConfigAggregationAuthorizationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListConfigAggregationAuthorization paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getConfigAggregationAuthorizationFilters = map[string]string{
	"arn":                   "description.AggregationAuthorization.AggregationAuthorizationArn",
	"authorized_account_id": "description.AggregationAuthorization.AuthorizedAccountId",
	"authorized_aws_region": "description.AggregationAuthorization.AuthorizedAwsRegion",
	"creation_time":         "description.AggregationAuthorization.CreationTime",
	"og_account_id":         "metadata.SourceID",
	"tags_src":              "description.Tags",
	"title":                 "description.AggregationAuthorization.AggregationAuthorizationArn",
}

func GetConfigAggregationAuthorization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigAggregationAuthorization")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewConfigAggregationAuthorizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getConfigAggregationAuthorizationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ConfigAggregationAuthorization =============================

// ==========================  START: ConfigConformancePack =============================

type ConfigConformancePack struct {
	Description   aws.ConfigConformancePackDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ConfigConformancePackHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ConfigConformancePack `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ConfigConformancePackHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ConfigConformancePackHit `json:"hits"`
}

type ConfigConformancePackSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ConfigConformancePackHits `json:"hits"`
}

type ConfigConformancePackPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigConformancePackPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigConformancePackPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_conformancepack", filters, limit)
	if err != nil {
		return ConfigConformancePackPaginator{}, err
	}

	p := ConfigConformancePackPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigConformancePackPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigConformancePackPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ConfigConformancePackPaginator) NextPage(ctx context.Context) ([]ConfigConformancePack, error) {
	var response ConfigConformancePackSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigConformancePack
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigConformancePackFilters = map[string]string{
	"arn":                        "description.ConformancePack.ConformancePackArn",
	"conformance_pack_id":        "description.ConformancePack.ConformancePackId",
	"created_by":                 "description.ConformancePack.CreatedBy",
	"delivery_s3_bucket":         "description.ConformancePack.DeliveryS3Bucket",
	"delivery_s3_key_prefix":     "description.ConformancePack.DeliveryS3KeyPrefix",
	"input_parameters":           "description.ConformancePack.ConformancePackInputParameters",
	"og_account_id":              "metadata.SourceID",
	"last_update_requested_time": "description.ConformancePack.LastUpdateRequestedTime",
	"name":                       "description.ConformancePack.ConformancePackName",
	"title":                      "description.ConformancePack.ConformancePackName",
}

func ListConfigConformancePack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigConformancePack")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConformancePack NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConformancePack NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConformancePack GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConformancePack GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConformancePack GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewConfigConformancePackPaginator(essdk.BuildFilter(ctx, d.QueryContext, listConfigConformancePackFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigConformancePack NewConfigConformancePackPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListConfigConformancePack paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getConfigConformancePackFilters = map[string]string{
	"arn":                        "description.ConformancePack.ConformancePackArn",
	"conformance_pack_id":        "description.ConformancePack.ConformancePackId",
	"created_by":                 "description.ConformancePack.CreatedBy",
	"delivery_s3_bucket":         "description.ConformancePack.DeliveryS3Bucket",
	"delivery_s3_key_prefix":     "description.ConformancePack.DeliveryS3KeyPrefix",
	"input_parameters":           "description.ConformancePack.ConformancePackInputParameters",
	"og_account_id":              "metadata.SourceID",
	"last_update_requested_time": "description.ConformancePack.LastUpdateRequestedTime",
	"name":                       "description.ConformancePack.ConformancePackName",
	"title":                      "description.ConformancePack.ConformancePackName",
}

func GetConfigConformancePack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigConformancePack")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewConfigConformancePackPaginator(essdk.BuildFilter(ctx, d.QueryContext, getConfigConformancePackFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ConfigConformancePack =============================

// ==========================  START: ConfigRule =============================

type ConfigRule struct {
	Description   aws.ConfigRuleDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ConfigRuleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ConfigRule    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ConfigRuleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ConfigRuleHit   `json:"hits"`
}

type ConfigRuleSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ConfigRuleHits `json:"hits"`
}

type ConfigRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigRulePaginator(filters []essdk.BoolFilter, limit *int64) (ConfigRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_rule", filters, limit)
	if err != nil {
		return ConfigRulePaginator{}, err
	}

	p := ConfigRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ConfigRulePaginator) NextPage(ctx context.Context) ([]ConfigRule, error) {
	var response ConfigRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigRuleFilters = map[string]string{
	"arn":                         "configrulearn",
	"compliance_by_config_rule":   "description.Compliance",
	"created_by":                  "description.Rule.CreatedBy",
	"description":                 "description.Rule.Description",
	"evaluation_modes":            "description.Rule.EvaluationModes",
	"input_parameters":            "description.Rule.InputParameters",
	"og_account_id":               "metadata.SourceID",
	"maximum_execution_frequency": "description.Rule.MaximumExecutionFrequency",
	"name":                        "description.Rule.ConfigRuleName",
	"rule_id":                     "description.Rule.ConfigRuleId",
	"rule_state":                  "description.Rule.ConfigRuleState",
	"scope":                       "description.Rule.Scope",
	"source":                      "description.Rule.Source",
	"tags_src":                    "description.Tags",
	"title":                       "description.Rule.ConfigRuleName",
}

func ListConfigRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewConfigRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listConfigRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRule NewConfigRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListConfigRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getConfigRuleFilters = map[string]string{
	"arn":                         "configrulearn",
	"compliance_by_config_rule":   "description.Compliance",
	"created_by":                  "description.Rule.CreatedBy",
	"description":                 "description.Rule.Description",
	"evaluation_modes":            "description.Rule.EvaluationModes",
	"input_parameters":            "description.Rule.InputParameters",
	"og_account_id":               "metadata.SourceID",
	"maximum_execution_frequency": "description.Rule.MaximumExecutionFrequency",
	"name":                        "description.Rule.ConfigRuleName",
	"rule_id":                     "description.Rule.ConfigRuleId",
	"rule_state":                  "description.Rule.ConfigRuleState",
	"scope":                       "description.Rule.Scope",
	"source":                      "description.Rule.Source",
	"tags_src":                    "description.Tags",
	"title":                       "description.Rule.ConfigRuleName",
}

func GetConfigRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewConfigRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getConfigRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ConfigRule =============================

// ==========================  START: ConfigRetentionConfiguration =============================

type ConfigRetentionConfiguration struct {
	Description   aws.ConfigRetentionConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type ConfigRetentionConfigurationHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  ConfigRetentionConfiguration `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type ConfigRetentionConfigurationHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []ConfigRetentionConfigurationHit `json:"hits"`
}

type ConfigRetentionConfigurationSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  ConfigRetentionConfigurationHits `json:"hits"`
}

type ConfigRetentionConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConfigRetentionConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (ConfigRetentionConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_config_retentionconfiguration", filters, limit)
	if err != nil {
		return ConfigRetentionConfigurationPaginator{}, err
	}

	p := ConfigRetentionConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConfigRetentionConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConfigRetentionConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ConfigRetentionConfigurationPaginator) NextPage(ctx context.Context) ([]ConfigRetentionConfiguration, error) {
	var response ConfigRetentionConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ConfigRetentionConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConfigRetentionConfigurationFilters = map[string]string{
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.RetentionConfiguration.Name",
	"retention_period_in_days": "description.RetentionConfiguration.RetentionPeriodInDays",
	"title":                    "description.RetentionConfiguration.Name",
}

func ListConfigRetentionConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConfigRetentionConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRetentionConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRetentionConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRetentionConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRetentionConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRetentionConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewConfigRetentionConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listConfigRetentionConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListConfigRetentionConfiguration NewConfigRetentionConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListConfigRetentionConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getConfigRetentionConfigurationFilters = map[string]string{
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.ConformancePack.ConformancePackName",
	"retention_period_in_days": "description.RetentionConfiguration.RetentionPeriodInDays",
	"title":                    "description.RetentionConfiguration.Name",
}

func GetConfigRetentionConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConfigRetentionConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewConfigRetentionConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getConfigRetentionConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ConfigRetentionConfiguration =============================

// ==========================  START: DAXCluster =============================

type DAXCluster struct {
	Description   aws.DAXClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type DAXClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DAXCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DAXClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DAXClusterHit   `json:"hits"`
}

type DAXClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  DAXClusterHits `json:"hits"`
}

type DAXClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXClusterPaginator(filters []essdk.BoolFilter, limit *int64) (DAXClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_cluster", filters, limit)
	if err != nil {
		return DAXClusterPaginator{}, err
	}

	p := DAXClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DAXClusterPaginator) NextPage(ctx context.Context) ([]DAXCluster, error) {
	var response DAXClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXClusterFilters = map[string]string{
	"active_nodes":                 "description.Cluster.ActiveNodes",
	"arn":                          "description.Cluster.ClusterArn",
	"cluster_discovery_endpoint":   "description.Cluster.ClusterDiscoveryEndpoint",
	"cluster_name":                 "description.Cluster.ClusterName",
	"description":                  "description.Cluster.Description",
	"iam_role_arn":                 "description.Cluster.IamRoleArn",
	"og_account_id":                "metadata.SourceID",
	"node_ids_to_remove":           "description.Cluster.NodeIdsToRemove",
	"node_type":                    "description.Cluster.NodeType",
	"nodes":                        "description.Cluster.Nodes",
	"notification_configuration":   "description.Cluster.NotificationConfiguration",
	"parameter_group":              "description.Cluster.ParameterGroup",
	"preferred_maintenance_window": "description.Cluster.PreferredMaintenanceWindow",
	"security_groups":              "description.Cluster.SecurityGroups",
	"sse_description":              "description.Cluster.SSEDescription",
	"status":                       "description.Cluster.Status",
	"subnet_group":                 "description.Cluster.SubnetGroup",
	"tags_src":                     "description.Tags",
	"title":                        "description.Cluster.ClusterName",
	"total_nodes":                  "description.Cluster.TotalNodes",
}

func ListDAXCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDAXClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDAXClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXCluster NewDAXClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDAXCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDAXClusterFilters = map[string]string{
	"active_nodes":                 "description.Cluster.ActiveNodes",
	"arn":                          "description.Cluster.ClusterArn",
	"cluster_discovery_endpoint":   "description.Cluster.ClusterDiscoveryEndpoint",
	"cluster_name":                 "description.Cluster.ClusterName",
	"description":                  "description.Cluster.Description",
	"iam_role_arn":                 "description.Cluster.IamRoleArn",
	"og_account_id":                "metadata.SourceID",
	"node_ids_to_remove":           "description.Cluster.NodeIdsToRemove",
	"node_type":                    "description.Cluster.NodeType",
	"nodes":                        "description.Cluster.Nodes",
	"notification_configuration":   "description.Cluster.NotificationConfiguration",
	"parameter_group":              "description.Cluster.ParameterGroup",
	"preferred_maintenance_window": "description.Cluster.PreferredMaintenanceWindow",
	"security_groups":              "description.Cluster.SecurityGroups",
	"sse_description":              "description.Cluster.SSEDescription",
	"status":                       "description.Cluster.Status",
	"subnet_group":                 "description.Cluster.SubnetGroup",
	"tags_src":                     "description.Tags",
	"title":                        "description.Cluster.ClusterName",
	"total_nodes":                  "description.Cluster.TotalNodes",
}

func GetDAXCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDAXClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDAXClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DAXCluster =============================

// ==========================  START: DAXParameterGroup =============================

type DAXParameterGroup struct {
	Description   aws.DAXParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type DAXParameterGroupHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DAXParameterGroup `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DAXParameterGroupHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []DAXParameterGroupHit `json:"hits"`
}

type DAXParameterGroupSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DAXParameterGroupHits `json:"hits"`
}

type DAXParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (DAXParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_parametergroup", filters, limit)
	if err != nil {
		return DAXParameterGroupPaginator{}, err
	}

	p := DAXParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXParameterGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DAXParameterGroupPaginator) NextPage(ctx context.Context) ([]DAXParameterGroup, error) {
	var response DAXParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXParameterGroupFilters = map[string]string{
	"description":          "description.ParameterGroup.Description",
	"og_account_id":        "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroup.ParameterGroupName",
	"title":                "description.ParameterGroup.ParameterGroupName",
}

func ListDAXParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameterGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameterGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDAXParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDAXParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameterGroup NewDAXParameterGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDAXParameterGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDAXParameterGroupFilters = map[string]string{
	"description":          "description.ParameterGroup.Description",
	"og_account_id":        "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroup.ParameterGroupName",
	"title":                "description.ParameterGroup.ParameterGroupName",
}

func GetDAXParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDAXParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDAXParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DAXParameterGroup =============================

// ==========================  START: DAXParameter =============================

type DAXParameter struct {
	Description   aws.DAXParameterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type DAXParameterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DAXParameter  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DAXParameterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DAXParameterHit `json:"hits"`
}

type DAXParameterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  DAXParameterHits `json:"hits"`
}

type DAXParameterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXParameterPaginator(filters []essdk.BoolFilter, limit *int64) (DAXParameterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_parameter", filters, limit)
	if err != nil {
		return DAXParameterPaginator{}, err
	}

	p := DAXParameterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXParameterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXParameterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DAXParameterPaginator) NextPage(ctx context.Context) ([]DAXParameter, error) {
	var response DAXParameterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXParameter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXParameterFilters = map[string]string{
	"allowed_values":       "description.Parameter.AllowedValues",
	"change_type":          "description.Parameter.ChangeType",
	"data_type":            "description.Parameter.DataType",
	"description":          "description.Parameter.Description",
	"is_modifiable":        "description.Parameter.IsModifiable",
	"og_account_id":        "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroupName",
	"parameter_name":       "description.Parameter.ParameterName",
	"parameter_type":       "description.Parameter.ParameterType",
	"parameter_value":      "description.Parameter.ParameterValue",
	"source":               "description.Parameter.Source",
	"title":                "description.Parameter.ParameterName",
}

func ListDAXParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXParameter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameter NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameter NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameter GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameter GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameter GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDAXParameterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDAXParameterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXParameter NewDAXParameterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDAXParameter paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDAXParameterFilters = map[string]string{
	"allowed_values":       "description.Parameter.AllowedValues",
	"change_type":          "description.Parameter.ChangeType",
	"data_type":            "description.Parameter.DataType",
	"description":          "description.Parameter.Description",
	"is_modifiable":        "description.Parameter.IsModifiable",
	"og_account_id":        "metadata.SourceID",
	"parameter_group_name": "description.ParameterGroupName",
	"parameter_name":       "description.Parameter.ParameterName",
	"parameter_type":       "description.Parameter.ParameterType",
	"parameter_value":      "description.Parameter.ParameterValue",
	"source":               "description.Parameter.Source",
	"title":                "description.Parameter.ParameterName",
}

func GetDAXParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXParameter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDAXParameterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDAXParameterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DAXParameter =============================

// ==========================  START: DAXSubnetGroup =============================

type DAXSubnetGroup struct {
	Description   aws.DAXSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type DAXSubnetGroupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  DAXSubnetGroup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type DAXSubnetGroupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []DAXSubnetGroupHit `json:"hits"`
}

type DAXSubnetGroupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  DAXSubnetGroupHits `json:"hits"`
}

type DAXSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDAXSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (DAXSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dax_subnetgroup", filters, limit)
	if err != nil {
		return DAXSubnetGroupPaginator{}, err
	}

	p := DAXSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DAXSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DAXSubnetGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DAXSubnetGroupPaginator) NextPage(ctx context.Context) ([]DAXSubnetGroup, error) {
	var response DAXSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DAXSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDAXSubnetGroupFilters = map[string]string{
	"description":       "description.SubnetGroup.Description",
	"og_account_id":     "metadata.SourceID",
	"subnet_group_name": "description.SubnetGroup.SubnetGroupName",
	"subnets":           "description.SubnetGroup.Subnets",
	"title":             "description.SubnetGroup.SubnetGroupName",
	"vpc_id":            "description.SubnetGroup.VpcId",
}

func ListDAXSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDAXSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXSubnetGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXSubnetGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDAXSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDAXSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDAXSubnetGroup NewDAXSubnetGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDAXSubnetGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDAXSubnetGroupFilters = map[string]string{
	"description":       "description.SubnetGroup.Description",
	"og_account_id":     "metadata.SourceID",
	"subnet_group_name": "description.SubnetGroup.SubnetGroupName",
	"subnets":           "description.SubnetGroup.Subnets",
	"title":             "description.SubnetGroup.SubnetGroupName",
	"vpc_id":            "description.SubnetGroup.VpcId",
}

func GetDAXSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDAXSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDAXSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDAXSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DAXSubnetGroup =============================

// ==========================  START: DMSReplicationInstance =============================

type DMSReplicationInstance struct {
	Description   aws.DMSReplicationInstanceDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type DMSReplicationInstanceHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  DMSReplicationInstance `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type DMSReplicationInstanceHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []DMSReplicationInstanceHit `json:"hits"`
}

type DMSReplicationInstanceSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  DMSReplicationInstanceHits `json:"hits"`
}

type DMSReplicationInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDMSReplicationInstancePaginator(filters []essdk.BoolFilter, limit *int64) (DMSReplicationInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dms_replicationinstance", filters, limit)
	if err != nil {
		return DMSReplicationInstancePaginator{}, err
	}

	p := DMSReplicationInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DMSReplicationInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DMSReplicationInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DMSReplicationInstancePaginator) NextPage(ctx context.Context) ([]DMSReplicationInstance, error) {
	var response DMSReplicationInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DMSReplicationInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDMSReplicationInstanceFilters = map[string]string{
	"allocated_storage":                         "description.ReplicationInstance.AllocatedStorage",
	"arn":                                       "description.ReplicationInstance.ReplicationInstanceArn",
	"auto_minor_version_upgrade":                "description.ReplicationInstance.AutoMinorVersionUpgrade",
	"availability_zone":                         "description.ReplicationInstance.AvailabilityZone",
	"dns_name_servers":                          "description.ReplicationInstance.DnsNameServers",
	"engine_version":                            "description.ReplicationInstance.EngineVersion",
	"free_until":                                "description.ReplicationInstance.FreeUntil",
	"instance_create_time":                      "description.ReplicationInstance.InstanceCreateTime",
	"og_account_id":                             "metadata.SourceID",
	"kms_key_id":                                "description.ReplicationInstance.KmsKeyId",
	"multi_az":                                  "description.ReplicationInstance.MultiAZ",
	"pending_modified_values":                   "description.ReplicationInstance.PendingModifiedValues",
	"preferred_maintenance_window":              "description.ReplicationInstance.PreferredMaintenanceWindow",
	"publicly_accessible":                       "description.ReplicationInstance.PubliclyAccessible",
	"replication_instance_class":                "description.ReplicationInstance.ReplicationInstanceClass",
	"replication_instance_identifier":           "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"replication_instance_private_ip_address":   "description.ReplicationInstance.ReplicationInstancePrivateIpAddress",
	"replication_instance_private_ip_addresses": "description.ReplicationInstance.ReplicationInstancePrivateIpAddresses",
	"replication_instance_public_ip_address":    "description.ReplicationInstance.ReplicationInstancePublicIpAddress",
	"replication_instance_public_ip_addresses":  "description.ReplicationInstance.ReplicationInstancePublicIpAddresses",
	"replication_instance_status":               "description.ReplicationInstance.ReplicationInstanceStatus",
	"replication_subnet_group":                  "description.ReplicationInstance.ReplicationSubnetGroup",
	"secondary_availability_zone":               "description.ReplicationInstance.SecondaryAvailabilityZone",
	"tags_src":                                  "description.Tags",
	"title":                                     "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"vpc_security_groups":                       "description.ReplicationInstance.VpcSecurityGroups",
}

func ListDMSReplicationInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDMSReplicationInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDMSReplicationInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDMSReplicationInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationInstance NewDMSReplicationInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDMSReplicationInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDMSReplicationInstanceFilters = map[string]string{
	"allocated_storage":                         "description.ReplicationInstance.AllocatedStorage",
	"arn":                                       "description.ReplicationInstance.ReplicationInstanceArn",
	"auto_minor_version_upgrade":                "description.ReplicationInstance.AutoMinorVersionUpgrade",
	"availability_zone":                         "description.ReplicationInstance.AvailabilityZone",
	"dns_name_servers":                          "description.ReplicationInstance.DnsNameServers",
	"engine_version":                            "description.ReplicationInstance.EngineVersion",
	"free_until":                                "description.ReplicationInstance.FreeUntil",
	"instance_create_time":                      "description.ReplicationInstance.InstanceCreateTime",
	"og_account_id":                             "metadata.SourceID",
	"kms_key_id":                                "description.ReplicationInstance.KmsKeyId",
	"multi_az":                                  "description.ReplicationInstance.MultiAZ",
	"pending_modified_values":                   "description.ReplicationInstance.PendingModifiedValues",
	"preferred_maintenance_window":              "description.ReplicationInstance.PreferredMaintenanceWindow",
	"publicly_accessible":                       "description.ReplicationInstance.PubliclyAccessible",
	"replication_instance_class":                "description.ReplicationInstance.ReplicationInstanceClass",
	"replication_instance_identifier":           "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"replication_instance_private_ip_address":   "description.ReplicationInstance.ReplicationInstancePrivateIpAddress",
	"replication_instance_private_ip_addresses": "description.ReplicationInstance.ReplicationInstancePrivateIpAddresses",
	"replication_instance_public_ip_address":    "description.ReplicationInstance.ReplicationInstancePublicIpAddress",
	"replication_instance_public_ip_addresses":  "description.ReplicationInstance.ReplicationInstancePublicIpAddresses",
	"replication_instance_status":               "description.ReplicationInstance.ReplicationInstanceStatus",
	"replication_subnet_group":                  "description.ReplicationInstance.ReplicationSubnetGroup",
	"secondary_availability_zone":               "description.ReplicationInstance.SecondaryAvailabilityZone",
	"tags_src":                                  "description.Tags",
	"title":                                     "description.ReplicationInstance.ReplicationInstanceIdentifier",
	"vpc_security_groups":                       "description.ReplicationInstance.VpcSecurityGroups",
}

func GetDMSReplicationInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDMSReplicationInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDMSReplicationInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDMSReplicationInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DMSReplicationInstance =============================

// ==========================  START: DMSEndpoint =============================

type DMSEndpoint struct {
	Description   aws.DMSEndpointDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type DMSEndpointHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DMSEndpoint   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DMSEndpointHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DMSEndpointHit  `json:"hits"`
}

type DMSEndpointSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  DMSEndpointHits `json:"hits"`
}

type DMSEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDMSEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (DMSEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dms_endpoint", filters, limit)
	if err != nil {
		return DMSEndpointPaginator{}, err
	}

	p := DMSEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DMSEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DMSEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DMSEndpointPaginator) NextPage(ctx context.Context) ([]DMSEndpoint, error) {
	var response DMSEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DMSEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDMSEndpointFilters = map[string]string{
	"arn":                           "description.Endpoint.EndpointArn",
	"certificate_arn":               "description.Endpoint.CertificateArn",
	"database_name":                 "description.Endpoint.DatabaseName",
	"dms_transfer_settings":         "description.Endpoint.DmsTransferSettings",
	"doc_db_settings":               "description.Endpoint.DocDbSettings",
	"dynamo_db_settings":            "description.Endpoint.DynamoDbSettings",
	"elasticsearch_settings":        "description.Endpoint.ElasticsearchSettings",
	"endpoint_identifier":           "description.Endpoint.EndpointIdentifier",
	"endpoint_type":                 "description.Endpoint.EndpointType",
	"engine_display_name":           "description.Endpoint.EngineDisplayName",
	"engine_name":                   "description.Endpoint.EngineName",
	"external_id":                   "description.Endpoint.ExternalId",
	"external_table_definition":     "description.Endpoint.ExternalTableDefinition",
	"extra_connection_attributes":   "description.Endpoint.ExtraConnectionAttributes",
	"gcp_my_sql_settings":           "description.Endpoint.GcpMySQLSettings",
	"ibm_db2_settings":              "description.Endpoint.IBMDb2Settings",
	"kafka_settings":                "description.Endpoint.KafkaSettings",
	"kinesis_settings":              "description.Endpoint.KinesisSettings",
	"kms_key_id":                    "description.Endpoint.KmsKeyId",
	"microsoft_sql_server_settings": "description.Endpoint.MicrosoftSQLServerSettings",
	"mongo_db_settings":             "description.Endpoint.MongoDbSettings",
	"my_sql_settings":               "description.Endpoint.MySQLSettings",
	"neptune_settings":              "description.Endpoint.NeptuneSettings",
	"oracle_settings":               "description.Endpoint.OracleSettings",
	"port":                          "description.Endpoint.Port",
	"postgre_sql_settings":          "description.Endpoint.PostgreSQLSettings",
	"redis_settings":                "description.Endpoint.RedisSettings",
	"redshift_settings":             "description.Endpoint.RedshiftSettings",
	"s3_settings":                   "description.Endpoint.S3Settings",
	"server_name":                   "description.Endpoint.ServerName",
	"service_access_role_arn":       "description.Endpoint.ServiceAccessRoleArn",
	"ssl_mode":                      "description.Endpoint.SslMode",
	"status":                        "description.Endpoint.Status",
	"sybase_settings":               "description.Endpoint.SybaseSettings",
	"tags_src":                      "description.Tags",
	"title":                         "description.Endpoint.EndpointIdentifier",
	"username":                      "description.Endpoint.Username",
}

func ListDMSEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDMSEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDMSEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDMSEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSEndpoint NewDMSEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDMSEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDMSEndpointFilters = map[string]string{
	"arn":                           "description.Endpoint.EndpointArn",
	"certificate_arn":               "description.Endpoint.CertificateArn",
	"database_name":                 "description.Endpoint.DatabaseName",
	"dms_transfer_settings":         "description.Endpoint.DmsTransferSettings",
	"doc_db_settings":               "description.Endpoint.DocDbSettings",
	"dynamo_db_settings":            "description.Endpoint.DynamoDbSettings",
	"elasticsearch_settings":        "description.Endpoint.ElasticsearchSettings",
	"endpoint_identifier":           "description.Endpoint.EndpointIdentifier",
	"endpoint_type":                 "description.Endpoint.EndpointType",
	"engine_display_name":           "description.Endpoint.EngineDisplayName",
	"engine_name":                   "description.Endpoint.EngineName",
	"external_id":                   "description.Endpoint.ExternalId",
	"external_table_definition":     "description.Endpoint.ExternalTableDefinition",
	"extra_connection_attributes":   "description.Endpoint.ExtraConnectionAttributes",
	"gcp_my_sql_settings":           "description.Endpoint.GcpMySQLSettings",
	"ibm_db2_settings":              "description.Endpoint.IBMDb2Settings",
	"kafka_settings":                "description.Endpoint.KafkaSettings",
	"kinesis_settings":              "description.Endpoint.KinesisSettings",
	"kms_key_id":                    "description.Endpoint.KmsKeyId",
	"microsoft_sql_server_settings": "description.Endpoint.MicrosoftSQLServerSettings",
	"mongo_db_settings":             "description.Endpoint.MongoDbSettings",
	"my_sql_settings":               "description.Endpoint.MySQLSettings",
	"neptune_settings":              "description.Endpoint.NeptuneSettings",
	"oracle_settings":               "description.Endpoint.OracleSettings",
	"port":                          "description.Endpoint.Port",
	"postgre_sql_settings":          "description.Endpoint.PostgreSQLSettings",
	"redis_settings":                "description.Endpoint.RedisSettings",
	"redshift_settings":             "description.Endpoint.RedshiftSettings",
	"s3_settings":                   "description.Endpoint.S3Settings",
	"server_name":                   "description.Endpoint.ServerName",
	"service_access_role_arn":       "description.Endpoint.ServiceAccessRoleArn",
	"ssl_mode":                      "description.Endpoint.SslMode",
	"status":                        "description.Endpoint.Status",
	"sybase_settings":               "description.Endpoint.SybaseSettings",
	"tags_src":                      "description.Tags",
	"title":                         "description.Endpoint.EndpointIdentifier",
	"username":                      "description.Endpoint.Username",
}

func GetDMSEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDMSEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDMSEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDMSEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DMSEndpoint =============================

// ==========================  START: DMSReplicationTask =============================

type DMSReplicationTask struct {
	Description   aws.DMSReplicationTaskDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type DMSReplicationTaskHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  DMSReplicationTask `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type DMSReplicationTaskHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []DMSReplicationTaskHit `json:"hits"`
}

type DMSReplicationTaskSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  DMSReplicationTaskHits `json:"hits"`
}

type DMSReplicationTaskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDMSReplicationTaskPaginator(filters []essdk.BoolFilter, limit *int64) (DMSReplicationTaskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dms_replicationtask", filters, limit)
	if err != nil {
		return DMSReplicationTaskPaginator{}, err
	}

	p := DMSReplicationTaskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DMSReplicationTaskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DMSReplicationTaskPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DMSReplicationTaskPaginator) NextPage(ctx context.Context) ([]DMSReplicationTask, error) {
	var response DMSReplicationTaskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DMSReplicationTask
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDMSReplicationTaskFilters = map[string]string{
	"arn":                             "description.ReplicationTask.ReplicationTaskArn",
	"cdc_start_position":              "description.ReplicationTask.CdcStartPosition",
	"cdc_stop_position":               "description.ReplicationTask.CdcStopPosition",
	"last_failure_message":            "description.ReplicationTask.LastFailureMessage",
	"migration_type":                  "description.ReplicationTask.MigrationType",
	"recovery_checkpoint":             "description.ReplicationTask.RecoveryCheckpoint",
	"replication_instance_arn":        "description.ReplicationTask.ReplicationInstanceArn",
	"replication_task_creation_date":  "description.ReplicationTask.ReplicationTaskCreationDate",
	"replication_task_identifier":     "description.ReplicationTask.ReplicationTaskIdentifier",
	"replication_task_settings":       "description.ReplicationTask.ReplicationTaskSettings",
	"replication_task_start_date":     "description.ReplicationTask.ReplicationTaskStartDate",
	"replication_task_stats":          "description.ReplicationTask.ReplicationTaskStats",
	"source_endpoint_arn":             "description.ReplicationTask.SourceEndpointArn",
	"status":                          "description.ReplicationTask.Status",
	"stop_reason":                     "description.ReplicationTask.StopReason",
	"table_mappings":                  "description.ReplicationTask.TableMappings",
	"tags_src":                        "description.Tags",
	"target_endpoint_arn":             "description.ReplicationTask.TargetEndpointArn",
	"target_replication_instance_arn": "description.ReplicationTask.TargetReplicationInstanceArn",
	"task_data":                       "description.ReplicationTask.TaskData",
	"title":                           "description.ReplicationTask.ReplicationTaskIdentifier",
}

func ListDMSReplicationTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDMSReplicationTask")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationTask NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationTask NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDMSReplicationTaskPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDMSReplicationTaskFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDMSReplicationTask NewDMSReplicationTaskPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDMSReplicationTask paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDMSReplicationTaskFilters = map[string]string{
	"arn":                             "description.ReplicationTask.ReplicationTaskArn",
	"cdc_start_position":              "description.ReplicationTask.CdcStartPosition",
	"cdc_stop_position":               "description.ReplicationTask.CdcStopPosition",
	"last_failure_message":            "description.ReplicationTask.LastFailureMessage",
	"migration_type":                  "description.ReplicationTask.MigrationType",
	"recovery_checkpoint":             "description.ReplicationTask.RecoveryCheckpoint",
	"replication_instance_arn":        "description.ReplicationTask.ReplicationInstanceArn",
	"replication_task_creation_date":  "description.ReplicationTask.ReplicationTaskCreationDate",
	"replication_task_identifier":     "description.ReplicationTask.ReplicationTaskIdentifier",
	"replication_task_settings":       "description.ReplicationTask.ReplicationTaskSettings",
	"replication_task_start_date":     "description.ReplicationTask.ReplicationTaskStartDate",
	"replication_task_stats":          "description.ReplicationTask.ReplicationTaskStats",
	"source_endpoint_arn":             "description.ReplicationTask.SourceEndpointArn",
	"status":                          "description.ReplicationTask.Status",
	"stop_reason":                     "description.ReplicationTask.StopReason",
	"table_mappings":                  "description.ReplicationTask.TableMappings",
	"tags_src":                        "description.Tags",
	"target_endpoint_arn":             "description.ReplicationTask.TargetEndpointArn",
	"target_replication_instance_arn": "description.ReplicationTask.TargetReplicationInstanceArn",
	"task_data":                       "description.ReplicationTask.TaskData",
	"title":                           "description.ReplicationTask.ReplicationTaskIdentifier",
}

func GetDMSReplicationTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDMSReplicationTask")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDMSReplicationTaskPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDMSReplicationTaskFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DMSReplicationTask =============================

// ==========================  START: DynamoDbTable =============================

type DynamoDbTable struct {
	Description   aws.DynamoDbTableDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type DynamoDbTableHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DynamoDbTable `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DynamoDbTableHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []DynamoDbTableHit `json:"hits"`
}

type DynamoDbTableSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  DynamoDbTableHits `json:"hits"`
}

type DynamoDbTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbTablePaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_table", filters, limit)
	if err != nil {
		return DynamoDbTablePaginator{}, err
	}

	p := DynamoDbTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbTablePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynamoDbTablePaginator) NextPage(ctx context.Context) ([]DynamoDbTable, error) {
	var response DynamoDbTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbTableFilters = map[string]string{
	"archival_summary":                   "description.Table.ArchivalSummary",
	"arn":                                "description.Table.TableArn",
	"attribute_definitions":              "description.Table.AttributeDefinitions",
	"continuous_backups_status":          "description.ContinuousBackup.ContinuousBackupsStatus",
	"creation_date_time":                 "description.Table.CreationDateTime",
	"deletion_protection_enabled":        "description.Table.DeletionProtectionEnabled",
	"global_table_version":               "description.Table.GlobalTableVersion",
	"item_count":                         "description.Table.ItemCount",
	"og_account_id":                      "metadata.SourceID",
	"key_schema":                         "description.Table.KeySchema",
	"latest_stream_arn":                  "description.Table.LatestStreamArn",
	"latest_stream_label":                "description.Table.LatestStreamLabel",
	"name":                               "description.Table.TableName",
	"point_in_time_recovery_description": "description.ContinuousBackup.PointInTimeRecoveryDescription",
	"read_capacity":                      "description.Table.ProvisionedThroughput.ReadCapacityUnits",
	"sse_description":                    "description.Table.SSEDescription",
	"streaming_destination":              "description.StreamingDestination",
	"table_class":                        "description.Table.TableClassSummary.TableClass",
	"table_id":                           "description.Table.TableId",
	"table_size_bytes":                   "description.Table.TableSizeBytes",
	"table_status":                       "description.Table.TableStatus",
	"tags_src":                           "description.Tags",
	"title":                              "description.Table.TableName",
	"write_capacity":                     "description.Table.ProvisionedThroughput.WriteCapacityUnits",
}

func ListDynamoDbTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTable NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTable NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynamoDbTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynamoDbTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTable NewDynamoDbTablePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynamoDbTable paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynamoDbTableFilters = map[string]string{
	"archival_summary":                   "description.Table.ArchivalSummary",
	"arn":                                "description.Table.TableArn",
	"attribute_definitions":              "description.Table.AttributeDefinitions",
	"continuous_backups_status":          "description.ContinuousBackup.ContinuousBackupsStatus",
	"creation_date_time":                 "description.Table.CreationDateTime",
	"deletion_protection_enabled":        "description.Table.DeletionProtectionEnabled",
	"global_table_version":               "description.Table.GlobalTableVersion",
	"item_count":                         "description.Table.ItemCount",
	"og_account_id":                      "metadata.SourceID",
	"key_schema":                         "description.Table.KeySchema",
	"latest_stream_arn":                  "description.Table.LatestStreamArn",
	"latest_stream_label":                "description.Table.LatestStreamLabel",
	"name":                               "description.Table.TableName",
	"point_in_time_recovery_description": "description.ContinuousBackup.PointInTimeRecoveryDescription",
	"read_capacity":                      "description.Table.ProvisionedThroughput.ReadCapacityUnits",
	"sse_description":                    "description.Table.SSEDescription",
	"streaming_destination":              "description.StreamingDestination",
	"table_class":                        "description.Table.TableClassSummary.TableClass",
	"table_id":                           "description.Table.TableId",
	"table_size_bytes":                   "description.Table.TableSizeBytes",
	"table_status":                       "description.Table.TableStatus",
	"tags_src":                           "description.Tags",
	"title":                              "description.Table.TableName",
	"write_capacity":                     "description.Table.ProvisionedThroughput.WriteCapacityUnits",
}

func GetDynamoDbTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynamoDbTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynamoDbTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynamoDbTable =============================

// ==========================  START: DynamoDbGlobalSecondaryIndex =============================

type DynamoDbGlobalSecondaryIndex struct {
	Description   aws.DynamoDbGlobalSecondaryIndexDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type DynamoDbGlobalSecondaryIndexHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  DynamoDbGlobalSecondaryIndex `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type DynamoDbGlobalSecondaryIndexHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []DynamoDbGlobalSecondaryIndexHit `json:"hits"`
}

type DynamoDbGlobalSecondaryIndexSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  DynamoDbGlobalSecondaryIndexHits `json:"hits"`
}

type DynamoDbGlobalSecondaryIndexPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbGlobalSecondaryIndexPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbGlobalSecondaryIndexPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_globalsecondaryindex", filters, limit)
	if err != nil {
		return DynamoDbGlobalSecondaryIndexPaginator{}, err
	}

	p := DynamoDbGlobalSecondaryIndexPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbGlobalSecondaryIndexPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbGlobalSecondaryIndexPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynamoDbGlobalSecondaryIndexPaginator) NextPage(ctx context.Context) ([]DynamoDbGlobalSecondaryIndex, error) {
	var response DynamoDbGlobalSecondaryIndexSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbGlobalSecondaryIndex
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbGlobalSecondaryIndexFilters = map[string]string{
	"index_arn":     "description.GlobalSecondaryIndex.IndexArn",
	"index_name":    "description.GlobalSecondaryIndex.IndexName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.GlobalSecondaryIndex.IndexName",
}

func ListDynamoDbGlobalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbGlobalSecondaryIndex")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalSecondaryIndex NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalSecondaryIndex NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalSecondaryIndex GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalSecondaryIndex GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalSecondaryIndex GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynamoDbGlobalSecondaryIndexPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynamoDbGlobalSecondaryIndexFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalSecondaryIndex NewDynamoDbGlobalSecondaryIndexPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynamoDbGlobalSecondaryIndex paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynamoDbGlobalSecondaryIndexFilters = map[string]string{
	"index_arn":     "description.GlobalSecondaryIndex.IndexArn",
	"index_name":    "description.GlobalSecondaryIndex.IndexName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.GlobalSecondaryIndex.IndexName",
}

func GetDynamoDbGlobalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbGlobalSecondaryIndex")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynamoDbGlobalSecondaryIndexPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynamoDbGlobalSecondaryIndexFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynamoDbGlobalSecondaryIndex =============================

// ==========================  START: DynamoDbLocalSecondaryIndex =============================

type DynamoDbLocalSecondaryIndex struct {
	Description   aws.DynamoDbLocalSecondaryIndexDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type DynamoDbLocalSecondaryIndexHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  DynamoDbLocalSecondaryIndex `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type DynamoDbLocalSecondaryIndexHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []DynamoDbLocalSecondaryIndexHit `json:"hits"`
}

type DynamoDbLocalSecondaryIndexSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  DynamoDbLocalSecondaryIndexHits `json:"hits"`
}

type DynamoDbLocalSecondaryIndexPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbLocalSecondaryIndexPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbLocalSecondaryIndexPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_localsecondaryindex", filters, limit)
	if err != nil {
		return DynamoDbLocalSecondaryIndexPaginator{}, err
	}

	p := DynamoDbLocalSecondaryIndexPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbLocalSecondaryIndexPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbLocalSecondaryIndexPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynamoDbLocalSecondaryIndexPaginator) NextPage(ctx context.Context) ([]DynamoDbLocalSecondaryIndex, error) {
	var response DynamoDbLocalSecondaryIndexSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbLocalSecondaryIndex
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbLocalSecondaryIndexFilters = map[string]string{
	"index_arn":     "description.LocalSecondaryIndex.IndexArn",
	"index_name":    "description.LocalSecondaryIndex.IndexName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.LocalSecondaryIndex.IndexName",
}

func ListDynamoDbLocalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbLocalSecondaryIndex")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbLocalSecondaryIndex NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbLocalSecondaryIndex NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbLocalSecondaryIndex GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbLocalSecondaryIndex GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbLocalSecondaryIndex GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynamoDbLocalSecondaryIndexPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynamoDbLocalSecondaryIndexFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbLocalSecondaryIndex NewDynamoDbLocalSecondaryIndexPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynamoDbLocalSecondaryIndex paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynamoDbLocalSecondaryIndexFilters = map[string]string{
	"index_arn":     "description.LocalSecondaryIndex.IndexArn",
	"index_name":    "description.LocalSecondaryIndex.IndexName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.LocalSecondaryIndex.IndexName",
}

func GetDynamoDbLocalSecondaryIndex(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbLocalSecondaryIndex")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynamoDbLocalSecondaryIndexPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynamoDbLocalSecondaryIndexFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynamoDbLocalSecondaryIndex =============================

// ==========================  START: DynamoDbStream =============================

type DynamoDbStream struct {
	Description   aws.DynamoDbStreamDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type DynamoDbStreamHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  DynamoDbStream `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type DynamoDbStreamHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []DynamoDbStreamHit `json:"hits"`
}

type DynamoDbStreamSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  DynamoDbStreamHits `json:"hits"`
}

type DynamoDbStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbStreamPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodbstreams_stream", filters, limit)
	if err != nil {
		return DynamoDbStreamPaginator{}, err
	}

	p := DynamoDbStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbStreamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynamoDbStreamPaginator) NextPage(ctx context.Context) ([]DynamoDbStream, error) {
	var response DynamoDbStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbStreamFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"stream_arn":    "description.Stream.StreamArn",
	"stream_label":  "description.Stream.StreamLabel",
	"title":         "description.Stream.StreamLabel",
}

func ListDynamoDbStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbStream NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbStream NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynamoDbStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynamoDbStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbStream NewDynamoDbStreamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynamoDbStream paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynamoDbStreamFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"stream_arn":    "description.Stream.StreamArn",
	"stream_label":  "description.Stream.StreamLabel",
	"title":         "description.Stream.StreamLabel",
}

func GetDynamoDbStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynamoDbStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynamoDbStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynamoDbStream =============================

// ==========================  START: DynamoDbBackup =============================

type DynamoDbBackup struct {
	Description   aws.DynamoDbBackupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type DynamoDbBackupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  DynamoDbBackup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type DynamoDbBackupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []DynamoDbBackupHit `json:"hits"`
}

type DynamoDbBackupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  DynamoDbBackupHits `json:"hits"`
}

type DynamoDbBackupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbBackupPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbBackupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_backup", filters, limit)
	if err != nil {
		return DynamoDbBackupPaginator{}, err
	}

	p := DynamoDbBackupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbBackupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbBackupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynamoDbBackupPaginator) NextPage(ctx context.Context) ([]DynamoDbBackup, error) {
	var response DynamoDbBackupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbBackup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbBackupFilters = map[string]string{
	"arn":                      "description.Backup.BackupArn",
	"backup_creation_datetime": "description.Backup.BackupCreationDateTime",
	"backup_expiry_datetime":   "description.Backup.BackupExpiryDateTime",
	"backup_size_bytes":        "description.Backup.BackupSizeBytes",
	"backup_status":            "description.Backup.BackupStatus",
	"backup_type":              "description.Backup.BackupType",
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.Backup.BackupName",
	"table_arn":                "description.Backup.TableArn",
	"table_id":                 "description.Backup.TableId",
	"table_name":               "description.Backup.TableName",
	"title":                    "description.Backup.BackupName",
}

func ListDynamoDbBackup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbBackup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbBackup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbBackup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbBackup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbBackup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbBackup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynamoDbBackupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynamoDbBackupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbBackup NewDynamoDbBackupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynamoDbBackup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynamoDbBackupFilters = map[string]string{
	"arn":                      "description.Backup.BackupArn",
	"backup_creation_datetime": "description.Backup.BackupCreationDateTime",
	"backup_expiry_datetime":   "description.Backup.BackupExpiryDateTime",
	"backup_size_bytes":        "description.Backup.BackupSizeBytes",
	"backup_status":            "description.Backup.BackupStatus",
	"backup_type":              "description.Backup.BackupType",
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.Backup.BackupName",
	"table_arn":                "description.Backup.TableArn",
	"table_id":                 "description.Backup.TableId",
	"table_name":               "description.Backup.TableName",
	"title":                    "description.Backup.BackupName",
}

func GetDynamoDbBackup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbBackup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynamoDbBackupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynamoDbBackupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynamoDbBackup =============================

// ==========================  START: DynamoDbGlobalTable =============================

type DynamoDbGlobalTable struct {
	Description   aws.DynamoDbGlobalTableDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type DynamoDbGlobalTableHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DynamoDbGlobalTable `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DynamoDbGlobalTableHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DynamoDbGlobalTableHit `json:"hits"`
}

type DynamoDbGlobalTableSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DynamoDbGlobalTableHits `json:"hits"`
}

type DynamoDbGlobalTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbGlobalTablePaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbGlobalTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_globaltable", filters, limit)
	if err != nil {
		return DynamoDbGlobalTablePaginator{}, err
	}

	p := DynamoDbGlobalTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbGlobalTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbGlobalTablePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynamoDbGlobalTablePaginator) NextPage(ctx context.Context) ([]DynamoDbGlobalTable, error) {
	var response DynamoDbGlobalTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbGlobalTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbGlobalTableFilters = map[string]string{
	"creation_date_time":  "description.GlobalTable.CreationDateTime",
	"global_table_arn":    "description.GlobalTable.GlobalTableArn",
	"global_table_name":   "description.GlobalTable.GlobalTableName",
	"global_table_status": "description.GlobalTable.GlobalTableStatus",
	"og_account_id":       "metadata.SourceID",
	"replication_group":   "description.GlobalTable.ReplicationGroup",
	"title":               "description.GlobalTable.GlobalTableName",
}

func ListDynamoDbGlobalTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbGlobalTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalTable NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalTable NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynamoDbGlobalTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynamoDbGlobalTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbGlobalTable NewDynamoDbGlobalTablePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynamoDbGlobalTable paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynamoDbGlobalTableFilters = map[string]string{
	"creation_date_time":  "description.GlobalTable.CreationDateTime",
	"global_table_arn":    "description.GlobalTable.GlobalTableArn",
	"global_table_name":   "description.GlobalTable.GlobalTableName",
	"global_table_status": "description.GlobalTable.GlobalTableStatus",
	"og_account_id":       "metadata.SourceID",
	"replication_group":   "description.GlobalTable.ReplicationGroup",
	"title":               "description.GlobalTable.GlobalTableName",
}

func GetDynamoDbGlobalTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbGlobalTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynamoDbGlobalTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynamoDbGlobalTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynamoDbGlobalTable =============================

// ==========================  START: DynamoDbTableExport =============================

type DynamoDbTableExport struct {
	Description   aws.DynamoDbTableExportDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type DynamoDbTableExportHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DynamoDbTableExport `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DynamoDbTableExportHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DynamoDbTableExportHit `json:"hits"`
}

type DynamoDbTableExportSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DynamoDbTableExportHits `json:"hits"`
}

type DynamoDbTableExportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDynamoDbTableExportPaginator(filters []essdk.BoolFilter, limit *int64) (DynamoDbTableExportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dynamodb_tableexport", filters, limit)
	if err != nil {
		return DynamoDbTableExportPaginator{}, err
	}

	p := DynamoDbTableExportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DynamoDbTableExportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DynamoDbTableExportPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DynamoDbTableExportPaginator) NextPage(ctx context.Context) ([]DynamoDbTableExport, error) {
	var response DynamoDbTableExportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DynamoDbTableExport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDynamoDbTableExportFilters = map[string]string{
	"arn":               "description.Export.ExportArn",
	"billed_size_bytes": "description.Export.BilledSizeBytes",
	"client_token":      "description.Export.ClientToken",
	"end_time":          "description.Export.EndTime",
	"export_format":     "description.Export.ExportFormat",
	"export_manifest":   "description.Export.ExportManifest",
	"export_status":     "description.Export.ExportStatus",
	"export_time":       "description.Export.ExportTime",
	"failure_code":      "description.Export.FailureCode",
	"failure_message":   "description.Export.FailureMessage",
	"item_count":        "description.Export.ItemCount",
	"og_account_id":     "metadata.SourceID",
	"s3_bucket":         "description.Export.S3Bucket",
	"s3_bucket_owner":   "description.Export.S3BucketOwner",
	"s3_prefix":         "description.Export.S3Prefix",
	"s3_sse_algorithm":  "description.Export.S3SseAlgorithm",
	"s3_sse_kms_key_id": "description.Export.S3SseKmsKeyId",
	"start_time":        "description.Export.StartTime",
	"table_arn":         "description.Export.TableArn",
	"table_id":          "description.Export.TableId",
}

func ListDynamoDbTableExport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDynamoDbTableExport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTableExport NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTableExport NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTableExport GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTableExport GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTableExport GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDynamoDbTableExportPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDynamoDbTableExportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDynamoDbTableExport NewDynamoDbTableExportPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDynamoDbTableExport paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDynamoDbTableExportFilters = map[string]string{
	"arn":               "description.Export.ExportArn",
	"billed_size_bytes": "description.Export.BilledSizeBytes",
	"client_token":      "description.Export.ClientToken",
	"end_time":          "description.Export.EndTime",
	"export_format":     "description.Export.ExportFormat",
	"export_manifest":   "description.Export.ExportManifest",
	"export_status":     "description.Export.ExportStatus",
	"export_time":       "description.Export.ExportTime",
	"failure_code":      "description.Export.FailureCode",
	"failure_message":   "description.Export.FailureMessage",
	"item_count":        "description.Export.ItemCount",
	"og_account_id":     "metadata.SourceID",
	"s3_bucket":         "description.Export.S3Bucket",
	"s3_bucket_owner":   "description.Export.S3BucketOwner",
	"s3_prefix":         "description.Export.S3Prefix",
	"s3_sse_algorithm":  "description.Export.S3SseAlgorithm",
	"s3_sse_kms_key_id": "description.Export.S3SseKmsKeyId",
	"start_time":        "description.Export.StartTime",
	"table_arn":         "description.Export.TableArn",
	"table_id":          "description.Export.TableId",
}

func GetDynamoDbTableExport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDynamoDbTableExport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDynamoDbTableExportPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDynamoDbTableExportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DynamoDbTableExport =============================

// ==========================  START: OAMLink =============================

type OAMLink struct {
	Description   aws.OAMLinkDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type OAMLinkHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  OAMLink       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OAMLinkHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OAMLinkHit      `json:"hits"`
}

type OAMLinkSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  OAMLinkHits `json:"hits"`
}

type OAMLinkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOAMLinkPaginator(filters []essdk.BoolFilter, limit *int64) (OAMLinkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_oam_link", filters, limit)
	if err != nil {
		return OAMLinkPaginator{}, err
	}

	p := OAMLinkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OAMLinkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OAMLinkPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OAMLinkPaginator) NextPage(ctx context.Context) ([]OAMLink, error) {
	var response OAMLinkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OAMLink
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOAMLinkFilters = map[string]string{
	"arn":            "description.Link.Arn",
	"id":             "description.Link.Id",
	"og_account_id":  "metadata.SourceID",
	"label":          "description.Link.Label",
	"label_template": "description.Link.LabelTemplate",
	"resource_types": "description.Link.ResourceTypes",
	"sink_arn":       "description.Link.SinkArn",
	"tags":           "description.Link.Tags",
	"title":          "description.Link.Label",
}

func ListOAMLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOAMLink")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMLink NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMLink NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMLink GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMLink GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMLink GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOAMLinkPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOAMLinkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMLink NewOAMLinkPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOAMLink paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOAMLinkFilters = map[string]string{
	"arn":            "description.Link.Arn",
	"id":             "description.Link.Id",
	"og_account_id":  "metadata.SourceID",
	"label":          "description.Link.Label",
	"label_template": "description.Link.LabelTemplate",
	"resource_types": "description.Link.ResourceTypes",
	"sink_arn":       "description.Link.SinkArn",
	"tags":           "description.Link.Tags",
	"title":          "description.Link.Label",
}

func GetOAMLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOAMLink")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOAMLinkPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOAMLinkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OAMLink =============================

// ==========================  START: OAMSink =============================

type OAMSink struct {
	Description   aws.OAMSinkDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type OAMSinkHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  OAMSink       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type OAMSinkHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []OAMSinkHit      `json:"hits"`
}

type OAMSinkSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  OAMSinkHits `json:"hits"`
}

type OAMSinkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOAMSinkPaginator(filters []essdk.BoolFilter, limit *int64) (OAMSinkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_oam_sink", filters, limit)
	if err != nil {
		return OAMSinkPaginator{}, err
	}

	p := OAMSinkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OAMSinkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OAMSinkPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OAMSinkPaginator) NextPage(ctx context.Context) ([]OAMSink, error) {
	var response OAMSinkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OAMSink
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOAMSinkFilters = map[string]string{
	"arn":           "description.Sink.Arn",
	"id":            "description.Sink.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Sink.Name",
	"tags":          "description.Tags",
	"title":         "description.Sink.Name",
}

func ListOAMSink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOAMSink")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMSink NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMSink NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMSink GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMSink GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMSink GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOAMSinkPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOAMSinkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOAMSink NewOAMSinkPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOAMSink paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOAMSinkFilters = map[string]string{
	"arn":           "description.Sink.Arn",
	"id":            "description.Sink.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Sink.Name",
	"tags":          "description.Tags",
	"title":         "description.Sink.Name",
}

func GetOAMSink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOAMSink")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOAMSinkPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOAMSinkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OAMSink =============================

// ==========================  START: EC2VolumeSnapshot =============================

type EC2VolumeSnapshot struct {
	Description   aws.EC2VolumeSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2VolumeSnapshotHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2VolumeSnapshot `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2VolumeSnapshotHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2VolumeSnapshotHit `json:"hits"`
}

type EC2VolumeSnapshotSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2VolumeSnapshotHits `json:"hits"`
}

type EC2VolumeSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VolumeSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VolumeSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_volumesnapshot", filters, limit)
	if err != nil {
		return EC2VolumeSnapshotPaginator{}, err
	}

	p := EC2VolumeSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VolumeSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VolumeSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VolumeSnapshotPaginator) NextPage(ctx context.Context) ([]EC2VolumeSnapshot, error) {
	var response EC2VolumeSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VolumeSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VolumeSnapshotFilters = map[string]string{
	"arn":                       "arn",
	"create_volume_permissions": "description.CreateVolumePermissions",
	"data_encryption_key_id":    "description.Snapshot.DataEncryptionKeyId",
	"description":               "description.Snapshot.Description",
	"encrypted":                 "description.Snapshot.Encrypted",
	"og_account_id":             "metadata.SourceID",
	"kms_key_id":                "description.Snapshot.KmsKeyId",
	"owner_alias":               "description.Snapshot.OwnerAlias",
	"owner_id":                  "description.Snapshot.OwnerId",
	"progress":                  "description.Snapshot.Progress",
	"snapshot_id":               "description.Snapshot.SnapshotId",
	"start_time":                "description.Snapshot.StartTime",
	"state":                     "description.Snapshot.State",
	"state_message":             "description.Snapshot.StateMessage",
	"tags_src":                  "description.Snapshot.Tags",
	"title":                     "description.Snapshot.SnapshotId",
	"volume_id":                 "description.Snapshot.VolumeId",
	"volume_size":               "description.Snapshot.VolumeSize",
}

func ListEC2VolumeSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VolumeSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VolumeSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VolumeSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VolumeSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VolumeSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VolumeSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VolumeSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VolumeSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VolumeSnapshot NewEC2VolumeSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VolumeSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VolumeSnapshotFilters = map[string]string{
	"arn":                       "arn",
	"create_volume_permissions": "description.CreateVolumePermissions",
	"data_encryption_key_id":    "description.Snapshot.DataEncryptionKeyId",
	"description":               "description.Snapshot.Description",
	"encrypted":                 "description.Snapshot.Encrypted",
	"og_account_id":             "metadata.SourceID",
	"kms_key_id":                "description.Snapshot.KmsKeyId",
	"owner_alias":               "description.Snapshot.OwnerAlias",
	"owner_id":                  "description.Snapshot.OwnerId",
	"progress":                  "description.Snapshot.Progress",
	"snapshot_id":               "description.Snapshot.SnapshotId",
	"start_time":                "description.Snapshot.StartTime",
	"state":                     "description.Snapshot.State",
	"state_message":             "description.Snapshot.StateMessage",
	"tags_src":                  "description.Snapshot.Tags",
	"title":                     "description.Snapshot.SnapshotId",
	"volume_id":                 "description.Snapshot.VolumeId",
	"volume_size":               "description.Snapshot.VolumeSize",
}

func GetEC2VolumeSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VolumeSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VolumeSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VolumeSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VolumeSnapshot =============================

// ==========================  START: EC2ElasticIP =============================

type EC2ElasticIP struct {
	Description   aws.EC2ElasticIPDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type EC2ElasticIPHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2ElasticIP  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2ElasticIPHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2ElasticIPHit `json:"hits"`
}

type EC2ElasticIPSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  EC2ElasticIPHits `json:"hits"`
}

type EC2ElasticIPPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2ElasticIPPaginator(filters []essdk.BoolFilter, limit *int64) (EC2ElasticIPPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_elasticip", filters, limit)
	if err != nil {
		return EC2ElasticIPPaginator{}, err
	}

	p := EC2ElasticIPPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2ElasticIPPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2ElasticIPPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2ElasticIPPaginator) NextPage(ctx context.Context) ([]EC2ElasticIP, error) {
	var response EC2ElasticIPSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2ElasticIP
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2ElasticIPFilters = map[string]string{
	"id":            "description.Address.AllocationId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Address.AllocationId",
}

func ListEC2ElasticIP(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2ElasticIP")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ElasticIP NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ElasticIP NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ElasticIP GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ElasticIP GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ElasticIP GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2ElasticIPPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2ElasticIPFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ElasticIP NewEC2ElasticIPPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2ElasticIP paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2ElasticIPFilters = map[string]string{
	"id":            "description.Address.AllocationId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Address.AllocationId",
}

func GetEC2ElasticIP(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2ElasticIP")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2ElasticIPPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2ElasticIPFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2ElasticIP =============================

// ==========================  START: EC2CustomerGateway =============================

type EC2CustomerGateway struct {
	Description   aws.EC2CustomerGatewayDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type EC2CustomerGatewayHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  EC2CustomerGateway `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type EC2CustomerGatewayHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []EC2CustomerGatewayHit `json:"hits"`
}

type EC2CustomerGatewaySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  EC2CustomerGatewayHits `json:"hits"`
}

type EC2CustomerGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2CustomerGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2CustomerGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_customergateway", filters, limit)
	if err != nil {
		return EC2CustomerGatewayPaginator{}, err
	}

	p := EC2CustomerGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2CustomerGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2CustomerGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2CustomerGatewayPaginator) NextPage(ctx context.Context) ([]EC2CustomerGateway, error) {
	var response EC2CustomerGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2CustomerGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2CustomerGatewayFilters = map[string]string{
	"akas":                "description.CustomerGateway.Tags",
	"bgp_asn":             "description.CustomerGateway.BgpAsn",
	"certificate_arn":     "description.CustomerGateway.CertificateArn",
	"customer_gateway_id": "description.CustomerGateway.CustomerGatewayId",
	"device_name":         "description.CustomerGateway.DeviceName",
	"ip_address":          "description.CustomerGateway.IpAddress",
	"og_account_id":       "metadata.SourceID",
	"state":               "description.CustomerGateway.State",
	"tags_src":            "description.CustomerGateway.Tags",
	"type":                "description.CustomerGateway.Type",
}

func ListEC2CustomerGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2CustomerGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CustomerGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CustomerGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CustomerGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CustomerGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CustomerGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2CustomerGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2CustomerGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CustomerGateway NewEC2CustomerGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2CustomerGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2CustomerGatewayFilters = map[string]string{
	"akas":                "description.CustomerGateway.Tags",
	"bgp_asn":             "description.CustomerGateway.BgpAsn",
	"certificate_arn":     "description.CustomerGateway.CertificateArn",
	"customer_gateway_id": "description.CustomerGateway.CustomerGatewayId",
	"device_name":         "description.CustomerGateway.DeviceName",
	"ip_address":          "description.CustomerGateway.IpAddress",
	"og_account_id":       "metadata.SourceID",
	"state":               "description.CustomerGateway.State",
	"tags_src":            "description.CustomerGateway.Tags",
	"type":                "description.CustomerGateway.Type",
}

func GetEC2CustomerGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2CustomerGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2CustomerGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2CustomerGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2CustomerGateway =============================

// ==========================  START: EC2VerifiedAccessInstance =============================

type EC2VerifiedAccessInstance struct {
	Description   aws.EC2VerifiedAccessInstanceDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type EC2VerifiedAccessInstanceHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  EC2VerifiedAccessInstance `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type EC2VerifiedAccessInstanceHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []EC2VerifiedAccessInstanceHit `json:"hits"`
}

type EC2VerifiedAccessInstanceSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  EC2VerifiedAccessInstanceHits `json:"hits"`
}

type EC2VerifiedAccessInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessInstancePaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccessinstance", filters, limit)
	if err != nil {
		return EC2VerifiedAccessInstancePaginator{}, err
	}

	p := EC2VerifiedAccessInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VerifiedAccessInstancePaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessInstance, error) {
	var response EC2VerifiedAccessInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessInstanceFilters = map[string]string{
	"creation_time":                   "description.VerifiedAccountInstance.CreationTime",
	"description":                     "description.VerifiedAccountInstance.Description",
	"og_account_id":                   "metadata.SourceID",
	"last_updated_time":               "description.VerifiedAccountInstance.LastUpdatedTime",
	"tags_src":                        "description.VerifiedAccountInstance.Tags",
	"verified_access_instance_id":     "description.VerifiedAccountInstance.VerifiedAccessInstanceId",
	"verified_access_trust_providers": "description.VerifiedAccountInstance.VerifiedAccessTrustProviders",
}

func ListEC2VerifiedAccessInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VerifiedAccessInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VerifiedAccessInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessInstance NewEC2VerifiedAccessInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VerifiedAccessInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VerifiedAccessInstanceFilters = map[string]string{
	"creation_time":                   "description.VerifiedAccountInstance.CreationTime",
	"description":                     "description.VerifiedAccountInstance.Description",
	"og_account_id":                   "metadata.SourceID",
	"last_updated_time":               "description.VerifiedAccountInstance.LastUpdatedTime",
	"tags_src":                        "description.VerifiedAccountInstance.Tags",
	"verified_access_instance_id":     "description.VerifiedAccountInstance.VerifiedAccessInstanceId",
	"verified_access_trust_providers": "description.VerifiedAccountInstance.VerifiedAccessTrustProviders",
}

func GetEC2VerifiedAccessInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VerifiedAccessInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessInstance =============================

// ==========================  START: EC2VerifiedAccessEndpoint =============================

type EC2VerifiedAccessEndpoint struct {
	Description   aws.EC2VerifiedAccessEndpointDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type EC2VerifiedAccessEndpointHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  EC2VerifiedAccessEndpoint `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type EC2VerifiedAccessEndpointHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []EC2VerifiedAccessEndpointHit `json:"hits"`
}

type EC2VerifiedAccessEndpointSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  EC2VerifiedAccessEndpointHits `json:"hits"`
}

type EC2VerifiedAccessEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccessendpoint", filters, limit)
	if err != nil {
		return EC2VerifiedAccessEndpointPaginator{}, err
	}

	p := EC2VerifiedAccessEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VerifiedAccessEndpointPaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessEndpoint, error) {
	var response EC2VerifiedAccessEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessEndpointFilters = map[string]string{
	"application_domain":          "description.VerifiedAccountEndpoint.ApplicationDomain",
	"attachment_type":             "description.VerifiedAccountEndpoint.AttachmentType",
	"creation_time":               "description.VerifiedAccountEndpoint.CreationTime",
	"deletion_time":               "description.VerifiedAccountEndpoint.DeletionTime",
	"description":                 "description.VerifiedAccountEndpoint.Description",
	"device_validation_domain":    "description.VerifiedAccountEndpoint.DeviceValidationDomain",
	"domain_certificate_arn":      "description.VerifiedAccountEndpoint.DomainCertificateArn",
	"endpoint_domain":             "description.VerifiedAccountEndpoint.EndpointDomain",
	"endpoint_type":               "description.VerifiedAccountEndpoint.EndpointType",
	"og_account_id":               "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountEndpoint.LastUpdatedTime",
	"load_balancer_options":       "description.VerifiedAccountEndpoint.LoadBalancerOptions",
	"network_interface_options":   "description.VerifiedAccountEndpoint.NetworkInterfaceOptions",
	"status":                      "description.VerifiedAccountEndpoint.Status",
	"status_code":                 "description.VerifiedAccountEndpoint.Status.Code",
	"tags_src":                    "description.VerifiedAccountEndpoint.Tags",
	"verified_access_endpoint_id": "description.VerifiedAccountEndpoint.VerifiedAccessEndpointId",
	"verified_access_group_id":    "description.VerifiedAccountEndpoint.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountEndpoint.VerifiedAccessInstanceId",
}

func ListEC2VerifiedAccessEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VerifiedAccessEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VerifiedAccessEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessEndpoint NewEC2VerifiedAccessEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VerifiedAccessEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VerifiedAccessEndpointFilters = map[string]string{
	"application_domain":          "description.VerifiedAccountEndpoint.ApplicationDomain",
	"attachment_type":             "description.VerifiedAccountEndpoint.AttachmentType",
	"creation_time":               "description.VerifiedAccountEndpoint.CreationTime",
	"deletion_time":               "description.VerifiedAccountEndpoint.DeletionTime",
	"description":                 "description.VerifiedAccountEndpoint.Description",
	"device_validation_domain":    "description.VerifiedAccountEndpoint.DeviceValidationDomain",
	"domain_certificate_arn":      "description.VerifiedAccountEndpoint.DomainCertificateArn",
	"endpoint_domain":             "description.VerifiedAccountEndpoint.EndpointDomain",
	"endpoint_type":               "description.VerifiedAccountEndpoint.EndpointType",
	"og_account_id":               "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountEndpoint.LastUpdatedTime",
	"load_balancer_options":       "description.VerifiedAccountEndpoint.LoadBalancerOptions",
	"network_interface_options":   "description.VerifiedAccountEndpoint.NetworkInterfaceOptions",
	"status":                      "description.VerifiedAccountEndpoint.Status",
	"status_code":                 "description.VerifiedAccountEndpoint.Status.Code",
	"tags_src":                    "description.VerifiedAccountEndpoint.Tags",
	"verified_access_endpoint_id": "description.VerifiedAccountEndpoint.VerifiedAccessEndpointId",
	"verified_access_group_id":    "description.VerifiedAccountEndpoint.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountEndpoint.VerifiedAccessInstanceId",
}

func GetEC2VerifiedAccessEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VerifiedAccessEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessEndpoint =============================

// ==========================  START: EC2VerifiedAccessGroup =============================

type EC2VerifiedAccessGroup struct {
	Description   aws.EC2VerifiedAccessGroupDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type EC2VerifiedAccessGroupHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  EC2VerifiedAccessGroup `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type EC2VerifiedAccessGroupHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []EC2VerifiedAccessGroupHit `json:"hits"`
}

type EC2VerifiedAccessGroupSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  EC2VerifiedAccessGroupHits `json:"hits"`
}

type EC2VerifiedAccessGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccessgroup", filters, limit)
	if err != nil {
		return EC2VerifiedAccessGroupPaginator{}, err
	}

	p := EC2VerifiedAccessGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VerifiedAccessGroupPaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessGroup, error) {
	var response EC2VerifiedAccessGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessGroupFilters = map[string]string{
	"arn":                         "description.VerifiedAccountGroup.VerifiedAccessGroupArn",
	"creation_time":               "description.VerifiedAccountGroup.CreationTime",
	"deletion_time":               "description.VerifiedAccountGroup.DeletionTime",
	"description":                 "description.VerifiedAccountGroup.Description",
	"og_account_id":               "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountGroup.LastUpdatedTime",
	"owner":                       "description.VerifiedAccountGroup.Owner",
	"tags_src":                    "description.VerifiedAccountGroup.Tags",
	"verified_access_group_id":    "description.VerifiedAccountGroup.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountGroup.VerifiedAccessInstanceId",
}

func ListEC2VerifiedAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VerifiedAccessGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VerifiedAccessGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessGroup NewEC2VerifiedAccessGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VerifiedAccessGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VerifiedAccessGroupFilters = map[string]string{
	"arn":                         "description.VerifiedAccountGroup.VerifiedAccessGroupArn",
	"creation_time":               "description.VerifiedAccountGroup.CreationTime",
	"deletion_time":               "description.VerifiedAccountGroup.DeletionTime",
	"description":                 "description.VerifiedAccountGroup.Description",
	"og_account_id":               "metadata.SourceID",
	"last_updated_time":           "description.VerifiedAccountGroup.LastUpdatedTime",
	"owner":                       "description.VerifiedAccountGroup.Owner",
	"tags_src":                    "description.VerifiedAccountGroup.Tags",
	"verified_access_group_id":    "description.VerifiedAccountEndpoint.VerifiedAccessGroupId",
	"verified_access_instance_id": "description.VerifiedAccountGroup.VerifiedAccessInstanceId",
}

func GetEC2VerifiedAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VerifiedAccessGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessGroup =============================

// ==========================  START: EC2VerifiedAccessTrustProvider =============================

type EC2VerifiedAccessTrustProvider struct {
	Description   aws.EC2VerifiedAccessTrustProviderDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type EC2VerifiedAccessTrustProviderHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  EC2VerifiedAccessTrustProvider `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type EC2VerifiedAccessTrustProviderHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []EC2VerifiedAccessTrustProviderHit `json:"hits"`
}

type EC2VerifiedAccessTrustProviderSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  EC2VerifiedAccessTrustProviderHits `json:"hits"`
}

type EC2VerifiedAccessTrustProviderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VerifiedAccessTrustProviderPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VerifiedAccessTrustProviderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_verifiedaccesstrustprovider", filters, limit)
	if err != nil {
		return EC2VerifiedAccessTrustProviderPaginator{}, err
	}

	p := EC2VerifiedAccessTrustProviderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VerifiedAccessTrustProviderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VerifiedAccessTrustProviderPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VerifiedAccessTrustProviderPaginator) NextPage(ctx context.Context) ([]EC2VerifiedAccessTrustProvider, error) {
	var response EC2VerifiedAccessTrustProviderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VerifiedAccessTrustProvider
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VerifiedAccessTrustProviderFilters = map[string]string{
	"creation_time":                     "description.VerifiedAccountGroup.CreationTime",
	"description":                       "description.VerifiedAccountGroup.Description",
	"device_trust_provider_type":        "description.VerifiedAccountGroup.DeviceTrustProviderType",
	"og_account_id":                     "metadata.SourceID",
	"last_updated_time":                 "description.VerifiedAccountGroup.LastUpdatedTime",
	"oidc_options":                      "description.VerifiedAccountGroup.OidcOptions",
	"policy_reference_name":             "description.VerifiedAccountGroup.PolicyReferenceName",
	"tags_src":                          "description.VerifiedAccountGroup.Tags",
	"trust_provider_type":               "description.VerifiedAccountGroup.TrustProviderType",
	"user_trust_provider_type":          "description.VerifiedAccountGroup.UserTrustProviderType",
	"verified_access_trust_provider_id": "description.VerifiedAccessTrustProvider.VerifiedAccessTrustProviderId",
}

func ListEC2VerifiedAccessTrustProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VerifiedAccessTrustProvider")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessTrustProvider NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessTrustProvider NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessTrustProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessTrustProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessTrustProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VerifiedAccessTrustProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VerifiedAccessTrustProviderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VerifiedAccessTrustProvider NewEC2VerifiedAccessTrustProviderPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VerifiedAccessTrustProvider paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VerifiedAccessTrustProviderFilters = map[string]string{
	"creation_time":                     "description.VerifiedAccountGroup.CreationTime",
	"description":                       "description.VerifiedAccountGroup.Description",
	"device_trust_provider_type":        "description.VerifiedAccountGroup.DeviceTrustProviderType",
	"og_account_id":                     "metadata.SourceID",
	"last_updated_time":                 "description.VerifiedAccountGroup.LastUpdatedTime",
	"oidc_options":                      "description.VerifiedAccountGroup.OidcOptions",
	"policy_reference_name":             "description.VerifiedAccountGroup.PolicyReferenceName",
	"tags_src":                          "description.VerifiedAccountGroup.Tags",
	"trust_provider_type":               "description.VerifiedAccountGroup.TrustProviderType",
	"user_trust_provider_type":          "description.VerifiedAccountGroup.UserTrustProviderType",
	"verified_access_trust_provider_id": "description.VerifiedAccountGroup.VerifiedAccessTrustProviderId",
}

func GetEC2VerifiedAccessTrustProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VerifiedAccessTrustProvider")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VerifiedAccessTrustProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VerifiedAccessTrustProviderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VerifiedAccessTrustProvider =============================

// ==========================  START: EC2VPNGateway =============================

type EC2VPNGateway struct {
	Description   aws.EC2VPNGatewayDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2VPNGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2VPNGateway `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2VPNGatewayHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2VPNGatewayHit `json:"hits"`
}

type EC2VPNGatewaySearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2VPNGatewayHits `json:"hits"`
}

type EC2VPNGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPNGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPNGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpngateway", filters, limit)
	if err != nil {
		return EC2VPNGatewayPaginator{}, err
	}

	p := EC2VPNGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPNGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPNGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VPNGatewayPaginator) NextPage(ctx context.Context) ([]EC2VPNGateway, error) {
	var response EC2VPNGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPNGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPNGatewayFilters = map[string]string{
	"amazon_side_asn":   "description.VPNGateway.AmazonSideAsn",
	"availability_zone": "description.VPNGateway.AvailabilityZone",
	"og_account_id":     "metadata.SourceID",
	"state":             "description.VPNGateway.State",
	"tags_src":          "description.VPNGateway.Tags",
	"type":              "description.VPNGateway.Type",
	"vpc_attachments":   "description.VPNGateway.VpcAttachments",
	"vpn_gateway_id":    "description.VPNGateway.VpnGatewayId",
}

func ListEC2VPNGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPNGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VPNGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VPNGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNGateway NewEC2VPNGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VPNGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VPNGatewayFilters = map[string]string{
	"amazon_side_asn":   "description.VPNGateway.AmazonSideAsn",
	"availability_zone": "description.VPNGateway.AvailabilityZone",
	"og_account_id":     "metadata.SourceID",
	"state":             "description.VPNGateway.State",
	"tags_src":          "description.VPNGateway.Tags",
	"type":              "description.VPNGateway.Type",
	"vpc_attachments":   "description.VPNGateway.VpcAttachments",
	"vpn_gateway_id":    "description.VPNGateway.VpnGatewayId",
}

func GetEC2VPNGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPNGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VPNGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VPNGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VPNGateway =============================

// ==========================  START: EC2Volume =============================

type EC2Volume struct {
	Description   aws.EC2VolumeDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type EC2VolumeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Volume     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2VolumeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2VolumeHit    `json:"hits"`
}

type EC2VolumeSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  EC2VolumeHits `json:"hits"`
}

type EC2VolumePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VolumePaginator(filters []essdk.BoolFilter, limit *int64) (EC2VolumePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_volume", filters, limit)
	if err != nil {
		return EC2VolumePaginator{}, err
	}

	p := EC2VolumePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VolumePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VolumePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VolumePaginator) NextPage(ctx context.Context) ([]EC2Volume, error) {
	var response EC2VolumeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Volume
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VolumeFilters = map[string]string{
	"arn":                  "arn",
	"attachments":          "description.Volume.Attachments",
	"auto_enable_io":       "description.Attributes.AutoEnableIO",
	"availability_zone":    "description.Volume.AvailabilityZone",
	"create_time":          "description.Volume.CreateTime",
	"encrypted":            "description.Volume.Encrypted",
	"fast_restored":        "description.Volume.FastRestored",
	"iops":                 "description.Volume.Iops",
	"og_account_id":        "metadata.SourceID",
	"kms_key_id":           "description.Volume.KmsKeyId",
	"multi_attach_enabled": "description.Volume.MultiAttachEnabled",
	"outpost_arn":          "description.Volume.OutpostArn",
	"product_codes":        "description.Attributes.ProductCodes",
	"size":                 "description.Volume.Size",
	"snapshot_id":          "description.Volume.SnapshotId",
	"state":                "description.Volume.State",
	"tags_src":             "description.Volume.Tags",
	"volume_id":            "description.Volume.VolumeId",
	"volume_type":          "description.Volume.VolumeType",
}

func ListEC2Volume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Volume")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Volume NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Volume NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Volume GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Volume GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Volume GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VolumeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Volume NewEC2VolumePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Volume paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VolumeFilters = map[string]string{
	"arn":                  "arn",
	"attachments":          "description.Volume.Attachments",
	"auto_enable_io":       "description.Attributes.AutoEnableIO",
	"availability_zone":    "description.Volume.AvailabilityZone",
	"create_time":          "description.Volume.CreateTime",
	"encrypted":            "description.Volume.Encrypted",
	"fast_restored":        "description.Volume.FastRestored",
	"iops":                 "description.Volume.Iops",
	"og_account_id":        "metadata.SourceID",
	"kms_key_id":           "description.Volume.KmsKeyId",
	"multi_attach_enabled": "description.Volume.MultiAttachEnabled",
	"outpost_arn":          "description.Volume.OutpostArn",
	"product_codes":        "description.Attributes.ProductCodes",
	"size":                 "description.Volume.Size",
	"snapshot_id":          "description.Volume.SnapshotId",
	"state":                "description.Volume.State",
	"tags_src":             "description.Volume.Tags",
	"volume_id":            "description.Volume.VolumeId",
	"volume_type":          "description.Volume.VolumeType",
}

func GetEC2Volume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Volume")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VolumeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Volume =============================

// ==========================  START: EC2ClientVpnEndpoint =============================

type EC2ClientVpnEndpoint struct {
	Description   aws.EC2ClientVpnEndpointDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type EC2ClientVpnEndpointHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  EC2ClientVpnEndpoint `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type EC2ClientVpnEndpointHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []EC2ClientVpnEndpointHit `json:"hits"`
}

type EC2ClientVpnEndpointSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  EC2ClientVpnEndpointHits `json:"hits"`
}

type EC2ClientVpnEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2ClientVpnEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (EC2ClientVpnEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_clientvpnendpoint", filters, limit)
	if err != nil {
		return EC2ClientVpnEndpointPaginator{}, err
	}

	p := EC2ClientVpnEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2ClientVpnEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2ClientVpnEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2ClientVpnEndpointPaginator) NextPage(ctx context.Context) ([]EC2ClientVpnEndpoint, error) {
	var response EC2ClientVpnEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2ClientVpnEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2ClientVpnEndpointFilters = map[string]string{
	"authentication_options":      "description.ClientVpnEndpoint.AuthenticationOptions",
	"client_cidr_block":           "description.ClientVpnEndpoint.ClientCidrBlock",
	"client_connect_options":      "description.ClientVpnEndpoint.ClientConnectOptions",
	"client_login_banner_options": "description.ClientVpnEndpoint.ClientLoginBannerOptions",
	"client_vpn_endpoint_id":      "description.ClientVpnEndpoint.ClientVpnEndpointId",
	"connection_log_options":      "description.ClientVpnEndpoint.ConnectionLogOptions",
	"creation_time":               "description.ClientVpnEndpoint.CreationTime",
	"deletion_time":               "description.ClientVpnEndpoint.DeletionTime",
	"description":                 "description.ClientVpnEndpoint.Description",
	"dns_name":                    "description.ClientVpnEndpoint.DnsName",
	"dns_servers":                 "description.ClientVpnEndpoint.DnsServers",
	"og_account_id":               "metadata.SourceID",
	"security_group_ids":          "description.ClientVpnEndpoint.SecurityGroupIds",
	"self_service_portal_url":     "description.ClientVpnEndpoint.SelfServicePortalUrl",
	"server_certificate_arn":      "description.ClientVpnEndpoint.ServerCertificateArn",
	"session_timeout_hours":       "description.ClientVpnEndpoint.SessionTimeoutHours",
	"split_tunnel":                "description.ClientVpnEndpoint.SplitTunnel",
	"status":                      "description.ClientVpnEndpoint.Status",
	"tags_src":                    "description.ClientVpnEndpoint.Tags",
	"transport_protocol":          "description.ClientVpnEndpoint.TransportProtocol",
	"vpc_id":                      "description.ClientVpnEndpoint.VpcId",
	"vpn_port":                    "description.ClientVpnEndpoint.VpnPort",
	"vpn_protocol":                "description.ClientVpnEndpoint.VpnProtocol",
}

func ListEC2ClientVpnEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2ClientVpnEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ClientVpnEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ClientVpnEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ClientVpnEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ClientVpnEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ClientVpnEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2ClientVpnEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2ClientVpnEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ClientVpnEndpoint NewEC2ClientVpnEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2ClientVpnEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2ClientVpnEndpointFilters = map[string]string{
	"authentication_options":      "description.ClientVpnEndpoint.AuthenticationOptions",
	"client_cidr_block":           "description.ClientVpnEndpoint.ClientCidrBlock",
	"client_connect_options":      "description.ClientVpnEndpoint.ClientConnectOptions",
	"client_login_banner_options": "description.ClientVpnEndpoint.ClientLoginBannerOptions",
	"client_vpn_endpoint_id":      "description.ClientVpnEndpoint.ClientVpnEndpointId",
	"connection_log_options":      "description.ClientVpnEndpoint.ConnectionLogOptions",
	"creation_time":               "description.ClientVpnEndpoint.CreationTime",
	"deletion_time":               "description.ClientVpnEndpoint.DeletionTime",
	"description":                 "description.ClientVpnEndpoint.Description",
	"dns_name":                    "description.ClientVpnEndpoint.DnsName",
	"dns_servers":                 "description.ClientVpnEndpoint.DnsServers",
	"og_account_id":               "metadata.SourceID",
	"security_group_ids":          "description.ClientVpnEndpoint.SecurityGroupIds",
	"self_service_portal_url":     "description.ClientVpnEndpoint.SelfServicePortalUrl",
	"server_certificate_arn":      "description.ClientVpnEndpoint.ServerCertificateArn",
	"session_timeout_hours":       "description.ClientVpnEndpoint.SessionTimeoutHours",
	"split_tunnel":                "description.ClientVpnEndpoint.SplitTunnel",
	"status":                      "description.ClientVpnEndpoint.Status",
	"tags_src":                    "description.ClientVpnEndpoint.Tags",
	"transport_protocol":          "description.ClientVpnEndpoint.TransportProtocol",
	"volume_id":                   "description.Volume.VolumeId",
	"vpc_id":                      "description.ClientVpnEndpoint.VpcId",
	"vpn_port":                    "description.ClientVpnEndpoint.VpnPort",
	"vpn_protocol":                "description.ClientVpnEndpoint.VpnProtocol",
}

func GetEC2ClientVpnEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2ClientVpnEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2ClientVpnEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2ClientVpnEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2ClientVpnEndpoint =============================

// ==========================  START: EC2Instance =============================

type EC2Instance struct {
	Description   aws.EC2InstanceDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type EC2InstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Instance   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2InstanceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2InstanceHit  `json:"hits"`
}

type EC2InstanceSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  EC2InstanceHits `json:"hits"`
}

type EC2InstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InstancePaginator(filters []essdk.BoolFilter, limit *int64) (EC2InstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_instance", filters, limit)
	if err != nil {
		return EC2InstancePaginator{}, err
	}

	p := EC2InstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2InstancePaginator) NextPage(ctx context.Context) ([]EC2Instance, error) {
	var response EC2InstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Instance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InstanceFilters = map[string]string{
	"ami_launch_index":                           "description.Instance.AmiLaunchIndex",
	"architecture":                               "description.Instance.Architecture",
	"arn":                                        "arn",
	"block_device_mappings":                      "description.Instance.BlockDeviceMappings",
	"boot_mode":                                  "description.Instance.BootMode",
	"capacity_reservation_id":                    "description.Instance.CapacityReservationId",
	"capacity_reservation_specification":         "description.Instance.CapacityReservationSpecification",
	"client_token":                               "description.Instance.ClientToken",
	"cpu_options_core_count":                     "description.Instance.CpuOptions.CoreCount",
	"cpu_options_threads_per_core":               "description.Instance.CpuOptions.ThreadsPerCore",
	"disable_api_termination":                    "description.Attributes.DisableApiTermination",
	"ebs_optimized":                              "description.Instance.EbsOptimized",
	"elastic_gpu_associations":                   "description.Instance.ElasticGpuAssociations",
	"elastic_inference_accelerator_associations": "description.Instance.ElasticInferenceAcceleratorAssociations",
	"ena_support":                                "description.Instance.EnaSupport",
	"enclave_options":                            "description.Instance.EnclaveOptions",
	"hibernation_options":                        "description.Instance.HibernationOptions",
	"hypervisor":                                 "description.Instance.Hypervisor",
	"iam_instance_profile_arn":                   "description.Instance.IamInstanceProfile.Arn",
	"iam_instance_profile_id":                    "description.Instance.IamInstanceProfile.Id",
	"image_id":                                   "description.Instance.ImageId",
	"instance_id":                                "description.Instance.InstanceId",
	"instance_initiated_shutdown_behavior":       "description.Attributes.InstanceInitiatedShutdownBehavior",
	"instance_lifecycle":                         "description.Instance.InstanceLifecycle",
	"instance_state":                             "description.Instance.State.Name",
	"instance_status":                            "description.Attributes.InstanceStatus",
	"instance_type":                              "description.Instance.InstanceType",
	"og_account_id":                              "metadata.SourceID",
	"kernel_id":                                  "description.Instance.KernelId",
	"key_name":                                   "description.Instance.KeyName",
	"launch_template_data":                       "description.LaunchTemplateData",
	"launch_time":                                "description.Instance.LaunchTime",
	"licenses":                                   "description.Instance.Licenses",
	"maintenance_options":                        "description.Instance.MaintenanceOptions",
	"metadata_options":                           "description.Instance.MetadataOptions",
	"monitoring_state":                           "description.Instance.Monitoring.State",
	"network_interfaces":                         "description.Instance.NetworkInterfaces",
	"outpost_arn":                                "description.Instance.OutpostArn",
	"placement_affinity":                         "description.Instance.Placement.Affinity",
	"placement_availability_zone":                "description.Instance.Placement.AvailabilityZone",
	"placement_group_id":                         "description.Instance.Placement.GroupId",
	"placement_group_name":                       "description.Instance.Placement.GroupName",
	"placement_host_id":                          "description.Instance.Placement.HostId",
	"placement_host_resource_group_arn":          "description.Instance.Placement.HostResourceGroupArn",
	"placement_partition_number":                 "description.Instance.Placement.PartitionNumber",
	"placement_tenancy":                          "description.Instance.Placement.Tenancy",
	"platform":                                   "description.Instance.Platform",
	"platform_details":                           "description.Instance.PlatformDetails",
	"private_dns_name":                           "description.Instance.PrivateDnsName",
	"private_dns_name_options":                   "description.Instance.PrivateDnsNameOptions",
	"private_ip_address":                         "description.Instance.PrivateIpAddress",
	"product_codes":                              "description.Instance.ProductCodes",
	"public_dns_name":                            "description.Instance.PublicDnsName",
	"public_ip_address":                          "description.Instance.PublicIpAddress",
	"ram_disk_id":                                "description.Instance.RamdiskId",
	"root_device_name":                           "description.Instance.RootDeviceName",
	"root_device_type":                           "description.Instance.RootDeviceType",
	"security_groups":                            "description.Instance.SecurityGroups",
	"source_dest_check":                          "description.Instance.SourceDestCheck",
	"spot_instance_request_id":                   "description.Instance.SpotInstanceRequestId",
	"sriov_net_support":                          "description.Instance.SriovNetSupport",
	"state_code":                                 "description.Instance.State.Code",
	"state_transition_reason":                    "description.Instance.StateTransitionReason",
	"subnet_id":                                  "description.Instance.SubnetId",
	"tags_src":                                   "description.Instance.Tags",
	"tpm_support":                                "description.Instance.TpmSupport",
	"usage_operation":                            "description.Instance.UsageOperation",
	"usage_operation_update_time":                "description.Instance.UsageOperationUpdateTime",
	"virtualization_type":                        "description.Instance.VirtualizationType",
	"vpc_id":                                     "description.Instance.VpcId",
}

func ListEC2Instance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Instance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Instance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Instance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Instance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Instance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Instance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2InstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2InstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Instance NewEC2InstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Instance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2InstanceFilters = map[string]string{
	"ami_launch_index":                           "description.Instance.AmiLaunchIndex",
	"architecture":                               "description.Instance.Architecture",
	"arn":                                        "arn",
	"block_device_mappings":                      "description.Instance.BlockDeviceMappings",
	"boot_mode":                                  "description.Instance.BootMode",
	"capacity_reservation_id":                    "description.Instance.CapacityReservationId",
	"capacity_reservation_specification":         "description.Instance.CapacityReservationSpecification",
	"client_token":                               "description.Instance.ClientToken",
	"cpu_options_core_count":                     "description.Instance.CpuOptions.CoreCount",
	"cpu_options_threads_per_core":               "description.Instance.CpuOptions.ThreadsPerCore",
	"disable_api_termination":                    "description.Attributes.DisableApiTermination",
	"ebs_optimized":                              "description.Instance.EbsOptimized",
	"elastic_gpu_associations":                   "description.Instance.ElasticGpuAssociations",
	"elastic_inference_accelerator_associations": "description.Instance.ElasticInferenceAcceleratorAssociations",
	"ena_support":                                "description.Instance.EnaSupport",
	"enclave_options":                            "description.Instance.EnclaveOptions",
	"hibernation_options":                        "description.Instance.HibernationOptions",
	"hypervisor":                                 "description.Instance.Hypervisor",
	"iam_instance_profile_arn":                   "description.Instance.IamInstanceProfile.Arn",
	"iam_instance_profile_id":                    "description.Instance.IamInstanceProfile.Id",
	"image_id":                                   "description.Instance.ImageId",
	"instance_id":                                "description.Instance.InstanceId",
	"instance_initiated_shutdown_behavior":       "description.Attributes.InstanceInitiatedShutdownBehavior",
	"instance_lifecycle":                         "description.Instance.InstanceLifecycle",
	"instance_state":                             "description.Instance.State.Name",
	"instance_status":                            "description.Attributes.InstanceStatus",
	"instance_type":                              "description.Instance.InstanceType",
	"og_account_id":                              "metadata.SourceID",
	"kernel_id":                                  "description.Instance.KernelId",
	"key_name":                                   "description.Instance.KeyName",
	"launch_template_data":                       "description.LaunchTemplateData",
	"launch_time":                                "description.Instance.LaunchTime",
	"licenses":                                   "description.Instance.Licenses",
	"maintenance_options":                        "description.Instance.MaintenanceOptions",
	"metadata_options":                           "description.Instance.MetadataOptions",
	"monitoring_state":                           "description.Instance.Monitoring.State",
	"network_interfaces":                         "description.Instance.NetworkInterfaces",
	"outpost_arn":                                "description.Instance.OutpostArn",
	"placement_affinity":                         "description.Instance.Placement.Affinity",
	"placement_availability_zone":                "description.Instance.Placement.AvailabilityZone",
	"placement_group_id":                         "description.Instance.Placement.GroupId",
	"placement_group_name":                       "description.Instance.Placement.GroupName",
	"placement_host_id":                          "description.Instance.Placement.HostId",
	"placement_host_resource_group_arn":          "description.Instance.Placement.HostResourceGroupArn",
	"placement_partition_number":                 "description.Instance.Placement.PartitionNumber",
	"placement_tenancy":                          "description.Instance.Placement.Tenancy",
	"platform":                                   "description.Instance.Platform",
	"platform_details":                           "description.Instance.PlatformDetails",
	"private_dns_name":                           "description.Instance.PrivateDnsName",
	"private_dns_name_options":                   "description.Instance.PrivateDnsNameOptions",
	"private_ip_address":                         "description.Instance.PrivateIpAddress",
	"product_codes":                              "description.Instance.ProductCodes",
	"public_dns_name":                            "description.Instance.PublicDnsName",
	"public_ip_address":                          "description.Instance.PublicIpAddress",
	"ram_disk_id":                                "description.Instance.RamdiskId",
	"root_device_name":                           "description.Instance.RootDeviceName",
	"root_device_type":                           "description.Instance.RootDeviceType",
	"security_groups":                            "description.Instance.SecurityGroups",
	"source_dest_check":                          "description.Instance.SourceDestCheck",
	"spot_instance_request_id":                   "description.Instance.SpotInstanceRequestId",
	"sriov_net_support":                          "description.Instance.SriovNetSupport",
	"state_code":                                 "description.Instance.State.Code",
	"state_transition_reason":                    "description.Instance.StateTransitionReason",
	"subnet_id":                                  "description.Instance.SubnetId",
	"tags_src":                                   "description.Instance.Tags",
	"tpm_support":                                "description.Instance.TpmSupport",
	"usage_operation":                            "description.Instance.UsageOperation",
	"usage_operation_update_time":                "description.Instance.UsageOperationUpdateTime",
	"virtualization_type":                        "description.Instance.VirtualizationType",
	"vpc_id":                                     "description.Instance.VpcId",
}

func GetEC2Instance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Instance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2InstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2InstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Instance =============================

// ==========================  START: EC2Vpc =============================

type EC2Vpc struct {
	Description   aws.EC2VpcDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type EC2VpcHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Vpc        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2VpcHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2VpcHit       `json:"hits"`
}

type EC2VpcSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  EC2VpcHits `json:"hits"`
}

type EC2VpcPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VpcPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VpcPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpc", filters, limit)
	if err != nil {
		return EC2VpcPaginator{}, err
	}

	p := EC2VpcPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VpcPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VpcPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VpcPaginator) NextPage(ctx context.Context) ([]EC2Vpc, error) {
	var response EC2VpcSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Vpc
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VpcFilters = map[string]string{
	"arn":                             "arn",
	"cidr_block":                      "description.Vpc.CidrBlock",
	"cidr_block_association_set":      "description.Vpc.CidrBlockAssociationSet",
	"dhcp_options_id":                 "description.Vpc.DhcpOptionsId",
	"instance_tenancy":                "description.Vpc.InstanceTenancy",
	"ipv6_cidr_block_association_set": "description.Vpc.Ipv6CidrBlockAssociationSet",
	"is_default":                      "description.Vpc.IsDefault",
	"og_account_id":                   "metadata.SourceID",
	"owner_id":                        "description.Vpc.OwnerId",
	"state":                           "description.Vpc.State",
	"tags_src":                        "description.Vpc.Tags",
	"vpc_id":                          "description.Vpc.VpcId",
}

func ListEC2Vpc(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Vpc")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Vpc NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Vpc NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Vpc GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Vpc GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Vpc GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VpcPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VpcFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Vpc NewEC2VpcPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Vpc paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VpcFilters = map[string]string{
	"arn":                             "arn",
	"cidr_block":                      "description.Vpc.CidrBlock",
	"cidr_block_association_set":      "description.Vpc.CidrBlockAssociationSet",
	"dhcp_options_id":                 "description.Vpc.DhcpOptionsId",
	"instance_tenancy":                "description.Vpc.InstanceTenancy",
	"ipv6_cidr_block_association_set": "description.Vpc.Ipv6CidrBlockAssociationSet",
	"is_default":                      "description.Vpc.IsDefault",
	"og_account_id":                   "metadata.SourceID",
	"owner_id":                        "description.Vpc.OwnerId",
	"state":                           "description.Vpc.State",
	"tags_src":                        "description.Vpc.Tags",
	"vpc_id":                          "description.Vpc.VpcId",
}

func GetEC2Vpc(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Vpc")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VpcPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VpcFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Vpc =============================

// ==========================  START: EC2NetworkInterface =============================

type EC2NetworkInterface struct {
	Description   aws.EC2NetworkInterfaceDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type EC2NetworkInterfaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  EC2NetworkInterface `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type EC2NetworkInterfaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []EC2NetworkInterfaceHit `json:"hits"`
}

type EC2NetworkInterfaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  EC2NetworkInterfaceHits `json:"hits"`
}

type EC2NetworkInterfacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2NetworkInterfacePaginator(filters []essdk.BoolFilter, limit *int64) (EC2NetworkInterfacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_networkinterface", filters, limit)
	if err != nil {
		return EC2NetworkInterfacePaginator{}, err
	}

	p := EC2NetworkInterfacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2NetworkInterfacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2NetworkInterfacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2NetworkInterfacePaginator) NextPage(ctx context.Context) ([]EC2NetworkInterface, error) {
	var response EC2NetworkInterfaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2NetworkInterface
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2NetworkInterfaceFilters = map[string]string{
	"association_allocation_id":      "description.NetworkInterface.Association.AllocationId",
	"association_carrier_ip":         "description.NetworkInterface.Association.CarrierIp",
	"association_customer_owned_ip":  "description.NetworkInterface.Association.CustomerOwnedIp",
	"association_id":                 "description.NetworkInterface.Association.AssociationId",
	"association_ip_owner_id":        "description.NetworkInterface.Association.IpOwnerId",
	"association_public_dns_name":    "description.NetworkInterface.Association.PublicDnsName",
	"association_public_ip":          "description.NetworkInterface.Association.PublicIp",
	"attached_instance_id":           "description.NetworkInterface.Attachment.InstanceId",
	"attached_instance_owner_id":     "description.NetworkInterface.Attachment.InstanceOwnerId",
	"attachment_id":                  "description.NetworkInterface.Attachment.AttachmentId",
	"attachment_status":              "description.NetworkInterface.Attachment.Status",
	"attachment_time":                "description.NetworkInterface.Attachment.AttachTime",
	"availability_zone":              "description.NetworkInterface.AvailabilityZone",
	"delete_on_instance_termination": "description.NetworkInterface.Attachment.DeleteOnTermination",
	"description":                    "description.NetworkInterface.Description",
	"device_index":                   "description.NetworkInterface.Attachment.DeviceIndex",
	"groups":                         "description.NetworkInterface.Groups",
	"interface_type":                 "description.NetworkInterface.InterfaceType",
	"ipv6_addresses":                 "description.NetworkInterface.Ipv6Addresses",
	"og_account_id":                  "metadata.SourceID",
	"mac_address":                    "description.NetworkInterface.MacAddress",
	"network_interface_id":           "description.NetworkInterface.NetworkInterfaceId",
	"outpost_arn":                    "description.NetworkInterface.OutpostArn",
	"owner_id":                       "description.NetworkInterface.OwnerId",
	"private_dns_name":               "description.NetworkInterface.PrivateDnsName",
	"private_ip_address":             "description.NetworkInterface.PrivateIpAddress",
	"private_ip_addresses":           "description.NetworkInterface.PrivateIpAddresses",
	"requester_id":                   "description.NetworkInterface.RequesterId",
	"requester_managed":              "description.NetworkInterface.RequesterManaged",
	"source_dest_check":              "description.NetworkInterface.SourceDestCheck",
	"status":                         "description.NetworkInterface.Status",
	"subnet_id":                      "description.NetworkInterface.SubnetId",
	"tags_src":                       "description.NetworkInterface.TagSet",
	"title":                          "description.NetworkInterface.NetworkInterfaceId",
	"vpc_id":                         "description.NetworkInterface.VpcId",
}

func ListEC2NetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2NetworkInterface")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkInterface NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkInterface NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2NetworkInterfacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2NetworkInterfaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkInterface NewEC2NetworkInterfacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2NetworkInterface paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2NetworkInterfaceFilters = map[string]string{
	"association_allocation_id":      "description.NetworkInterface.Association.AllocationId",
	"association_carrier_ip":         "description.NetworkInterface.Association.CarrierIp",
	"association_customer_owned_ip":  "description.NetworkInterface.Association.CustomerOwnedIp",
	"association_id":                 "description.NetworkInterface.Association.AssociationId",
	"association_ip_owner_id":        "description.NetworkInterface.Association.IpOwnerId",
	"association_public_dns_name":    "description.NetworkInterface.Association.PublicDnsName",
	"association_public_ip":          "description.NetworkInterface.Association.PublicIp",
	"attached_instance_id":           "description.NetworkInterface.Attachment.InstanceId",
	"attached_instance_owner_id":     "description.NetworkInterface.Attachment.InstanceOwnerId",
	"attachment_id":                  "description.NetworkInterface.Attachment.AttachmentId",
	"attachment_status":              "description.NetworkInterface.Attachment.Status",
	"attachment_time":                "description.NetworkInterface.Attachment.AttachTime",
	"availability_zone":              "description.NetworkInterface.AvailabilityZone",
	"delete_on_instance_termination": "description.NetworkInterface.Attachment.DeleteOnTermination",
	"description":                    "description.NetworkInterface.Description",
	"device_index":                   "description.NetworkInterface.Attachment.DeviceIndex",
	"groups":                         "description.NetworkInterface.Groups",
	"interface_type":                 "description.NetworkInterface.InterfaceType",
	"ipv6_addresses":                 "description.NetworkInterface.Ipv6Addresses",
	"og_account_id":                  "metadata.SourceID",
	"mac_address":                    "description.NetworkInterface.MacAddress",
	"network_interface_id":           "description.NetworkInterface.NetworkInterfaceId",
	"outpost_arn":                    "description.NetworkInterface.OutpostArn",
	"owner_id":                       "description.NetworkInterface.OwnerId",
	"private_dns_name":               "description.NetworkInterface.PrivateDnsName",
	"private_ip_address":             "description.NetworkInterface.PrivateIpAddress",
	"private_ip_addresses":           "description.NetworkInterface.PrivateIpAddresses",
	"requester_id":                   "description.NetworkInterface.RequesterId",
	"requester_managed":              "description.NetworkInterface.RequesterManaged",
	"source_dest_check":              "description.NetworkInterface.SourceDestCheck",
	"status":                         "description.NetworkInterface.Status",
	"subnet_id":                      "description.NetworkInterface.SubnetId",
	"tags_src":                       "description.NetworkInterface.TagSet",
	"title":                          "description.NetworkInterface.NetworkInterfaceId",
	"vpc_id":                         "description.NetworkInterface.VpcId",
}

func GetEC2NetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2NetworkInterface")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2NetworkInterfacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2NetworkInterfaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2NetworkInterface =============================

// ==========================  START: EC2RegionalSettings =============================

type EC2RegionalSettings struct {
	Description   aws.EC2RegionalSettingsDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type EC2RegionalSettingsHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  EC2RegionalSettings `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type EC2RegionalSettingsHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []EC2RegionalSettingsHit `json:"hits"`
}

type EC2RegionalSettingsSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  EC2RegionalSettingsHits `json:"hits"`
}

type EC2RegionalSettingsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2RegionalSettingsPaginator(filters []essdk.BoolFilter, limit *int64) (EC2RegionalSettingsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_regionalsettings", filters, limit)
	if err != nil {
		return EC2RegionalSettingsPaginator{}, err
	}

	p := EC2RegionalSettingsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2RegionalSettingsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2RegionalSettingsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2RegionalSettingsPaginator) NextPage(ctx context.Context) ([]EC2RegionalSettings, error) {
	var response EC2RegionalSettingsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2RegionalSettings
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2RegionalSettingsFilters = map[string]string{
	"default_ebs_encryption_enabled":     "description.EbsEncryptionByDefault",
	"default_ebs_encryption_key":         "description.KmsKeyId",
	"og_account_id":                      "metadata.SourceID",
	"snapshot_block_public_access_state": "description.SnapshotBlockPublicAccessState",
}

func ListEC2RegionalSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2RegionalSettings")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RegionalSettings NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RegionalSettings NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RegionalSettings GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RegionalSettings GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RegionalSettings GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2RegionalSettingsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2RegionalSettingsFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RegionalSettings NewEC2RegionalSettingsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2RegionalSettings paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2RegionalSettingsFilters = map[string]string{
	"default_ebs_encryption_enabled":     "description.EbsEncryptionByDefault",
	"default_ebs_encryption_key":         "description.KmsKeyId",
	"og_account_id":                      "metadata.SourceID",
	"snapshot_block_public_access_state": "description.SnapshotBlockPublicAccessState",
}

func GetEC2RegionalSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2RegionalSettings")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2RegionalSettingsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2RegionalSettingsFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2RegionalSettings =============================

// ==========================  START: EC2Subnet =============================

type EC2Subnet struct {
	Description   aws.EC2SubnetDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type EC2SubnetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Subnet     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2SubnetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2SubnetHit    `json:"hits"`
}

type EC2SubnetSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  EC2SubnetHits `json:"hits"`
}

type EC2SubnetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2SubnetPaginator(filters []essdk.BoolFilter, limit *int64) (EC2SubnetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_subnet", filters, limit)
	if err != nil {
		return EC2SubnetPaginator{}, err
	}

	p := EC2SubnetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2SubnetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2SubnetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2SubnetPaginator) NextPage(ctx context.Context) ([]EC2Subnet, error) {
	var response EC2SubnetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Subnet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2SubnetFilters = map[string]string{
	"assign_ipv6_address_on_creation": "description.Subnet.AssignIpv6AddressOnCreation",
	"availability_zone":               "description.Subnet.AvailabilityZone",
	"availability_zone_id":            "description.Subnet.AvailabilityZoneId",
	"available_ip_address_count":      "description.Subnet.AvailableIpAddressCount",
	"cidr_block":                      "description.Subnet.CidrBlock",
	"customer_owned_ipv4_pool":        "description.Subnet.CustomerOwnedIpv4Pool",
	"default_for_az":                  "description.Subnet.DefaultForAz",
	"ipv6_cidr_block_association_set": "description.Subnet.Ipv6CidrBlockAssociationSet",
	"og_account_id":                   "metadata.SourceID",
	"map_customer_owned_ip_on_launch": "description.Subnet.MapCustomerOwnedIpOnLaunch",
	"map_public_ip_on_launch":         "description.Subnet.MapPublicIpOnLaunch",
	"outpost_arn":                     "description.Subnet.OutpostArn",
	"owner_id":                        "description.Subnet.OwnerId",
	"state":                           "description.Subnet.State",
	"subnet_arn":                      "description.Subnet.SubnetArn",
	"subnet_id":                       "description.Subnet.SubnetId",
	"tags_src":                        "description.Subnet.Tags",
	"vpc_id":                          "description.Subnet.VpcId",
}

func ListEC2Subnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Subnet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Subnet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Subnet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Subnet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Subnet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Subnet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2SubnetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2SubnetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Subnet NewEC2SubnetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Subnet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2SubnetFilters = map[string]string{
	"assign_ipv6_address_on_creation": "description.Subnet.AssignIpv6AddressOnCreation",
	"availability_zone":               "description.Subnet.AvailabilityZone",
	"availability_zone_id":            "description.Subnet.AvailabilityZoneId",
	"available_ip_address_count":      "description.Subnet.AvailableIpAddressCount",
	"cidr_block":                      "description.Subnet.CidrBlock",
	"customer_owned_ipv4_pool":        "description.Subnet.CustomerOwnedIpv4Pool",
	"default_for_az":                  "description.Subnet.DefaultForAz",
	"ipv6_cidr_block_association_set": "description.Subnet.Ipv6CidrBlockAssociationSet",
	"og_account_id":                   "metadata.SourceID",
	"map_customer_owned_ip_on_launch": "description.Subnet.MapCustomerOwnedIpOnLaunch",
	"map_public_ip_on_launch":         "description.Subnet.MapPublicIpOnLaunch",
	"outpost_arn":                     "description.Subnet.OutpostArn",
	"owner_id":                        "description.Subnet.OwnerId",
	"state":                           "description.Subnet.State",
	"subnet_arn":                      "description.Subnet.SubnetArn",
	"subnet_id":                       "description.Subnet.SubnetId",
	"tags_src":                        "description.Subnet.Tags",
	"vpc_id":                          "description.Subnet.VpcId",
}

func GetEC2Subnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Subnet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2SubnetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2SubnetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Subnet =============================

// ==========================  START: EC2VPCEndpoint =============================

type EC2VPCEndpoint struct {
	Description   aws.EC2VPCEndpointDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EC2VPCEndpointHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EC2VPCEndpoint `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EC2VPCEndpointHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EC2VPCEndpointHit `json:"hits"`
}

type EC2VPCEndpointSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EC2VPCEndpointHits `json:"hits"`
}

type EC2VPCEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPCEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPCEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpcendpoint", filters, limit)
	if err != nil {
		return EC2VPCEndpointPaginator{}, err
	}

	p := EC2VPCEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPCEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPCEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VPCEndpointPaginator) NextPage(ctx context.Context) ([]EC2VPCEndpoint, error) {
	var response EC2VPCEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPCEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPCEndpointFilters = map[string]string{
	"creation_timestamp":    "description.VpcEndpoint.CreationTimestamp",
	"dns_entries":           "description.VpcEndpoint.DnsEntries",
	"groups":                "description.VpcEndpoint.Groups",
	"og_account_id":         "metadata.SourceID",
	"network_interface_ids": "description.VpcEndpoint.NetworkInterfaceIds",
	"owner_id":              "description.VpcEndpoint.OwnerId",
	"private_dns_enabled":   "description.VpcEndpoint.PrivateDnsEnabled",
	"requester_managed":     "description.VpcEndpoint.RequesterManaged",
	"route_table_ids":       "description.VpcEndpoint.RouteTableIds",
	"service_name":          "description.VpcEndpoint.ServiceName",
	"state":                 "description.VpcEndpoint.State",
	"subnet_ids":            "description.VpcEndpoint.SubnetIds",
	"tags_src":              "description.VpcEndpoint.Tags",
	"vpc_endpoint_id":       "description.VpcEndpoint.VpcEndpointId",
	"vpc_endpoint_type":     "description.VpcEndpoint.VpcEndpointType",
	"vpc_id":                "description.VpcEndpoint.VpcId",
}

func ListEC2VPCEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPCEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VPCEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VPCEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpoint NewEC2VPCEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VPCEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VPCEndpointFilters = map[string]string{
	"creation_timestamp":    "description.VpcEndpoint.CreationTimestamp",
	"dns_entries":           "description.VpcEndpoint.DnsEntries",
	"groups":                "description.VpcEndpoint.Groups",
	"og_account_id":         "metadata.SourceID",
	"network_interface_ids": "description.VpcEndpoint.NetworkInterfaceIds",
	"owner_id":              "description.VpcEndpoint.OwnerId",
	"private_dns_enabled":   "description.VpcEndpoint.PrivateDnsEnabled",
	"requester_managed":     "description.VpcEndpoint.RequesterManaged",
	"route_table_ids":       "description.VpcEndpoint.RouteTableIds",
	"service_name":          "description.VpcEndpoint.ServiceName",
	"state":                 "description.VpcEndpoint.State",
	"subnet_ids":            "description.VpcEndpoint.SubnetIds",
	"tags_src":              "description.VpcEndpoint.Tags",
	"vpc_endpoint_id":       "description.VpcEndpoint.VpcEndpointId",
	"vpc_endpoint_type":     "description.VpcEndpoint.VpcEndpointType",
	"vpc_id":                "description.VpcEndpoint.VpcId",
}

func GetEC2VPCEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPCEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VPCEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VPCEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VPCEndpoint =============================

// ==========================  START: EC2SecurityGroup =============================

type EC2SecurityGroup struct {
	Description   aws.EC2SecurityGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EC2SecurityGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EC2SecurityGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EC2SecurityGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EC2SecurityGroupHit `json:"hits"`
}

type EC2SecurityGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EC2SecurityGroupHits `json:"hits"`
}

type EC2SecurityGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2SecurityGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EC2SecurityGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_securitygroup", filters, limit)
	if err != nil {
		return EC2SecurityGroupPaginator{}, err
	}

	p := EC2SecurityGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2SecurityGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2SecurityGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2SecurityGroupPaginator) NextPage(ctx context.Context) ([]EC2SecurityGroup, error) {
	var response EC2SecurityGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2SecurityGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2SecurityGroupFilters = map[string]string{
	"arn":                   "arn",
	"description":           "description.SecurityGroup.Description",
	"group_id":              "description.SecurityGroup.GroupId",
	"group_name":            "description.SecurityGroup.GroupName",
	"ip_permissions":        "description.SecurityGroup.IpPermissions",
	"ip_permissions_egress": "description.SecurityGroup.IpPermissionsEgress",
	"og_account_id":         "metadata.SourceID",
	"owner_id":              "description.SecurityGroup.OwnerId",
	"tags_src":              "description.SecurityGroup.Tags",
	"title":                 "description.SecurityGroup.GroupName",
	"vpc_id":                "description.SecurityGroup.VpcId",
}

func ListEC2SecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2SecurityGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2SecurityGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2SecurityGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroup NewEC2SecurityGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2SecurityGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2SecurityGroupFilters = map[string]string{
	"arn":                   "arn",
	"description":           "description.SecurityGroup.Description",
	"group_id":              "description.SecurityGroup.GroupId",
	"group_name":            "description.SecurityGroup.GroupName",
	"ip_permissions":        "description.SecurityGroup.IpPermissions",
	"ip_permissions_egress": "description.SecurityGroup.IpPermissionsEgress",
	"og_account_id":         "metadata.SourceID",
	"owner_id":              "description.SecurityGroup.OwnerId",
	"tags_src":              "description.SecurityGroup.Tags",
	"title":                 "description.SecurityGroup.GroupName",
	"vpc_id":                "description.SecurityGroup.VpcId",
}

func GetEC2SecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2SecurityGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2SecurityGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2SecurityGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2SecurityGroup =============================

// ==========================  START: EC2EIP =============================

type EC2EIP struct {
	Description   aws.EC2EIPDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type EC2EIPHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2EIP        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2EIPHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2EIPHit       `json:"hits"`
}

type EC2EIPSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  EC2EIPHits `json:"hits"`
}

type EC2EIPPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2EIPPaginator(filters []essdk.BoolFilter, limit *int64) (EC2EIPPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_eip", filters, limit)
	if err != nil {
		return EC2EIPPaginator{}, err
	}

	p := EC2EIPPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2EIPPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2EIPPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2EIPPaginator) NextPage(ctx context.Context) ([]EC2EIP, error) {
	var response EC2EIPSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2EIP
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2EIPFilters = map[string]string{
	"allocation_id":              "description.Address.AllocationId",
	"arn":                        "arn",
	"association_id":             "description.Address.AssociationId",
	"carrier_ip":                 "description.Address.CarrierIp",
	"customer_owned_ip":          "description.Address.CustomerOwnedIp",
	"customer_owned_ipv4_pool":   "description.Address.CustomerOwnedIpv4Pool",
	"domain":                     "description.Address.Domain",
	"instance_id":                "description.Address.InstanceId",
	"og_account_id":              "metadata.SourceID",
	"network_border_group":       "description.Address.NetworkBorderGroup",
	"network_interface_id":       "description.Address.NetworkInterfaceId",
	"network_interface_owner_id": "description.Address.NetworkInterfaceOwnerId",
	"private_ip_address":         "description.Address.PrivateIpAddress",
	"public_ip":                  "description.Address.PublicIp",
	"public_ipv4_pool":           "description.Address.PublicIpv4Pool",
	"tags_src":                   "description.Address.Tags",
	"title":                      "description.Address.AllocationId",
}

func ListEC2EIP(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2EIP")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EIP NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EIP NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EIP GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EIP GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EIP GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2EIPPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2EIPFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EIP NewEC2EIPPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2EIP paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2EIPFilters = map[string]string{
	"allocation_id":              "description.SecurityGroup.AllocationId",
	"arn":                        "arn",
	"association_id":             "description.Address.AssociationId",
	"carrier_ip":                 "description.Address.CarrierIp",
	"customer_owned_ip":          "description.Address.CustomerOwnedIp",
	"customer_owned_ipv4_pool":   "description.Address.CustomerOwnedIpv4Pool",
	"domain":                     "description.Address.Domain",
	"instance_id":                "description.Address.InstanceId",
	"og_account_id":              "metadata.SourceID",
	"network_border_group":       "description.Address.NetworkBorderGroup",
	"network_interface_id":       "description.Address.NetworkInterfaceId",
	"network_interface_owner_id": "description.Address.NetworkInterfaceOwnerId",
	"private_ip_address":         "description.Address.PrivateIpAddress",
	"public_ip":                  "description.Address.PublicIp",
	"public_ipv4_pool":           "description.Address.PublicIpv4Pool",
	"tags_src":                   "description.Address.Tags",
	"title":                      "description.Address.AllocationId",
}

func GetEC2EIP(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2EIP")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2EIPPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2EIPFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2EIP =============================

// ==========================  START: EC2InternetGateway =============================

type EC2InternetGateway struct {
	Description   aws.EC2InternetGatewayDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type EC2InternetGatewayHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  EC2InternetGateway `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type EC2InternetGatewayHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []EC2InternetGatewayHit `json:"hits"`
}

type EC2InternetGatewaySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  EC2InternetGatewayHits `json:"hits"`
}

type EC2InternetGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InternetGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2InternetGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_internetgateway", filters, limit)
	if err != nil {
		return EC2InternetGatewayPaginator{}, err
	}

	p := EC2InternetGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InternetGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InternetGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2InternetGatewayPaginator) NextPage(ctx context.Context) ([]EC2InternetGateway, error) {
	var response EC2InternetGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2InternetGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InternetGatewayFilters = map[string]string{
	"attachments":         "description.InternetGateway.Attachments",
	"internet_gateway_id": "description.InternetGateway.InternetGatewayId",
	"og_account_id":       "metadata.SourceID",
	"owner_id":            "description.InternetGateway.OwnerId",
	"tags_src":            "description.InternetGateway.Tags",
}

func ListEC2InternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2InternetGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InternetGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InternetGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InternetGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InternetGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InternetGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2InternetGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2InternetGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InternetGateway NewEC2InternetGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2InternetGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2InternetGatewayFilters = map[string]string{
	"attachments":         "description.InternetGateway.Attachments",
	"internet_gateway_id": "description.InternetGateway.InternetGatewayId",
	"og_account_id":       "metadata.SourceID",
	"owner_id":            "description.InternetGateway.OwnerId",
	"tags_src":            "description.InternetGateway.Tags",
}

func GetEC2InternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2InternetGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2InternetGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2InternetGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2InternetGateway =============================

// ==========================  START: EC2NetworkAcl =============================

type EC2NetworkAcl struct {
	Description   aws.EC2NetworkAclDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2NetworkAclHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2NetworkAcl `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2NetworkAclHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2NetworkAclHit `json:"hits"`
}

type EC2NetworkAclSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2NetworkAclHits `json:"hits"`
}

type EC2NetworkAclPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2NetworkAclPaginator(filters []essdk.BoolFilter, limit *int64) (EC2NetworkAclPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_networkacl", filters, limit)
	if err != nil {
		return EC2NetworkAclPaginator{}, err
	}

	p := EC2NetworkAclPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2NetworkAclPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2NetworkAclPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2NetworkAclPaginator) NextPage(ctx context.Context) ([]EC2NetworkAcl, error) {
	var response EC2NetworkAclSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2NetworkAcl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2NetworkAclFilters = map[string]string{
	"arn":            "arn",
	"associations":   "description.NetworkAcl.Associations",
	"entries":        "description.NetworkAcl.Entries",
	"is_default":     "description.NetworkAcl.IsDefault",
	"og_account_id":  "metadata.SourceID",
	"network_acl_id": "description.NetworkAcl.NetworkAclId",
	"owner_id":       "description.NetworkAcl.OwnerId",
	"tags_src":       "description.NetworkAcl.Tags",
	"vpc_id":         "description.NetworkAcl.VpcId",
}

func ListEC2NetworkAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2NetworkAcl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkAcl NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkAcl NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2NetworkAclPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2NetworkAclFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NetworkAcl NewEC2NetworkAclPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2NetworkAcl paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2NetworkAclFilters = map[string]string{
	"arn":            "arn",
	"associations":   "description.NetworkAcl.Associations",
	"entries":        "description.NetworkAcl.Entries",
	"is_default":     "description.NetworkAcl.IsDefault",
	"og_account_id":  "metadata.SourceID",
	"network_acl_id": "description.NetworkAcl.NetworkAclId",
	"owner_id":       "description.NetworkAcl.OwnerId",
	"tags_src":       "description.NetworkAcl.Tags",
	"vpc_id":         "description.NetworkAcl.VpcId",
}

func GetEC2NetworkAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2NetworkAcl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2NetworkAclPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2NetworkAclFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2NetworkAcl =============================

// ==========================  START: EC2VPNConnection =============================

type EC2VPNConnection struct {
	Description   aws.EC2VPNConnectionDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EC2VPNConnectionHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  EC2VPNConnection `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type EC2VPNConnectionHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []EC2VPNConnectionHit `json:"hits"`
}

type EC2VPNConnectionSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  EC2VPNConnectionHits `json:"hits"`
}

type EC2VPNConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPNConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPNConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpnconnection", filters, limit)
	if err != nil {
		return EC2VPNConnectionPaginator{}, err
	}

	p := EC2VPNConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPNConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPNConnectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VPNConnectionPaginator) NextPage(ctx context.Context) ([]EC2VPNConnection, error) {
	var response EC2VPNConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPNConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPNConnectionFilters = map[string]string{
	"arn":                            "arn",
	"category":                       "description.VpnConnection.Category",
	"customer_gateway_configuration": "description.VpnConnection.CustomerGatewayConfiguration",
	"customer_gateway_id":            "description.VpnConnection.CustomerGatewayId",
	"og_account_id":                  "metadata.SourceID",
	"options":                        "description.VpnConnection.Options",
	"routes":                         "description.VpnConnection.Routes",
	"state":                          "description.VpnConnection.State",
	"tags_src":                       "description.VpnConnection.Tags",
	"transit_gateway_id":             "description.VpnConnection.TransitGatewayId",
	"type":                           "description.VpnConnection.Type",
	"vgw_telemetry":                  "description.VpnConnection.VgwTelemetry",
	"vpn_connection_id":              "description.VpnConnection.VpnConnectionId",
	"vpn_gateway_id":                 "description.VpnConnection.VpnGatewayId",
}

func ListEC2VPNConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPNConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNConnection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNConnection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VPNConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VPNConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPNConnection NewEC2VPNConnectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VPNConnection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VPNConnectionFilters = map[string]string{
	"arn":                            "arn",
	"category":                       "description.VpnConnection.Category",
	"customer_gateway_configuration": "description.VpnConnection.CustomerGatewayConfiguration",
	"customer_gateway_id":            "description.VpnConnection.CustomerGatewayId",
	"og_account_id":                  "metadata.SourceID",
	"options":                        "description.VpnConnection.Options",
	"routes":                         "description.VpnConnection.Routes",
	"state":                          "description.VpnConnection.State",
	"tags_src":                       "description.VpnConnection.Tags",
	"transit_gateway_id":             "description.VpnConnection.TransitGatewayId",
	"type":                           "description.VpnConnection.Type",
	"vgw_telemetry":                  "description.VpnConnection.VgwTelemetry",
	"vpn_connection_id":              "description.VpnConnection.VpnConnectionId",
	"vpn_gateway_id":                 "description.VpnConnection.VpnGatewayId",
}

func GetEC2VPNConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPNConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VPNConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VPNConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VPNConnection =============================

// ==========================  START: EC2RouteTable =============================

type EC2RouteTable struct {
	Description   aws.EC2RouteTableDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2RouteTableHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2RouteTable `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2RouteTableHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2RouteTableHit `json:"hits"`
}

type EC2RouteTableSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2RouteTableHits `json:"hits"`
}

type EC2RouteTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2RouteTablePaginator(filters []essdk.BoolFilter, limit *int64) (EC2RouteTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_routetable", filters, limit)
	if err != nil {
		return EC2RouteTablePaginator{}, err
	}

	p := EC2RouteTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2RouteTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2RouteTablePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2RouteTablePaginator) NextPage(ctx context.Context) ([]EC2RouteTable, error) {
	var response EC2RouteTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2RouteTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2RouteTableFilters = map[string]string{
	"associations":     "description.RouteTable.Associations",
	"og_account_id":    "metadata.SourceID",
	"owner_id":         "description.RouteTable.OwnerId",
	"propagating_vgws": "description.RouteTable.PropagatingVgws",
	"route_table_id":   "description.RouteTable.RouteTableId",
	"routes":           "description.RouteTable.Routes",
	"tags_src":         "description.RouteTable.Tags",
	"title":            "description.RouteTable.RouteTableId",
	"vpc_id":           "description.RouteTable.VpcId",
}

func ListEC2RouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2RouteTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RouteTable NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RouteTable NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RouteTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RouteTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RouteTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2RouteTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2RouteTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2RouteTable NewEC2RouteTablePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2RouteTable paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2RouteTableFilters = map[string]string{
	"associations":     "description.RouteTable.Associations",
	"og_account_id":    "metadata.SourceID",
	"owner_id":         "description.RouteTable.OwnerId",
	"propagating_vgws": "description.RouteTable.PropagatingVgws",
	"route_table_id":   "description.RouteTable.RouteTableId",
	"routes":           "description.RouteTable.Routes",
	"tags_src":         "description.RouteTable.Tags",
	"title":            "description.RouteTable.RouteTableId",
	"vpc_id":           "description.RouteTable.VpcId",
}

func GetEC2RouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2RouteTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2RouteTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2RouteTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2RouteTable =============================

// ==========================  START: EC2NatGateway =============================

type EC2NatGateway struct {
	Description   aws.EC2NatGatewayDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EC2NatGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2NatGateway `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2NatGatewayHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EC2NatGatewayHit `json:"hits"`
}

type EC2NatGatewaySearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EC2NatGatewayHits `json:"hits"`
}

type EC2NatGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2NatGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2NatGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_natgateway", filters, limit)
	if err != nil {
		return EC2NatGatewayPaginator{}, err
	}

	p := EC2NatGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2NatGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2NatGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2NatGatewayPaginator) NextPage(ctx context.Context) ([]EC2NatGateway, error) {
	var response EC2NatGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2NatGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2NatGatewayFilters = map[string]string{
	"arn":                   "arn",
	"create_time":           "description.NatGateway.CreateTime",
	"delete_time":           "description.NatGateway.DeleteTime",
	"failure_code":          "description.NatGateway.FailureCode",
	"failure_message":       "description.NatGateway.FailureMessage",
	"og_account_id":         "metadata.SourceID",
	"nat_gateway_addresses": "description.NatGateway.NatGatewayAddresses",
	"nat_gateway_id":        "description.NatGateway.NatGatewayId",
	"provisioned_bandwidth": "description.NatGateway.ProvisionedBandwidth",
	"state":                 "description.NatGateway.State",
	"subnet_id":             "description.NatGateway.SubnetId",
	"tags_src":              "description.NatGateway.Tags",
	"vpc_id":                "description.NatGateway.VpcId",
}

func ListEC2NatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2NatGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NatGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NatGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NatGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NatGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NatGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2NatGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2NatGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2NatGateway NewEC2NatGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2NatGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2NatGatewayFilters = map[string]string{
	"arn":                   "arn",
	"create_time":           "description.NatGateway.CreateTime",
	"delete_time":           "description.NatGateway.DeleteTime",
	"failure_code":          "description.NatGateway.FailureCode",
	"failure_message":       "description.NatGateway.FailureMessage",
	"og_account_id":         "metadata.SourceID",
	"nat_gateway_addresses": "description.NatGateway.NatGatewayAddresses",
	"nat_gateway_id":        "description.NatGateway.NatGatewayId",
	"provisioned_bandwidth": "description.NatGateway.ProvisionedBandwidth",
	"state":                 "description.NatGateway.State",
	"subnet_id":             "description.NatGateway.SubnetId",
	"tags_src":              "description.NatGateway.Tags",
	"vpc_id":                "description.NatGateway.VpcId",
}

func GetEC2NatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2NatGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2NatGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2NatGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2NatGateway =============================

// ==========================  START: EC2LocalGateway =============================

type EC2LocalGateway struct {
	Description   aws.EC2LocalGatewayDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type EC2LocalGatewayHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EC2LocalGateway `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EC2LocalGatewayHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EC2LocalGatewayHit `json:"hits"`
}

type EC2LocalGatewaySearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EC2LocalGatewayHits `json:"hits"`
}

type EC2LocalGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2LocalGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2LocalGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_localgateway", filters, limit)
	if err != nil {
		return EC2LocalGatewayPaginator{}, err
	}

	p := EC2LocalGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2LocalGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2LocalGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2LocalGatewayPaginator) NextPage(ctx context.Context) ([]EC2LocalGateway, error) {
	var response EC2LocalGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2LocalGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2LocalGatewayFilters = map[string]string{
	"arn":           "arn",
	"id":            "description.LocalGateway.LocalGatewayId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.LocalGateway.LocalGatewayId",
}

func ListEC2LocalGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2LocalGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LocalGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LocalGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LocalGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LocalGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LocalGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2LocalGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2LocalGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LocalGateway NewEC2LocalGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2LocalGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2LocalGatewayFilters = map[string]string{
	"arn":           "arn",
	"id":            "description.LocalGateway.LocalGatewayId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.LocalGateway.LocalGatewayId",
}

func GetEC2LocalGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2LocalGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2LocalGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2LocalGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2LocalGateway =============================

// ==========================  START: EC2Region =============================

type EC2Region struct {
	Description   aws.EC2RegionDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type EC2RegionHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Region     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2RegionHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2RegionHit    `json:"hits"`
}

type EC2RegionSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  EC2RegionHits `json:"hits"`
}

type EC2RegionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2RegionPaginator(filters []essdk.BoolFilter, limit *int64) (EC2RegionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_region", filters, limit)
	if err != nil {
		return EC2RegionPaginator{}, err
	}

	p := EC2RegionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2RegionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2RegionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2RegionPaginator) NextPage(ctx context.Context) ([]EC2Region, error) {
	var response EC2RegionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Region
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2RegionFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"name":          "description.Region.RegionName",
	"opt_in_status": "description.Region.OptInStatus",
	"partition":     "metadata.Partition",
	"region":        "description.Region.RegionName",
	"title":         "description.Region.RegionName",
}

func ListEC2Region(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Region")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Region NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Region NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Region GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Region GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Region GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2RegionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2RegionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Region NewEC2RegionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Region paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2RegionFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"name":          "description.Region.RegionName",
	"opt_in_status": "description.Region.OptInStatus",
	"partition":     "metadata.Partition",
	"region":        "description.Region.RegionName",
	"title":         "description.Region.RegionName",
}

func GetEC2Region(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Region")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2RegionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2RegionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Region =============================

// ==========================  START: EC2AvailabilityZone =============================

type EC2AvailabilityZone struct {
	Description   aws.EC2AvailabilityZoneDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type EC2AvailabilityZoneHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  EC2AvailabilityZone `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type EC2AvailabilityZoneHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []EC2AvailabilityZoneHit `json:"hits"`
}

type EC2AvailabilityZoneSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  EC2AvailabilityZoneHits `json:"hits"`
}

type EC2AvailabilityZonePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2AvailabilityZonePaginator(filters []essdk.BoolFilter, limit *int64) (EC2AvailabilityZonePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_availabilityzone", filters, limit)
	if err != nil {
		return EC2AvailabilityZonePaginator{}, err
	}

	p := EC2AvailabilityZonePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2AvailabilityZonePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2AvailabilityZonePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2AvailabilityZonePaginator) NextPage(ctx context.Context) ([]EC2AvailabilityZone, error) {
	var response EC2AvailabilityZoneSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2AvailabilityZone
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2AvailabilityZoneFilters = map[string]string{
	"group_name":       "description.AvailabilityZone.GroupName",
	"og_account_id":    "metadata.SourceID",
	"messages":         "description.AvailabilityZone.Messages",
	"name":             "description.AvailabilityZone.ZoneName",
	"opt_in_status":    "description.AvailabilityZone.OptInStatus",
	"parent_zone_id":   "description.AvailabilityZone.ParentZoneId",
	"parent_zone_name": "description.AvailabilityZone.ParentZoneName",
	"region_name":      "description.AvailabilityZone.RegionName",
	"title":            "description.AvailabilityZone.ZoneName",
	"zone_id":          "description.AvailabilityZone.ZoneId",
	"zone_type":        "description.AvailabilityZone.ZoneType",
}

func ListEC2AvailabilityZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2AvailabilityZone")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AvailabilityZone NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AvailabilityZone NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AvailabilityZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AvailabilityZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AvailabilityZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2AvailabilityZonePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2AvailabilityZoneFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AvailabilityZone NewEC2AvailabilityZonePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2AvailabilityZone paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2AvailabilityZoneFilters = map[string]string{
	"group_name":       "description.AvailabilityZone.GroupName",
	"og_account_id":    "metadata.SourceID",
	"messages":         "description.AvailabilityZone.Messages",
	"name":             "description.AvailabilityZone.ZoneName",
	"opt_in_status":    "description.AvailabilityZone.OptInStatus",
	"parent_zone_id":   "description.AvailabilityZone.ParentZoneId",
	"parent_zone_name": "description.AvailabilityZone.ParentZoneName",
	"region_name":      "description.AvailabilityZone.RegionName",
	"title":            "description.AvailabilityZone.ZoneName",
	"zone_id":          "description.AvailabilityZone.ZoneId",
	"zone_type":        "description.AvailabilityZone.ZoneType",
}

func GetEC2AvailabilityZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2AvailabilityZone")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2AvailabilityZonePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2AvailabilityZoneFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2AvailabilityZone =============================

// ==========================  START: EC2FlowLog =============================

type EC2FlowLog struct {
	Description   aws.EC2FlowLogDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EC2FlowLogHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2FlowLog    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2FlowLogHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2FlowLogHit   `json:"hits"`
}

type EC2FlowLogSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EC2FlowLogHits `json:"hits"`
}

type EC2FlowLogPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2FlowLogPaginator(filters []essdk.BoolFilter, limit *int64) (EC2FlowLogPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_flowlog", filters, limit)
	if err != nil {
		return EC2FlowLogPaginator{}, err
	}

	p := EC2FlowLogPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2FlowLogPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2FlowLogPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2FlowLogPaginator) NextPage(ctx context.Context) ([]EC2FlowLog, error) {
	var response EC2FlowLogSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2FlowLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2FlowLogFilters = map[string]string{
	"creation_time":               "description.FlowLog.CreationTime",
	"deliver_logs_error_message":  "description.FlowLog.DeliverLogsErrorMessage",
	"deliver_logs_permission_arn": "description.FlowLog.DeliverLogsPermissionArn",
	"deliver_logs_status":         "description.FlowLog.DeliverLogsStatus",
	"flow_log_id":                 "description.FlowLog.FlowLogId",
	"flow_log_status":             "description.FlowLog.FlowLogStatus",
	"og_account_id":               "metadata.SourceID",
	"log_destination":             "description.FlowLog.LogDestination",
	"log_destination_type":        "description.FlowLog.LogDestinationType",
	"log_format":                  "description.FlowLog.LogFormat",
	"log_group_name":              "description.FlowLog.LogGroupName",
	"max_aggregation_interval":    "description.FlowLog.MaxAggregationInterval",
	"resource_id":                 "description.FlowLog.ResourceId",
	"tags_src":                    "description.FlowLog.Tags",
	"traffic_type":                "description.FlowLog.TrafficType",
}

func ListEC2FlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2FlowLog")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2FlowLog NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2FlowLog NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2FlowLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2FlowLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2FlowLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2FlowLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2FlowLogFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2FlowLog NewEC2FlowLogPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2FlowLog paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2FlowLogFilters = map[string]string{
	"creation_time":               "description.FlowLog.CreationTime",
	"deliver_logs_error_message":  "description.FlowLog.DeliverLogsErrorMessage",
	"deliver_logs_permission_arn": "description.FlowLog.DeliverLogsPermissionArn",
	"deliver_logs_status":         "description.FlowLog.DeliverLogsStatus",
	"flow_log_id":                 "description.FlowLog.FlowLogId",
	"flow_log_status":             "description.FlowLog.FlowLogStatus",
	"og_account_id":               "metadata.SourceID",
	"log_destination":             "description.FlowLog.LogDestination",
	"log_destination_type":        "description.FlowLog.LogDestinationType",
	"log_format":                  "description.FlowLog.LogFormat",
	"log_group_name":              "description.FlowLog.LogGroupName",
	"max_aggregation_interval":    "description.FlowLog.MaxAggregationInterval",
	"resource_id":                 "description.FlowLog.ResourceId",
	"tags_src":                    "description.FlowLog.Tags",
	"traffic_type":                "description.FlowLog.TrafficType",
}

func GetEC2FlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2FlowLog")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2FlowLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2FlowLogFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2FlowLog =============================

// ==========================  START: EC2CapacityReservation =============================

type EC2CapacityReservation struct {
	Description   aws.EC2CapacityReservationDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type EC2CapacityReservationHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  EC2CapacityReservation `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type EC2CapacityReservationHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []EC2CapacityReservationHit `json:"hits"`
}

type EC2CapacityReservationSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  EC2CapacityReservationHits `json:"hits"`
}

type EC2CapacityReservationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2CapacityReservationPaginator(filters []essdk.BoolFilter, limit *int64) (EC2CapacityReservationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_capacityreservation", filters, limit)
	if err != nil {
		return EC2CapacityReservationPaginator{}, err
	}

	p := EC2CapacityReservationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2CapacityReservationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2CapacityReservationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2CapacityReservationPaginator) NextPage(ctx context.Context) ([]EC2CapacityReservation, error) {
	var response EC2CapacityReservationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2CapacityReservation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2CapacityReservationFilters = map[string]string{
	"availability_zone":        "description.CapacityReservation.AvailabilityZone",
	"availability_zone_id":     "description.CapacityReservation.AvailabilityZoneId",
	"available_instance_count": "description.CapacityReservation.AvailableInstanceCount",
	"capacity_reservation_arn": "description.CapacityReservation.CapacityReservationArn",
	"capacity_reservation_id":  "description.CapacityReservation.CapacityReservationId",
	"create_date":              "description.CapacityReservation.CreateDate",
	"ebs_optimized":            "description.CapacityReservation.EbsOptimized",
	"end_date":                 "description.CapacityReservation.EndDate",
	"end_date_type":            "description.CapacityReservation.EndDateType",
	"ephemeral_storage":        "description.CapacityReservation.EphemeralStorage",
	"instance_match_criteria":  "description.CapacityReservation.InstanceMatchCriteria",
	"instance_platform":        "description.CapacityReservation.InstancePlatform",
	"instance_type":            "description.CapacityReservation.InstanceType",
	"og_account_id":            "metadata.SourceID",
	"owner_id":                 "description.CapacityReservation.OwnerId",
	"start_date":               "description.CapacityReservation.StartDate",
	"state":                    "description.CapacityReservation.State",
	"tag_src":                  "description.CapacityReservation.Tags",
	"tenancy":                  "description.CapacityReservation.Tenancy",
	"title":                    "description.CapacityReservation.CapacityReservationId",
	"total_instance_count":     "description.CapacityReservation.TotalInstanceCount",
}

func ListEC2CapacityReservation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2CapacityReservation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2CapacityReservationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2CapacityReservationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservation NewEC2CapacityReservationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2CapacityReservation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2CapacityReservationFilters = map[string]string{
	"availability_zone":        "description.CapacityReservation.AvailabilityZone",
	"availability_zone_id":     "description.CapacityReservation.AvailabilityZoneId",
	"available_instance_count": "description.CapacityReservation.AvailableInstanceCount",
	"capacity_reservation_arn": "description.CapacityReservation.CapacityReservationArn",
	"capacity_reservation_id":  "description.CapacityReservation.CapacityReservationId",
	"create_date":              "description.CapacityReservation.CreateDate",
	"ebs_optimized":            "description.CapacityReservation.EbsOptimized",
	"end_date":                 "description.CapacityReservation.EndDate",
	"end_date_type":            "description.CapacityReservation.EndDateType",
	"ephemeral_storage":        "description.CapacityReservation.EphemeralStorage",
	"instance_match_criteria":  "description.CapacityReservation.InstanceMatchCriteria",
	"instance_platform":        "description.CapacityReservation.InstancePlatform",
	"instance_type":            "description.CapacityReservation.InstanceType",
	"og_account_id":            "metadata.SourceID",
	"owner_id":                 "description.CapacityReservation.OwnerId",
	"start_date":               "description.CapacityReservation.StartDate",
	"state":                    "description.CapacityReservation.State",
	"tag_src":                  "description.CapacityReservation.Tags",
	"tenancy":                  "description.CapacityReservation.Tenancy",
	"title":                    "description.CapacityReservation.CapacityReservationId",
	"total_instance_count":     "description.CapacityReservation.TotalInstanceCount",
}

func GetEC2CapacityReservation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2CapacityReservation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2CapacityReservationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2CapacityReservationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2CapacityReservation =============================

// ==========================  START: EC2KeyPair =============================

type EC2KeyPair struct {
	Description   aws.EC2KeyPairDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EC2KeyPairHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2KeyPair    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2KeyPairHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2KeyPairHit   `json:"hits"`
}

type EC2KeyPairSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EC2KeyPairHits `json:"hits"`
}

type EC2KeyPairPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2KeyPairPaginator(filters []essdk.BoolFilter, limit *int64) (EC2KeyPairPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_keypair", filters, limit)
	if err != nil {
		return EC2KeyPairPaginator{}, err
	}

	p := EC2KeyPairPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2KeyPairPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2KeyPairPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2KeyPairPaginator) NextPage(ctx context.Context) ([]EC2KeyPair, error) {
	var response EC2KeyPairSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2KeyPair
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2KeyPairFilters = map[string]string{
	"create_time":     "description.KeyPair.CreateTime",
	"og_account_id":   "metadata.SourceID",
	"key_fingerprint": "description.KeyPair.KeyFingerprint",
	"key_name":        "description.KeyPair.KeyName",
	"key_pair_id":     "description.KeyPair.KeyPairId",
	"tags_src":        "description.KeyPair.Tags",
	"title":           "description.KeyPair.KeyName",
}

func ListEC2KeyPair(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2KeyPair")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2KeyPair NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2KeyPair NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2KeyPair GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2KeyPair GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2KeyPair GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2KeyPairPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2KeyPairFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2KeyPair NewEC2KeyPairPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2KeyPair paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2KeyPairFilters = map[string]string{
	"create_time":     "description.KeyPair.CreateTime",
	"og_account_id":   "metadata.SourceID",
	"key_fingerprint": "description.KeyPair.KeyFingerprint",
	"key_name":        "description.KeyPair.KeyName",
	"key_pair_id":     "description.KeyPair.KeyPairId",
	"tags_src":        "description.KeyPair.Tags",
	"title":           "description.KeyPair.KeyName",
}

func GetEC2KeyPair(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2KeyPair")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2KeyPairPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2KeyPairFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2KeyPair =============================

// ==========================  START: EC2AMI =============================

type EC2AMI struct {
	Description   aws.EC2AMIDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type EC2AMIHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2AMI        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2AMIHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2AMIHit       `json:"hits"`
}

type EC2AMISearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  EC2AMIHits `json:"hits"`
}

type EC2AMIPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2AMIPaginator(filters []essdk.BoolFilter, limit *int64) (EC2AMIPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_image", filters, limit)
	if err != nil {
		return EC2AMIPaginator{}, err
	}

	p := EC2AMIPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2AMIPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2AMIPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2AMIPaginator) NextPage(ctx context.Context) ([]EC2AMI, error) {
	var response EC2AMISearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2AMI
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2AMIFilters = map[string]string{
	"architecture":          "description.AMI.Architecture",
	"block_device_mappings": "description.AMI.BlockDeviceMappings",
	"creation_date":         "description.AMI.CreationDate",
	"description":           "description.AMI.Description",
	"ena_support":           "description.AMI.EnaSupport",
	"hypervisor":            "description.AMI.Hypervisor",
	"image_id":              "description.AMI.ImageId",
	"image_location":        "description.AMI.ImageLocation",
	"image_owner_alias":     "description.AMI.ImageOwnerAlias",
	"image_type":            "description.AMI.ImageType",
	"imds_support":          "description.AMI.ImdsSupport",
	"og_account_id":         "metadata.SourceID",
	"kernel_id":             "description.AMI.KernelId",
	"launch_permissions":    "description.LaunchPermissions",
	"name":                  "description.AMI.Name",
	"owner_id":              "description.AMI.OwnerId",
	"platform":              "description.AMI.Platform",
	"platform_details":      "description.AMI.PlatformDetails",
	"product_codes":         "description.AMI.ProductCodes",
	"public":                "description.AMI.Public",
	"ramdisk_id":            "description.AMI.RamdiskId",
	"root_device_name":      "description.AMI.RootDeviceName",
	"root_device_type":      "description.AMI.RootDeviceType",
	"sriov_net_support":     "description.AMI.SriovNetSupport",
	"state":                 "description.AMI.State",
	"tags_src":              "description.AMI.Tags",
	"usage_operation":       "description.AMI.UsageOperation",
	"virtualization_type":   "description.AMI.VirtualizationType",
}

func ListEC2AMI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2AMI")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AMI NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AMI NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AMI GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AMI GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AMI GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2AMIPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2AMIFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2AMI NewEC2AMIPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2AMI paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2AMIFilters = map[string]string{
	"architecture":          "description.AMI.Architecture",
	"block_device_mappings": "description.AMI.BlockDeviceMappings",
	"creation_date":         "description.AMI.CreationDate",
	"description":           "description.AMI.Description",
	"ena_support":           "description.AMI.EnaSupport",
	"hypervisor":            "description.AMI.Hypervisor",
	"image_id":              "description.AMI.ImageId",
	"image_location":        "description.AMI.ImageLocation",
	"image_owner_alias":     "description.AMI.ImageOwnerAlias",
	"image_type":            "description.AMI.ImageType",
	"imds_support":          "description.AMI.ImdsSupport",
	"og_account_id":         "metadata.SourceID",
	"kernel_id":             "description.AMI.KernelId",
	"launch_permissions":    "description.LaunchPermissions",
	"name":                  "description.AMI.Name",
	"owner_id":              "description.AMI.OwnerId",
	"platform":              "description.AMI.Platform",
	"platform_details":      "description.AMI.PlatformDetails",
	"product_codes":         "description.AMI.ProductCodes",
	"public":                "description.AMI.Public",
	"ramdisk_id":            "description.AMI.RamdiskId",
	"root_device_name":      "description.AMI.RootDeviceName",
	"root_device_type":      "description.AMI.RootDeviceType",
	"sriov_net_support":     "description.AMI.SriovNetSupport",
	"state":                 "description.AMI.State",
	"tags_src":              "description.AMI.Tags",
	"usage_operation":       "description.AMI.UsageOperation",
	"virtualization_type":   "description.AMI.VirtualizationType",
}

func GetEC2AMI(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2AMI")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2AMIPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2AMIFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2AMI =============================

// ==========================  START: EC2ReservedInstances =============================

type EC2ReservedInstances struct {
	Description   aws.EC2ReservedInstancesDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type EC2ReservedInstancesHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  EC2ReservedInstances `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type EC2ReservedInstancesHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []EC2ReservedInstancesHit `json:"hits"`
}

type EC2ReservedInstancesSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  EC2ReservedInstancesHits `json:"hits"`
}

type EC2ReservedInstancesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2ReservedInstancesPaginator(filters []essdk.BoolFilter, limit *int64) (EC2ReservedInstancesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_reservedinstances", filters, limit)
	if err != nil {
		return EC2ReservedInstancesPaginator{}, err
	}

	p := EC2ReservedInstancesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2ReservedInstancesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2ReservedInstancesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2ReservedInstancesPaginator) NextPage(ctx context.Context) ([]EC2ReservedInstances, error) {
	var response EC2ReservedInstancesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2ReservedInstances
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2ReservedInstancesFilters = map[string]string{
	"arn":                              "arn",
	"availability_zone":                "description.ReservedInstances.AvailabilityZone",
	"currency_code":                    "description.ReservedInstances.CurrencyCode",
	"duration":                         "description.ReservedInstances.Duration",
	"end_time":                         "description.ReservedInstances.End",
	"fixed_price":                      "description.ReservedInstances.FixedPrice",
	"instance_count":                   "description.ReservedInstances.InstanceCount",
	"instance_state":                   "description.ReservedInstances.State",
	"instance_tenancy":                 "description.ReservedInstances.InstanceTenancy",
	"instance_type":                    "description.ReservedInstances.InstanceType",
	"og_account_id":                    "metadata.SourceID",
	"offering_class":                   "description.ReservedInstances.OfferingClass",
	"offering_type":                    "description.ReservedInstances.OfferingType",
	"product_description":              "description.ReservedInstances.ProductDescription",
	"reserved_instance_id":             "description.ReservedInstances.ReservedInstancesId",
	"reserved_instances_modifications": "description.ModificationDetails",
	"scope":                            "description.ReservedInstances.Scope",
	"start_time":                       "description.ReservedInstances.Start",
	"tags_src":                         "description.ReservedInstances.Tags",
	"title":                            "description.ReservedInstances.ReservedInstancesId",
	"usage_price":                      "description.ReservedInstances.UsagePrice",
}

func ListEC2ReservedInstances(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2ReservedInstances")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ReservedInstances NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ReservedInstances NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ReservedInstances GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ReservedInstances GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ReservedInstances GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2ReservedInstancesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2ReservedInstancesFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ReservedInstances NewEC2ReservedInstancesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2ReservedInstances paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2ReservedInstancesFilters = map[string]string{
	"arn":                              "arn",
	"availability_zone":                "description.ReservedInstances.AvailabilityZone",
	"currency_code":                    "description.ReservedInstances.CurrencyCode",
	"duration":                         "description.ReservedInstances.Duration",
	"end_time":                         "description.ReservedInstances.End",
	"fixed_price":                      "description.ReservedInstances.FixedPrice",
	"instance_count":                   "description.ReservedInstances.InstanceCount",
	"instance_state":                   "description.ReservedInstances.State",
	"instance_tenancy":                 "description.ReservedInstances.InstanceTenancy",
	"instance_type":                    "description.ReservedInstances.InstanceType",
	"og_account_id":                    "metadata.SourceID",
	"offering_class":                   "description.ReservedInstances.OfferingClass",
	"offering_type":                    "description.ReservedInstances.OfferingType",
	"product_description":              "description.ReservedInstances.ProductDescription",
	"reserved_instance_id":             "description.ReservedInstance.ReservedInstancesId",
	"reserved_instances_modifications": "description.ModificationDetails",
	"scope":                            "description.ReservedInstances.Scope",
	"start_time":                       "description.ReservedInstances.Start",
	"tags_src":                         "description.ReservedInstances.Tags",
	"title":                            "description.ReservedInstances.ReservedInstancesId",
	"usage_price":                      "description.ReservedInstances.UsagePrice",
}

func GetEC2ReservedInstances(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2ReservedInstances")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2ReservedInstancesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2ReservedInstancesFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2ReservedInstances =============================

// ==========================  START: EC2CapacityReservationFleet =============================

type EC2CapacityReservationFleet struct {
	Description   aws.EC2CapacityReservationFleetDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type EC2CapacityReservationFleetHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  EC2CapacityReservationFleet `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type EC2CapacityReservationFleetHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []EC2CapacityReservationFleetHit `json:"hits"`
}

type EC2CapacityReservationFleetSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  EC2CapacityReservationFleetHits `json:"hits"`
}

type EC2CapacityReservationFleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2CapacityReservationFleetPaginator(filters []essdk.BoolFilter, limit *int64) (EC2CapacityReservationFleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_capacityreservationfleet", filters, limit)
	if err != nil {
		return EC2CapacityReservationFleetPaginator{}, err
	}

	p := EC2CapacityReservationFleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2CapacityReservationFleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2CapacityReservationFleetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2CapacityReservationFleetPaginator) NextPage(ctx context.Context) ([]EC2CapacityReservationFleet, error) {
	var response EC2CapacityReservationFleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2CapacityReservationFleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2CapacityReservationFleetFilters = map[string]string{
	"capacity_reservation_fleet_arn": "description.CapacityReservationFleet.CapacityReservationFleetArn",
	"capacity_reservation_fleet_id":  "description.CapacityReservationFleet.CapacityReservationFleetId",
	"og_account_id":                  "metadata.SourceID",
	"title":                          "description.CapacityReservationFleet.CapacityReservationFleetId",
}

func ListEC2CapacityReservationFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2CapacityReservationFleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservationFleet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservationFleet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservationFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservationFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservationFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2CapacityReservationFleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2CapacityReservationFleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2CapacityReservationFleet NewEC2CapacityReservationFleetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2CapacityReservationFleet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2CapacityReservationFleetFilters = map[string]string{
	"capacity_reservation_fleet_arn": "description.CapacityReservationFleet.CapacityReservationFleetArn",
	"capacity_reservation_fleet_id":  "description.CapacityReservationFleet.CapacityReservationFleetId",
	"og_account_id":                  "metadata.SourceID",
	"title":                          "description.CapacityReservationFleet.CapacityReservationFleetId",
}

func GetEC2CapacityReservationFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2CapacityReservationFleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2CapacityReservationFleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2CapacityReservationFleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2CapacityReservationFleet =============================

// ==========================  START: EC2Fleet =============================

type EC2Fleet struct {
	Description   aws.EC2FleetDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type EC2FleetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Fleet      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2FleetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2FleetHit     `json:"hits"`
}

type EC2FleetSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  EC2FleetHits `json:"hits"`
}

type EC2FleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2FleetPaginator(filters []essdk.BoolFilter, limit *int64) (EC2FleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_fleet", filters, limit)
	if err != nil {
		return EC2FleetPaginator{}, err
	}

	p := EC2FleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2FleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2FleetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2FleetPaginator) NextPage(ctx context.Context) ([]EC2Fleet, error) {
	var response EC2FleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Fleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2FleetFilters = map[string]string{
	"fleet_arn":     "arn",
	"fleet_id":      "description.Fleet.FleetId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Fleet.FleetId",
}

func ListEC2Fleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Fleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Fleet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Fleet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Fleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Fleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Fleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2FleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2FleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Fleet NewEC2FleetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Fleet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2FleetFilters = map[string]string{
	"fleet_arn":     "arn",
	"fleet_id":      "description.Fleet.FleetId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Fleet.FleetId",
}

func GetEC2Fleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Fleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2FleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2FleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Fleet =============================

// ==========================  START: EC2Host =============================

type EC2Host struct {
	Description   aws.EC2HostDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type EC2HostHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Host       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2HostHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2HostHit      `json:"hits"`
}

type EC2HostSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  EC2HostHits `json:"hits"`
}

type EC2HostPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2HostPaginator(filters []essdk.BoolFilter, limit *int64) (EC2HostPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_host", filters, limit)
	if err != nil {
		return EC2HostPaginator{}, err
	}

	p := EC2HostPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2HostPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2HostPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2HostPaginator) NextPage(ctx context.Context) ([]EC2Host, error) {
	var response EC2HostSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Host
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2HostFilters = map[string]string{
	"host_arn":      "arn",
	"host_id":       "description.Host.HostId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Host.HostId",
}

func ListEC2Host(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Host")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Host NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Host NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Host GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Host GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Host GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2HostPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2HostFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Host NewEC2HostPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Host paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2HostFilters = map[string]string{
	"host_arn":      "arn",
	"host_id":       "description.Host.HostId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Host.HostId",
}

func GetEC2Host(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Host")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2HostPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2HostFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Host =============================

// ==========================  START: EC2PlacementGroup =============================

type EC2PlacementGroup struct {
	Description   aws.EC2PlacementGroupDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2PlacementGroupHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2PlacementGroup `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2PlacementGroupHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2PlacementGroupHit `json:"hits"`
}

type EC2PlacementGroupSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2PlacementGroupHits `json:"hits"`
}

type EC2PlacementGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2PlacementGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EC2PlacementGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_placementgroup", filters, limit)
	if err != nil {
		return EC2PlacementGroupPaginator{}, err
	}

	p := EC2PlacementGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2PlacementGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2PlacementGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2PlacementGroupPaginator) NextPage(ctx context.Context) ([]EC2PlacementGroup, error) {
	var response EC2PlacementGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2PlacementGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2PlacementGroupFilters = map[string]string{
	"arn":           "arn",
	"group_id":      "description.PlacementGroup.GroupId",
	"group_name":    "description.PlacementGroup.GroupName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.PlacementGroup.GroupName",
}

func ListEC2PlacementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2PlacementGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2PlacementGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2PlacementGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2PlacementGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2PlacementGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2PlacementGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2PlacementGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2PlacementGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2PlacementGroup NewEC2PlacementGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2PlacementGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2PlacementGroupFilters = map[string]string{
	"arn":           "arn",
	"group_id":      "description.PlacementGroup.GroupId",
	"group_name":    "description.PlacementGroup.GroupName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.PlacementGroup.GroupName",
}

func GetEC2PlacementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2PlacementGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2PlacementGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2PlacementGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2PlacementGroup =============================

// ==========================  START: EC2TransitGateway =============================

type EC2TransitGateway struct {
	Description   aws.EC2TransitGatewayDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2TransitGatewayHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2TransitGateway `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2TransitGatewayHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2TransitGatewayHit `json:"hits"`
}

type EC2TransitGatewaySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2TransitGatewayHits `json:"hits"`
}

type EC2TransitGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgateway", filters, limit)
	if err != nil {
		return EC2TransitGatewayPaginator{}, err
	}

	p := EC2TransitGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2TransitGatewayPaginator) NextPage(ctx context.Context) ([]EC2TransitGateway, error) {
	var response EC2TransitGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayFilters = map[string]string{
	"amazon_side_asn":                    "description.TransitGateway.Options.AmazonSideAsn",
	"association_default_route_table_id": "description.TransitGateway.Options.AssociationDefaultRouteTableId",
	"auto_accept_shared_attachments":     "description.TransitGateway.Options.AutoAcceptSharedAttachments",
	"cidr_blocks":                        "description.TransitGateway.Options.TransitGatewayCidrBlocks",
	"creation_time":                      "description.TransitGateway.CreationTime",
	"default_route_table_association":    "description.TransitGateway.Options.DefaultRouteTableAssociation",
	"default_route_table_propagation":    "description.TransitGateway.Options.DefaultRouteTablePropagation",
	"description":                        "description.TransitGateway.Description",
	"dns_support":                        "description.TransitGateway.Options.DnsSupport",
	"og_account_id":                      "metadata.SourceID",
	"multicast_support":                  "description.TransitGateway.Options.MulticastSupport",
	"owner_id":                           "description.TransitGateway.OwnerId",
	"propagation_default_route_table_id": "description.TransitGateway.Options.PropagationDefaultRouteTableId",
	"state":                              "description.TransitGateway.State",
	"tags_src":                           "description.TransitGateway.Tags",
	"transit_gateway_arn":                "description.TransitGateway.TransitGatewayArn",
	"transit_gateway_id":                 "description.TransitGateway.TransitGatewayId",
	"vpn_ecmp_support":                   "description.TransitGateway.Options.VpnEcmpSupport",
}

func ListEC2TransitGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2TransitGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2TransitGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGateway NewEC2TransitGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2TransitGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2TransitGatewayFilters = map[string]string{
	"amazon_side_asn":                    "description.TransitGateway.Options.AmazonSideAsn",
	"association_default_route_table_id": "description.TransitGateway.Options.AssociationDefaultRouteTableId",
	"auto_accept_shared_attachments":     "description.TransitGateway.Options.AutoAcceptSharedAttachments",
	"cidr_blocks":                        "description.TransitGateway.Options.TransitGatewayCidrBlocks",
	"creation_time":                      "description.TransitGateway.CreationTime",
	"default_route_table_association":    "description.TransitGateway.Options.DefaultRouteTableAssociation",
	"default_route_table_propagation":    "description.TransitGateway.Options.DefaultRouteTablePropagation",
	"description":                        "description.TransitGateway.Description",
	"dns_support":                        "description.TransitGateway.Options.DnsSupport",
	"og_account_id":                      "metadata.SourceID",
	"multicast_support":                  "description.TransitGateway.Options.MulticastSupport",
	"owner_id":                           "description.TransitGateway.OwnerId",
	"propagation_default_route_table_id": "description.TransitGateway.Options.PropagationDefaultRouteTableId",
	"state":                              "description.TransitGateway.State",
	"tags_src":                           "description.TransitGateway.Tags",
	"transit_gateway_arn":                "description.TransitGateway.TransitGatewayArn",
	"transit_gateway_id":                 "description.TransitGateway.TransitGatewayId",
	"vpn_ecmp_support":                   "description.TransitGateway.Options.VpnEcmpSupport",
}

func GetEC2TransitGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2TransitGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2TransitGateway =============================

// ==========================  START: EC2TransitGatewayRouteTable =============================

type EC2TransitGatewayRouteTable struct {
	Description   aws.EC2TransitGatewayRouteTableDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type EC2TransitGatewayRouteTableHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  EC2TransitGatewayRouteTable `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type EC2TransitGatewayRouteTableHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []EC2TransitGatewayRouteTableHit `json:"hits"`
}

type EC2TransitGatewayRouteTableSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  EC2TransitGatewayRouteTableHits `json:"hits"`
}

type EC2TransitGatewayRouteTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayRouteTablePaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayRouteTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgatewayroutetable", filters, limit)
	if err != nil {
		return EC2TransitGatewayRouteTablePaginator{}, err
	}

	p := EC2TransitGatewayRouteTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayRouteTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayRouteTablePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2TransitGatewayRouteTablePaginator) NextPage(ctx context.Context) ([]EC2TransitGatewayRouteTable, error) {
	var response EC2TransitGatewayRouteTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGatewayRouteTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayRouteTableFilters = map[string]string{
	"creation_time":                   "description.TransitGatewayRouteTable.CreationTime",
	"default_association_route_table": "description.TransitGatewayRouteTable.DefaultAssociationRouteTable",
	"default_propagation_route_table": "description.TransitGatewayRouteTable.DefaultPropagationRouteTable",
	"og_account_id":                   "metadata.SourceID",
	"state":                           "description.TransitGatewayRouteTable.State",
	"tags_src":                        "description.TransitGatewayRouteTable.Tags",
	"transit_gateway_id":              "description.TransitGatewayRouteTable.TransitGatewayId",
	"transit_gateway_route_table_id":  "description.TransitGatewayRouteTable.TransitGatewayRouteTableId",
}

func ListEC2TransitGatewayRouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGatewayRouteTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRouteTable NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRouteTable NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRouteTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRouteTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRouteTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2TransitGatewayRouteTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2TransitGatewayRouteTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRouteTable NewEC2TransitGatewayRouteTablePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2TransitGatewayRouteTable paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2TransitGatewayRouteTableFilters = map[string]string{
	"creation_time":                   "description.TransitGatewayRouteTable.CreationTime",
	"default_association_route_table": "description.TransitGatewayRouteTable.DefaultAssociationRouteTable",
	"default_propagation_route_table": "description.TransitGatewayRouteTable.DefaultPropagationRouteTable",
	"og_account_id":                   "metadata.SourceID",
	"state":                           "description.TransitGatewayRouteTable.State",
	"tags_src":                        "description.TransitGatewayRouteTable.Tags",
	"transit_gateway_id":              "description.TransitGatewayRouteTable.TransitGatewayId",
	"transit_gateway_route_table_id":  "description.TransitGatewayRouteTable.TransitGatewayRouteTableId",
}

func GetEC2TransitGatewayRouteTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGatewayRouteTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayRouteTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2TransitGatewayRouteTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2TransitGatewayRouteTable =============================

// ==========================  START: EC2DhcpOptions =============================

type EC2DhcpOptions struct {
	Description   aws.EC2DhcpOptionsDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EC2DhcpOptionsHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EC2DhcpOptions `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EC2DhcpOptionsHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EC2DhcpOptionsHit `json:"hits"`
}

type EC2DhcpOptionsSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EC2DhcpOptionsHits `json:"hits"`
}

type EC2DhcpOptionsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2DhcpOptionsPaginator(filters []essdk.BoolFilter, limit *int64) (EC2DhcpOptionsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_dhcpoptions", filters, limit)
	if err != nil {
		return EC2DhcpOptionsPaginator{}, err
	}

	p := EC2DhcpOptionsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2DhcpOptionsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2DhcpOptionsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2DhcpOptionsPaginator) NextPage(ctx context.Context) ([]EC2DhcpOptions, error) {
	var response EC2DhcpOptionsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2DhcpOptions
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2DhcpOptionsFilters = map[string]string{
	"dhcp_options_id":      "description.DhcpOptions.DhcpOptionsId",
	"domain_name":          "description.DhcpOptions.DhcpConfigurations",
	"domain_name_servers":  "description.DhcpOptions.DhcpConfigurations",
	"og_account_id":        "metadata.SourceID",
	"netbios_name_servers": "description.DhcpOptions.DhcpConfigurations",
	"netbios_node_type":    "description.DhcpOptions.DhcpConfigurations",
	"ntp_servers":          "description.DhcpOptions.DhcpConfigurations",
	"owner_id":             "description.DhcpOptions.OwnerId",
	"tags_src":             "description.DhcpOptions.Tags",
}

func ListEC2DhcpOptions(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2DhcpOptions")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2DhcpOptions NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2DhcpOptions NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2DhcpOptions GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2DhcpOptions GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2DhcpOptions GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2DhcpOptionsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2DhcpOptionsFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2DhcpOptions NewEC2DhcpOptionsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2DhcpOptions paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2DhcpOptionsFilters = map[string]string{
	"dhcp_options_id":      "description.DhcpOptions.DhcpOptionsId",
	"domain_name":          "description.DhcpOptions.DhcpConfigurations",
	"domain_name_servers":  "description.DhcpOptions.DhcpConfigurations",
	"og_account_id":        "metadata.SourceID",
	"netbios_name_servers": "description.DhcpOptions.DhcpConfigurations",
	"netbios_node_type":    "description.DhcpOptions.DhcpConfigurations",
	"ntp_servers":          "description.DhcpOptions.DhcpConfigurations",
	"owner_id":             "description.DhcpOptions.OwnerId",
	"tags_src":             "description.DhcpOptions.Tags",
}

func GetEC2DhcpOptions(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2DhcpOptions")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2DhcpOptionsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2DhcpOptionsFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2DhcpOptions =============================

// ==========================  START: EC2EgressOnlyInternetGateway =============================

type EC2EgressOnlyInternetGateway struct {
	Description   aws.EC2EgressOnlyInternetGatewayDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type EC2EgressOnlyInternetGatewayHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  EC2EgressOnlyInternetGateway `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type EC2EgressOnlyInternetGatewayHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []EC2EgressOnlyInternetGatewayHit `json:"hits"`
}

type EC2EgressOnlyInternetGatewaySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  EC2EgressOnlyInternetGatewayHits `json:"hits"`
}

type EC2EgressOnlyInternetGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2EgressOnlyInternetGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (EC2EgressOnlyInternetGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_egressonlyinternetgateway", filters, limit)
	if err != nil {
		return EC2EgressOnlyInternetGatewayPaginator{}, err
	}

	p := EC2EgressOnlyInternetGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2EgressOnlyInternetGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2EgressOnlyInternetGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2EgressOnlyInternetGatewayPaginator) NextPage(ctx context.Context) ([]EC2EgressOnlyInternetGateway, error) {
	var response EC2EgressOnlyInternetGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2EgressOnlyInternetGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2EgressOnlyInternetGatewayFilters = map[string]string{
	"attachments":   "description.EgressOnlyInternetGateway.Attachments",
	"id":            "description.EgressOnlyInternetGateway.EgressOnlyInternetGatewayId",
	"og_account_id": "metadata.SourceID",
	"tags_src":      "description.EgressOnlyInternetGateway.Tags",
}

func ListEC2EgressOnlyInternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2EgressOnlyInternetGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EgressOnlyInternetGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EgressOnlyInternetGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EgressOnlyInternetGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EgressOnlyInternetGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EgressOnlyInternetGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2EgressOnlyInternetGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2EgressOnlyInternetGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2EgressOnlyInternetGateway NewEC2EgressOnlyInternetGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2EgressOnlyInternetGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2EgressOnlyInternetGatewayFilters = map[string]string{
	"attachments":   "description.EgressOnlyInternetGateway.Attachments",
	"id":            "description.EgressOnlyInternetGateway.EgressOnlyInternetGatewayId",
	"og_account_id": "metadata.SourceID",
	"tags_src":      "description.EgressOnlyInternetGateway.Tags",
}

func GetEC2EgressOnlyInternetGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2EgressOnlyInternetGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2EgressOnlyInternetGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2EgressOnlyInternetGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2EgressOnlyInternetGateway =============================

// ==========================  START: EC2VpcPeeringConnection =============================

type EC2VpcPeeringConnection struct {
	Description   aws.EC2VpcPeeringConnectionDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type EC2VpcPeeringConnectionHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  EC2VpcPeeringConnection `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type EC2VpcPeeringConnectionHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []EC2VpcPeeringConnectionHit `json:"hits"`
}

type EC2VpcPeeringConnectionSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  EC2VpcPeeringConnectionHits `json:"hits"`
}

type EC2VpcPeeringConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VpcPeeringConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (EC2VpcPeeringConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpcpeeringconnection", filters, limit)
	if err != nil {
		return EC2VpcPeeringConnectionPaginator{}, err
	}

	p := EC2VpcPeeringConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VpcPeeringConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VpcPeeringConnectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VpcPeeringConnectionPaginator) NextPage(ctx context.Context) ([]EC2VpcPeeringConnection, error) {
	var response EC2VpcPeeringConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VpcPeeringConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VpcPeeringConnectionFilters = map[string]string{
	"accepter_cidr_block":           "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlock",
	"accepter_cidr_block_set":       "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlockSet",
	"accepter_ipv6_cidr_block_set":  "description.VpcPeeringConnection.AccepterVpcInfo.Ipv6CidrBlockSet",
	"accepter_owner_id":             "description.VpcPeeringConnection.AccepterVpcInfo.OwnerId",
	"accepter_peering_options":      "description.VpcPeeringConnection.AccepterVpcInfo.PeeringOptions",
	"accepter_region":               "description.VpcPeeringConnection.AccepterVpcInfo.Region",
	"accepter_vpc_id":               "description.VpcPeeringConnection.AccepterVpcInfo.VpcId",
	"expiration_time":               "description.VpcPeeringConnection.ExpirationTime",
	"id":                            "description.VpcPeeringConnection.VpcPeeringConnectionId",
	"og_account_id":                 "metadata.SourceID",
	"requester_cidr_block":          "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlock",
	"requester_cidr_block_set":      "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlockSet",
	"requester_ipv6_cidr_block_set": "description.VpcPeeringConnection.RequesterVpcInfo.Ipv6CidrBlockSet",
	"requester_owner_id":            "description.VpcPeeringConnection.RequesterVpcInfo.OwnerId",
	"requester_peering_options":     "description.VpcPeeringConnection.RequesterVpcInfo.PeeringOptions",
	"requester_region":              "description.VpcPeeringConnection.RequesterVpcInfo.Region",
	"requester_vpc_id":              "description.VpcPeeringConnection.RequesterVpcInfo.VpcId",
	"status_code":                   "description.VpcPeeringConnection.Status.Code",
	"status_message":                "description.VpcPeeringConnection.Status.Message",
	"tags_src":                      "description.VpcPeeringConnection.Tags",
	"title":                         "description.VpcPeeringConnection.VpcPeeringConnectionId",
}

func ListEC2VpcPeeringConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VpcPeeringConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VpcPeeringConnection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VpcPeeringConnection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VpcPeeringConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VpcPeeringConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VpcPeeringConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VpcPeeringConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VpcPeeringConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VpcPeeringConnection NewEC2VpcPeeringConnectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VpcPeeringConnection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VpcPeeringConnectionFilters = map[string]string{
	"accepter_cidr_block":           "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlock",
	"accepter_cidr_block_set":       "description.VpcPeeringConnection.AccepterVpcInfo.CidrBlockSet",
	"accepter_ipv6_cidr_block_set":  "description.VpcPeeringConnection.AccepterVpcInfo.Ipv6CidrBlockSet",
	"accepter_owner_id":             "description.VpcPeeringConnection.AccepterVpcInfo.OwnerId",
	"accepter_peering_options":      "description.VpcPeeringConnection.AccepterVpcInfo.PeeringOptions",
	"accepter_region":               "description.VpcPeeringConnection.AccepterVpcInfo.Region",
	"accepter_vpc_id":               "description.VpcPeeringConnection.AccepterVpcInfo.VpcId",
	"expiration_time":               "description.VpcPeeringConnection.ExpirationTime",
	"id":                            "description.VpcPeeringConnection.VpcPeeringConnectionId",
	"og_account_id":                 "metadata.SourceID",
	"requester_cidr_block":          "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlock",
	"requester_cidr_block_set":      "description.VpcPeeringConnection.RequesterVpcInfo.CidrBlockSet",
	"requester_ipv6_cidr_block_set": "description.VpcPeeringConnection.RequesterVpcInfo.Ipv6CidrBlockSet",
	"requester_owner_id":            "description.VpcPeeringConnection.RequesterVpcInfo.OwnerId",
	"requester_peering_options":     "description.VpcPeeringConnection.RequesterVpcInfo.PeeringOptions",
	"requester_region":              "description.VpcPeeringConnection.RequesterVpcInfo.Region",
	"requester_vpc_id":              "description.VpcPeeringConnection.RequesterVpcInfo.VpcId",
	"status_code":                   "description.VpcPeeringConnection.Status.Code",
	"status_message":                "description.VpcPeeringConnection.Status.Message",
	"tags_src":                      "description.VpcPeeringConnection.Tags",
	"title":                         "description.VpcPeeringConnection.VpcPeeringConnectionId",
}

func GetEC2VpcPeeringConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VpcPeeringConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VpcPeeringConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VpcPeeringConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VpcPeeringConnection =============================

// ==========================  START: EC2SecurityGroupRule =============================

type EC2SecurityGroupRule struct {
	Description   aws.EC2SecurityGroupRuleDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type EC2SecurityGroupRuleHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  EC2SecurityGroupRule `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type EC2SecurityGroupRuleHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []EC2SecurityGroupRuleHit `json:"hits"`
}

type EC2SecurityGroupRuleSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  EC2SecurityGroupRuleHits `json:"hits"`
}

type EC2SecurityGroupRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2SecurityGroupRulePaginator(filters []essdk.BoolFilter, limit *int64) (EC2SecurityGroupRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_securitygrouprule", filters, limit)
	if err != nil {
		return EC2SecurityGroupRulePaginator{}, err
	}

	p := EC2SecurityGroupRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2SecurityGroupRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2SecurityGroupRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2SecurityGroupRulePaginator) NextPage(ctx context.Context) ([]EC2SecurityGroupRule, error) {
	var response EC2SecurityGroupRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2SecurityGroupRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2SecurityGroupRuleFilters = map[string]string{
	"akas":                                 "akas",
	"cidr_ip":                              "description.IPRange.CidrIp",
	"cidr_ipv4":                            "description.IPRange.CidrIp",
	"cidr_ipv6":                            "description.Ipv6Range.CidrIpv6",
	"from_port":                            "description.Permission.FromPort",
	"group_id":                             "description.Group.GroupId",
	"group_name":                           "description.Group.GroupName",
	"ip_protocol":                          "description.Permission.IpProtocol",
	"og_account_id":                        "metadata.SourceID",
	"owner_id":                             "description.Group.OwnerId",
	"pair_group_id":                        "description.UserIDGroupPair.GroupId",
	"pair_group_name":                      "description.UserIDGroupPair.GroupName",
	"pair_peering_status":                  "description.UserIDGroupPair.PeeringStatus",
	"pair_user_id":                         "description.UserIDGroupPair.UserId",
	"pair_vpc_id":                          "description.UserIDGroupPair.VpcId",
	"pair_vpc_peering_connection_id":       "description.UserIDGroupPair.VpcPeeringConnectionId",
	"prefix_list_id":                       "description.PrefixListId.PrefixListId",
	"referenced_group_id":                  "referencedGroupInfo.GroupId",
	"referenced_peering_status":            "referencedGroupInfo.PeeringStatus",
	"referenced_user_id":                   "referencedGroupInfo.UserId",
	"referenced_vpc_id":                    "referencedGroupInfo.VpcId",
	"referenced_vpc_peering_connection_id": "description.UserIDGroupPair.VpcPeeringConnectionId",
	"title":                                "title",
	"to_port":                              "description.Permission.ToPort",
	"type":                                 "description.Type",
	"vpc_id":                               "description.Group.VpcId",
}

func ListEC2SecurityGroupRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2SecurityGroupRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroupRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroupRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroupRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroupRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroupRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2SecurityGroupRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2SecurityGroupRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2SecurityGroupRule NewEC2SecurityGroupRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2SecurityGroupRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2SecurityGroupRuleFilters = map[string]string{
	"akas":                                 "akas",
	"cidr_ip":                              "description.IPRange.CidrIp",
	"cidr_ipv4":                            "description.IPRange.CidrIp",
	"cidr_ipv6":                            "description.Ipv6Range.CidrIpv6",
	"from_port":                            "description.Permission.FromPort",
	"group_id":                             "description.Group.GroupId",
	"group_name":                           "description.Group.GroupName",
	"ip_protocol":                          "description.Permission.IpProtocol",
	"og_account_id":                        "metadata.SourceID",
	"owner_id":                             "description.Group.OwnerId",
	"pair_group_id":                        "description.UserIDGroupPair.GroupId",
	"pair_group_name":                      "description.UserIDGroupPair.GroupName",
	"pair_peering_status":                  "description.UserIDGroupPair.PeeringStatus",
	"pair_user_id":                         "description.UserIDGroupPair.UserId",
	"pair_vpc_id":                          "description.UserIDGroupPair.VpcId",
	"pair_vpc_peering_connection_id":       "description.UserIDGroupPair.VpcPeeringConnectionId",
	"prefix_list_id":                       "description.PrefixListId.PrefixListId",
	"referenced_group_id":                  "referencedGroupInfo.GroupId",
	"referenced_peering_status":            "referencedGroupInfo.PeeringStatus",
	"referenced_user_id":                   "referencedGroupInfo.UserId",
	"referenced_vpc_id":                    "referencedGroupInfo.VpcId",
	"referenced_vpc_peering_connection_id": "description.UserIDGroupPair.VpcPeeringConnectionId",
	"title":                                "title",
	"to_port":                              "description.Permission.ToPort",
	"type":                                 "description.Type",
	"vpc_id":                               "description.Group.VpcId",
}

func GetEC2SecurityGroupRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2SecurityGroupRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2SecurityGroupRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2SecurityGroupRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2SecurityGroupRule =============================

// ==========================  START: EC2IpamPool =============================

type EC2IpamPool struct {
	Description   aws.EC2IpamPoolDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type EC2IpamPoolHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2IpamPool   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2IpamPoolHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2IpamPoolHit  `json:"hits"`
}

type EC2IpamPoolSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  EC2IpamPoolHits `json:"hits"`
}

type EC2IpamPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2IpamPoolPaginator(filters []essdk.BoolFilter, limit *int64) (EC2IpamPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_ipampool", filters, limit)
	if err != nil {
		return EC2IpamPoolPaginator{}, err
	}

	p := EC2IpamPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2IpamPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2IpamPoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2IpamPoolPaginator) NextPage(ctx context.Context) ([]EC2IpamPool, error) {
	var response EC2IpamPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2IpamPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2IpamPoolFilters = map[string]string{
	"arn":           "description.IpamPool.IpamPoolArn",
	"ipam_pool_id":  "description.IpamPool.IpamPoolId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.IpamPool.IpamPoolId",
}

func ListEC2IpamPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2IpamPool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2IpamPool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2IpamPool NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2IpamPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2IpamPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2IpamPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2IpamPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2IpamPoolFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2IpamPool NewEC2IpamPoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2IpamPool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2IpamPoolFilters = map[string]string{
	"arn":           "description.IpamPool.IpamPoolArn",
	"ipam_pool_id":  "description.IpamPool.IpamPoolId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.IpamPool.IpamPoolId",
}

func GetEC2IpamPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2IpamPool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2IpamPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2IpamPoolFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2IpamPool =============================

// ==========================  START: EC2Ipam =============================

type EC2Ipam struct {
	Description   aws.EC2IpamDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type EC2IpamHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EC2Ipam       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EC2IpamHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EC2IpamHit      `json:"hits"`
}

type EC2IpamSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  EC2IpamHits `json:"hits"`
}

type EC2IpamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2IpamPaginator(filters []essdk.BoolFilter, limit *int64) (EC2IpamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_ipam", filters, limit)
	if err != nil {
		return EC2IpamPaginator{}, err
	}

	p := EC2IpamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2IpamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2IpamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2IpamPaginator) NextPage(ctx context.Context) ([]EC2Ipam, error) {
	var response EC2IpamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2Ipam
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2IpamFilters = map[string]string{
	"arn":           "description.Ipam.IpamArn",
	"ipam_id":       "description.Ipam.IpamId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Ipam.IpamId",
}

func ListEC2Ipam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2Ipam")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Ipam NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Ipam NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Ipam GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Ipam GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Ipam GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2IpamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2IpamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2Ipam NewEC2IpamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2Ipam paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2IpamFilters = map[string]string{
	"arn":           "description.Ipam.IpamArn",
	"ipam_id":       "description.Ipam.IpamId",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Ipam.IpamId",
}

func GetEC2Ipam(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2Ipam")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2IpamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2IpamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2Ipam =============================

// ==========================  START: EC2VPCEndpointService =============================

type EC2VPCEndpointService struct {
	Description   aws.EC2VPCEndpointServiceDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type EC2VPCEndpointServiceHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  EC2VPCEndpointService `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type EC2VPCEndpointServiceHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []EC2VPCEndpointServiceHit `json:"hits"`
}

type EC2VPCEndpointServiceSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  EC2VPCEndpointServiceHits `json:"hits"`
}

type EC2VPCEndpointServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2VPCEndpointServicePaginator(filters []essdk.BoolFilter, limit *int64) (EC2VPCEndpointServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_vpcendpointservice", filters, limit)
	if err != nil {
		return EC2VPCEndpointServicePaginator{}, err
	}

	p := EC2VPCEndpointServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2VPCEndpointServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2VPCEndpointServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2VPCEndpointServicePaginator) NextPage(ctx context.Context) ([]EC2VPCEndpointService, error) {
	var response EC2VPCEndpointServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2VPCEndpointService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2VPCEndpointServiceFilters = map[string]string{
	"acceptance_required":                 "description.VpcEndpointService.AcceptanceRequired",
	"availability_zones":                  "description.VpcEndpointService.AvailabilityZones",
	"base_endpoint_dns_names":             "description.VpcEndpointService.BaseEndpointDnsNames",
	"og_account_id":                       "metadata.SourceID",
	"manages_vpc_endpoints":               "description.VpcEndpointService.ManagesVpcEndpoints",
	"owner":                               "description.VpcEndpointService.Owner",
	"private_dns_name":                    "description.VpcEndpointService.PrivateDnsName",
	"private_dns_name_verification_state": "description.VpcEndpointService.PrivateDnsNameVerificationState",
	"service_id":                          "description.VpcEndpointService.ServiceId",
	"service_name":                        "description.VpcEndpointService.ServiceName",
	"service_type":                        "description.VpcEndpointService.ServiceType",
	"tags_src":                            "description.VpcEndpointService.Tags",
	"title":                               "description.VpcEndpointService.ServiceName",
	"vpc_endpoint_connections":            "description.VpcEndpointConnections",
	"vpc_endpoint_policy_supported":       "description.VpcEndpointService.VpcEndpointPolicySupported",
	"vpc_endpoint_service_permissions":    "description.AllowedPrincipals",
}

func ListEC2VPCEndpointService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2VPCEndpointService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpointService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpointService NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpointService GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpointService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpointService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2VPCEndpointServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2VPCEndpointServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2VPCEndpointService NewEC2VPCEndpointServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2VPCEndpointService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2VPCEndpointServiceFilters = map[string]string{
	"acceptance_required":                 "description.VpcEndpointService.AcceptanceRequired",
	"availability_zones":                  "description.VpcEndpointService.AvailabilityZones",
	"base_endpoint_dns_names":             "description.VpcEndpointService.BaseEndpointDnsNames",
	"og_account_id":                       "metadata.SourceID",
	"manages_vpc_endpoints":               "description.VpcEndpointService.ManagesVpcEndpoints",
	"owner":                               "description.VpcEndpointService.Owner",
	"private_dns_name":                    "description.VpcEndpointService.PrivateDnsName",
	"private_dns_name_verification_state": "description.VpcEndpointService.PrivateDnsNameVerificationState",
	"service_id":                          "description.VpcEndpointService.ServiceId",
	"service_name":                        "description.VPCEndpoint.ServiceName",
	"service_type":                        "description.VpcEndpointService.ServiceType",
	"tags_src":                            "description.VpcEndpointService.Tags",
	"title":                               "description.VpcEndpointService.ServiceName",
	"vpc_endpoint_connections":            "description.VpcEndpointConnections",
	"vpc_endpoint_policy_supported":       "description.VpcEndpointService.VpcEndpointPolicySupported",
	"vpc_endpoint_service_permissions":    "description.AllowedPrincipals",
}

func GetEC2VPCEndpointService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2VPCEndpointService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2VPCEndpointServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2VPCEndpointServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2VPCEndpointService =============================

// ==========================  START: EC2InstanceAvailability =============================

type EC2InstanceAvailability struct {
	Description   aws.EC2InstanceAvailabilityDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type EC2InstanceAvailabilityHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  EC2InstanceAvailability `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type EC2InstanceAvailabilityHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []EC2InstanceAvailabilityHit `json:"hits"`
}

type EC2InstanceAvailabilitySearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  EC2InstanceAvailabilityHits `json:"hits"`
}

type EC2InstanceAvailabilityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InstanceAvailabilityPaginator(filters []essdk.BoolFilter, limit *int64) (EC2InstanceAvailabilityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_instanceavailability", filters, limit)
	if err != nil {
		return EC2InstanceAvailabilityPaginator{}, err
	}

	p := EC2InstanceAvailabilityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InstanceAvailabilityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InstanceAvailabilityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2InstanceAvailabilityPaginator) NextPage(ctx context.Context) ([]EC2InstanceAvailability, error) {
	var response EC2InstanceAvailabilitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2InstanceAvailability
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InstanceAvailabilityFilters = map[string]string{
	"instance_type": "description.InstanceAvailability.InstanceType",
	"og_account_id": "metadata.SourceID",
	"location":      "description.InstanceAvailability.Location",
	"location_type": "description.InstanceAvailability.LocationType",
	"title":         "description.InstanceAvailability.InstanceType",
}

func ListEC2InstanceAvailability(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2InstanceAvailability")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceAvailability NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceAvailability NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceAvailability GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceAvailability GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceAvailability GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2InstanceAvailabilityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2InstanceAvailabilityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceAvailability NewEC2InstanceAvailabilityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2InstanceAvailability paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2InstanceAvailabilityFilters = map[string]string{
	"instance_type": "description.InstanceAvailability.InstanceType",
	"og_account_id": "metadata.SourceID",
	"location":      "description.InstanceAvailability.Location",
	"location_type": "description.InstanceAvailability.LocationType",
	"title":         "description.InstanceAvailability.InstanceType",
}

func GetEC2InstanceAvailability(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2InstanceAvailability")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2InstanceAvailabilityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2InstanceAvailabilityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2InstanceAvailability =============================

// ==========================  START: EC2InstanceType =============================

type EC2InstanceType struct {
	Description   aws.EC2InstanceTypeDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type EC2InstanceTypeHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EC2InstanceType `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EC2InstanceTypeHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EC2InstanceTypeHit `json:"hits"`
}

type EC2InstanceTypeSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EC2InstanceTypeHits `json:"hits"`
}

type EC2InstanceTypePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InstanceTypePaginator(filters []essdk.BoolFilter, limit *int64) (EC2InstanceTypePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_instancetype", filters, limit)
	if err != nil {
		return EC2InstanceTypePaginator{}, err
	}

	p := EC2InstanceTypePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InstanceTypePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InstanceTypePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2InstanceTypePaginator) NextPage(ctx context.Context) ([]EC2InstanceType, error) {
	var response EC2InstanceTypeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2InstanceType
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InstanceTypeFilters = map[string]string{
	"auto_recovery_supported":         "description.InstanceType.AutoRecoverySupported",
	"bare_metal":                      "description.InstanceType.BareMetal",
	"burstable_performance_supported": "description.InstanceType.BurstablePerformanceSupported",
	"current_generation":              "description.InstanceType.CurrentGeneration",
	"dedicated_hosts_supported":       "description.InstanceType.DedicatedHostsSupported",
	"ebs_info":                        "description.InstanceType.EbsInfo",
	"free_tier_eligible":              "description.InstanceType.FreeTierEligible",
	"gpu_info":                        "description.InstanceType.GpuInfo",
	"hibernation_supported":           "description.InstanceType.HibernationSupported",
	"hypervisor":                      "description.InstanceType.Hypervisor",
	"instance_storage_supported":      "description.InstanceType.InstanceStorageSupported",
	"instance_type":                   "description.InstanceType.InstanceType",
	"og_account_id":                   "metadata.SourceID",
	"memory_info":                     "description.InstanceType.MemoryInfo",
	"network_info":                    "description.InstanceType.NetworkInfo",
	"placement_group_info":            "description.InstanceType.PlacementGroupInfo",
	"processor_info":                  "description.InstanceType.ProcessorInfo",
	"supported_root_device_types":     "description.InstanceType.SupportedRootDeviceTypes",
	"supported_usage_classes":         "description.InstanceType.SupportedUsageClasses",
	"supported_virtualization_types":  "description.InstanceType.SupportedVirtualizationTypes",
	"title":                           "description.InstanceType.InstanceType",
	"v_cpu_info":                      "description.InstanceType.VCpuInfo",
}

func ListEC2InstanceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2InstanceType")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceType NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceType NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2InstanceTypePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2InstanceTypeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceType NewEC2InstanceTypePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2InstanceType paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2InstanceTypeFilters = map[string]string{
	"auto_recovery_supported":         "description.InstanceType.AutoRecoverySupported",
	"bare_metal":                      "description.InstanceType.BareMetal",
	"burstable_performance_supported": "description.InstanceType.BurstablePerformanceSupported",
	"current_generation":              "description.InstanceType.CurrentGeneration",
	"dedicated_hosts_supported":       "description.InstanceType.DedicatedHostsSupported",
	"ebs_info":                        "description.InstanceType.EbsInfo",
	"free_tier_eligible":              "description.InstanceType.FreeTierEligible",
	"gpu_info":                        "description.InstanceType.GpuInfo",
	"hibernation_supported":           "description.InstanceType.HibernationSupported",
	"hypervisor":                      "description.InstanceType.Hypervisor",
	"instance_storage_supported":      "description.InstanceType.InstanceStorageSupported",
	"instance_type":                   "description.InstanceType.InstanceType",
	"og_account_id":                   "metadata.SourceID",
	"memory_info":                     "description.InstanceType.MemoryInfo",
	"network_info":                    "description.InstanceType.NetworkInfo",
	"placement_group_info":            "description.InstanceType.PlacementGroupInfo",
	"processor_info":                  "description.InstanceType.ProcessorInfo",
	"supported_root_device_types":     "description.InstanceType.SupportedRootDeviceTypes",
	"supported_usage_classes":         "description.InstanceType.SupportedUsageClasses",
	"supported_virtualization_types":  "description.InstanceType.SupportedVirtualizationTypes",
	"title":                           "description.InstanceType.InstanceType",
	"v_cpu_info":                      "description.InstanceType.VCpuInfo",
}

func GetEC2InstanceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2InstanceType")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2InstanceTypePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2InstanceTypeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2InstanceType =============================

// ==========================  START: EC2ManagedPrefixList =============================

type EC2ManagedPrefixList struct {
	Description   aws.EC2ManagedPrefixListDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type EC2ManagedPrefixListHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  EC2ManagedPrefixList `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type EC2ManagedPrefixListHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []EC2ManagedPrefixListHit `json:"hits"`
}

type EC2ManagedPrefixListSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  EC2ManagedPrefixListHits `json:"hits"`
}

type EC2ManagedPrefixListPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2ManagedPrefixListPaginator(filters []essdk.BoolFilter, limit *int64) (EC2ManagedPrefixListPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_managedprefixlist", filters, limit)
	if err != nil {
		return EC2ManagedPrefixListPaginator{}, err
	}

	p := EC2ManagedPrefixListPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2ManagedPrefixListPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2ManagedPrefixListPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2ManagedPrefixListPaginator) NextPage(ctx context.Context) ([]EC2ManagedPrefixList, error) {
	var response EC2ManagedPrefixListSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2ManagedPrefixList
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2ManagedPrefixListFilters = map[string]string{
	"address_family": "description.ManagedPrefixList.AddressFamily",
	"arn":            "description.ManagedPrefixList.PrefixListArn",
	"id":             "description.ManagedPrefixList.PrefixListId",
	"og_account_id":  "metadata.SourceID",
	"max_entries":    "description.ManagedPrefixList.MaxEntries",
	"name":           "description.ManagedPrefixList.PrefixListName",
	"owner_id":       "description.ManagedPrefixList.OwnerId",
	"state":          "description.ManagedPrefixList.State",
	"state_message":  "description.ManagedPrefixList.StateMessage",
	"tags_src":       "description.ManagedPrefixList.Tags",
	"title":          "description.ManagedPrefixList.PrefixListName",
	"version":        "description.ManagedPrefixList.Version",
}

func ListEC2ManagedPrefixList(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2ManagedPrefixList")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixList NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixList NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixList GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixList GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixList GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2ManagedPrefixListPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2ManagedPrefixListFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixList NewEC2ManagedPrefixListPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2ManagedPrefixList paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2ManagedPrefixListFilters = map[string]string{
	"address_family": "description.ManagedPrefixList.AddressFamily",
	"arn":            "description.ManagedPrefixList.PrefixListArn",
	"id":             "description.ManagedPrefixList.PrefixListId",
	"og_account_id":  "metadata.SourceID",
	"max_entries":    "description.ManagedPrefixList.MaxEntries",
	"name":           "description.ManagedPrefixList.PrefixListName",
	"owner_id":       "description.ManagedPrefixList.OwnerId",
	"state":          "description.ManagedPrefixList.State",
	"state_message":  "description.ManagedPrefixList.StateMessage",
	"tags_src":       "description.ManagedPrefixList.Tags",
	"title":          "description.ManagedPrefixList.PrefixListName",
	"version":        "description.ManagedPrefixList.Version",
}

func GetEC2ManagedPrefixList(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2ManagedPrefixList")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2ManagedPrefixListPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2ManagedPrefixListFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2ManagedPrefixList =============================

// ==========================  START: EC2ManagedPrefixListEntry =============================

type EC2ManagedPrefixListEntry struct {
	Description   aws.EC2ManagedPrefixListEntryDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type EC2ManagedPrefixListEntryHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  EC2ManagedPrefixListEntry `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type EC2ManagedPrefixListEntryHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []EC2ManagedPrefixListEntryHit `json:"hits"`
}

type EC2ManagedPrefixListEntrySearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  EC2ManagedPrefixListEntryHits `json:"hits"`
}

type EC2ManagedPrefixListEntryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2ManagedPrefixListEntryPaginator(filters []essdk.BoolFilter, limit *int64) (EC2ManagedPrefixListEntryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_managedprefixlistentry", filters, limit)
	if err != nil {
		return EC2ManagedPrefixListEntryPaginator{}, err
	}

	p := EC2ManagedPrefixListEntryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2ManagedPrefixListEntryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2ManagedPrefixListEntryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2ManagedPrefixListEntryPaginator) NextPage(ctx context.Context) ([]EC2ManagedPrefixListEntry, error) {
	var response EC2ManagedPrefixListEntrySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2ManagedPrefixListEntry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2ManagedPrefixListEntryFilters = map[string]string{
	"og_account_id":  "metadata.SourceID",
	"prefix_list_id": "description.LaunchTemplateVersion.LaunchTemplateName",
	"title":          "cidr",
}

func ListEC2ManagedPrefixListEntry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2ManagedPrefixListEntry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixListEntry NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixListEntry NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixListEntry GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixListEntry GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixListEntry GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2ManagedPrefixListEntryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2ManagedPrefixListEntryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2ManagedPrefixListEntry NewEC2ManagedPrefixListEntryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2ManagedPrefixListEntry paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2ManagedPrefixListEntryFilters = map[string]string{
	"og_account_id":  "metadata.SourceID",
	"prefix_list_id": "description.LaunchTemplateVersion.LaunchTemplateName",
	"title":          "cidr",
}

func GetEC2ManagedPrefixListEntry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2ManagedPrefixListEntry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2ManagedPrefixListEntryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2ManagedPrefixListEntryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2ManagedPrefixListEntry =============================

// ==========================  START: EC2TransitGatewayRoute =============================

type EC2TransitGatewayRoute struct {
	Description   aws.EC2TransitGatewayRouteDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type EC2TransitGatewayRouteHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  EC2TransitGatewayRoute `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type EC2TransitGatewayRouteHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []EC2TransitGatewayRouteHit `json:"hits"`
}

type EC2TransitGatewayRouteSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  EC2TransitGatewayRouteHits `json:"hits"`
}

type EC2TransitGatewayRoutePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayRoutePaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayRoutePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgatewayroute", filters, limit)
	if err != nil {
		return EC2TransitGatewayRoutePaginator{}, err
	}

	p := EC2TransitGatewayRoutePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayRoutePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayRoutePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2TransitGatewayRoutePaginator) NextPage(ctx context.Context) ([]EC2TransitGatewayRoute, error) {
	var response EC2TransitGatewayRouteSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGatewayRoute
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayRouteFilters = map[string]string{
	"destination_cidr_block":         "description.TransitGatewayRoute.DestinationCidrBlock",
	"og_account_id":                  "metadata.SourceID",
	"prefix_list_id":                 "description.TransitGatewayRoute.PrefixListId",
	"state":                          "description.TransitGatewayRoute.State",
	"title":                          "description.TransitGatewayRoute.DestinationCidrBlock",
	"transit_gateway_attachments":    "description.TransitGatewayRoute.TransitGatewayAttachments",
	"transit_gateway_route_table_id": "description.TransitGatewayRouteTableId",
	"type":                           "description.TransitGatewayRoute.Type",
}

func ListEC2TransitGatewayRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGatewayRoute")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRoute NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRoute NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2TransitGatewayRoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2TransitGatewayRouteFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayRoute NewEC2TransitGatewayRoutePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2TransitGatewayRoute paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2TransitGatewayRouteFilters = map[string]string{
	"destination_cidr_block":         "description.TransitGatewayRoute.DestinationCidrBlock",
	"og_account_id":                  "metadata.SourceID",
	"prefix_list_id":                 "description.TransitGatewayRoute.PrefixListId",
	"state":                          "description.TransitGatewayRoute.State",
	"title":                          "description.TransitGatewayRoute.DestinationCidrBlock",
	"transit_gateway_attachments":    "description.TransitGatewayRoute.TransitGatewayAttachments",
	"transit_gateway_route_table_id": "description.TransitGatewayRouteTableId",
	"type":                           "description.TransitGatewayRoute.Type",
}

func GetEC2TransitGatewayRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGatewayRoute")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayRoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2TransitGatewayRouteFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2TransitGatewayRoute =============================

// ==========================  START: EC2TransitGatewayAttachment =============================

type EC2TransitGatewayAttachment struct {
	Description   aws.EC2TransitGatewayAttachmentDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type EC2TransitGatewayAttachmentHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  EC2TransitGatewayAttachment `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type EC2TransitGatewayAttachmentHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []EC2TransitGatewayAttachmentHit `json:"hits"`
}

type EC2TransitGatewayAttachmentSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  EC2TransitGatewayAttachmentHits `json:"hits"`
}

type EC2TransitGatewayAttachmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2TransitGatewayAttachmentPaginator(filters []essdk.BoolFilter, limit *int64) (EC2TransitGatewayAttachmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_transitgatewayattachment", filters, limit)
	if err != nil {
		return EC2TransitGatewayAttachmentPaginator{}, err
	}

	p := EC2TransitGatewayAttachmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2TransitGatewayAttachmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2TransitGatewayAttachmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2TransitGatewayAttachmentPaginator) NextPage(ctx context.Context) ([]EC2TransitGatewayAttachment, error) {
	var response EC2TransitGatewayAttachmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2TransitGatewayAttachment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2TransitGatewayAttachmentFilters = map[string]string{
	"association_state":                          "description.TransitGatewayAttachment.Association.State",
	"association_transit_gateway_route_table_id": "description.TransitGatewayAttachment.Association.TransitGatewayRouteTableId",
	"creation_time":                              "description.TransitGatewayAttachment.CreationTime",
	"og_account_id":                              "metadata.SourceID",
	"resource_id":                                "description.TransitGatewayAttachment.ResourceId",
	"resource_owner_id":                          "description.TransitGatewayAttachment.ResourceOwnerId",
	"resource_type":                              "description.TransitGatewayAttachment.ResourceType",
	"state":                                      "description.TransitGatewayAttachment.State",
	"tags_src":                                   "description.TransitGatewayAttachment.Tags",
	"transit_gateway_attachment_id":              "description.TransitGatewayAttachment.TransitGatewayAttachmentId",
	"transit_gateway_id":                         "description.TransitGatewayAttachment.TransitGatewayId",
	"transit_gateway_owner_id":                   "description.TransitGatewayAttachment.TransitGatewayOwnerId",
}

func ListEC2TransitGatewayAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2TransitGatewayAttachment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayAttachment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayAttachment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2TransitGatewayAttachmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2TransitGatewayAttachmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2TransitGatewayAttachment NewEC2TransitGatewayAttachmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2TransitGatewayAttachment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2TransitGatewayAttachmentFilters = map[string]string{
	"association_state":                          "description.TransitGatewayAttachment.Association.State",
	"association_transit_gateway_route_table_id": "description.TransitGatewayAttachment.Association.TransitGatewayRouteTableId",
	"creation_time":                              "description.TransitGatewayAttachment.CreationTime",
	"og_account_id":                              "metadata.SourceID",
	"resource_id":                                "description.TransitGatewayAttachment.ResourceId",
	"resource_owner_id":                          "description.TransitGatewayAttachment.ResourceOwnerId",
	"resource_type":                              "description.TransitGatewayAttachment.ResourceType",
	"state":                                      "description.TransitGatewayAttachment.State",
	"tags_src":                                   "description.TransitGatewayAttachment.Tags",
	"transit_gateway_attachment_id":              "description.TransitGatewayAttachment.TransitGatewayAttachmentId",
	"transit_gateway_id":                         "description.TransitGatewayAttachment.TransitGatewayId",
	"transit_gateway_owner_id":                   "description.TransitGatewayAttachment.TransitGatewayOwnerId",
}

func GetEC2TransitGatewayAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2TransitGatewayAttachment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2TransitGatewayAttachmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2TransitGatewayAttachmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2TransitGatewayAttachment =============================

// ==========================  START: EC2LaunchTemplate =============================

type EC2LaunchTemplate struct {
	Description   aws.EC2LaunchTemplateDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EC2LaunchTemplateHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EC2LaunchTemplate `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EC2LaunchTemplateHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EC2LaunchTemplateHit `json:"hits"`
}

type EC2LaunchTemplateSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EC2LaunchTemplateHits `json:"hits"`
}

type EC2LaunchTemplatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2LaunchTemplatePaginator(filters []essdk.BoolFilter, limit *int64) (EC2LaunchTemplatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_launchtemplate", filters, limit)
	if err != nil {
		return EC2LaunchTemplatePaginator{}, err
	}

	p := EC2LaunchTemplatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2LaunchTemplatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2LaunchTemplatePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2LaunchTemplatePaginator) NextPage(ctx context.Context) ([]EC2LaunchTemplate, error) {
	var response EC2LaunchTemplateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2LaunchTemplate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2LaunchTemplateFilters = map[string]string{
	"create_time":            "description.CreateTime",
	"created_by":             "description.CreatedBy",
	"default_version_number": "description.DefaultVersionNumber",
	"id":                     "description.LaunchTemplate.LaunchTemplateId",
	"latest_version_number":  "description.LatestVersionNumber",
	"launch_template_id":     "description.LaunchTemplate.LaunchTemplateId",
	"launch_template_name":   "description.LaunchTemplate.LaunchTemplateName",
	"name":                   "description.LaunchTemplate.LaunchTemplateName",
	"tags_src":               "description.Tags",
	"title":                  "description.LaunchTemplate.Name",
}

func ListEC2LaunchTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2LaunchTemplate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplate NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplate NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplate GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplate GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplate GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2LaunchTemplatePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2LaunchTemplateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplate NewEC2LaunchTemplatePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2LaunchTemplate paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2LaunchTemplateFilters = map[string]string{
	"create_time":            "description.CreateTime",
	"created_by":             "description.CreatedBy",
	"default_version_number": "description.DefaultVersionNumber",
	"id":                     "description.LaunchTemplate.LaunchTemplateId",
	"latest_version_number":  "description.LatestVersionNumber",
	"launch_template_id":     "description.LaunchTemplate.LaunchTemplateId",
	"launch_template_name":   "description.LaunchTemplate.LaunchTemplateName",
	"name":                   "description.LaunchTemplate.LaunchTemplateName",
	"tags_src":               "description.Tags",
	"title":                  "description.LaunchTemplate.Name",
}

func GetEC2LaunchTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2LaunchTemplate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2LaunchTemplatePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2LaunchTemplateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2LaunchTemplate =============================

// ==========================  START: EC2LaunchTemplateVersion =============================

type EC2LaunchTemplateVersion struct {
	Description   aws.EC2LaunchTemplateVersionDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type EC2LaunchTemplateVersionHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  EC2LaunchTemplateVersion `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type EC2LaunchTemplateVersionHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []EC2LaunchTemplateVersionHit `json:"hits"`
}

type EC2LaunchTemplateVersionSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  EC2LaunchTemplateVersionHits `json:"hits"`
}

type EC2LaunchTemplateVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2LaunchTemplateVersionPaginator(filters []essdk.BoolFilter, limit *int64) (EC2LaunchTemplateVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_launchtemplateversion", filters, limit)
	if err != nil {
		return EC2LaunchTemplateVersionPaginator{}, err
	}

	p := EC2LaunchTemplateVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2LaunchTemplateVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2LaunchTemplateVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2LaunchTemplateVersionPaginator) NextPage(ctx context.Context) ([]EC2LaunchTemplateVersion, error) {
	var response EC2LaunchTemplateVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2LaunchTemplateVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2LaunchTemplateVersionFilters = map[string]string{
	"create_time":             "description.LaunchTemplateVersion.CreateTime",
	"created_by":              "description.LaunchTemplateVersion.CreatedBy",
	"default_version":         "description.LaunchTemplateVersion.DefaultVersion",
	"disable_api_stop":        "description.LaunchTemplateVersion.LaunchTemplateData.DisableApiStop",
	"disable_api_termination": "description.LaunchTemplateVersion.LaunchTemplateData.DisableApiTermination",
	"ebs_optimized":           "description.LaunchTemplateVersion.LaunchTemplateData.EbsOptimized",
	"image_id":                "description.LaunchTemplateVersion.LaunchTemplateData.ImageId",
	"instance_type":           "description.LaunchTemplateVersion.LaunchTemplateData.InstanceType",
	"kernel_id":               "description.LaunchTemplateVersion.LaunchTemplateData.KernelId",
	"key_name":                "description.LaunchTemplateVersion.LaunchTemplateData.KeyName",
	"launch_template_data":    "description.LaunchTemplateVersion.LaunchTemplateData",
	"launch_template_id":      "description.LaunchTemplateVersion.LaunchTemplateId",
	"launch_template_name":    "description.LaunchTemplateVersion.LaunchTemplateName",
	"ram_disk_id":             "description.LaunchTemplateVersion.LaunchTemplateData.RamDiskId",
	"security_group_ids":      "description.LaunchTemplateVersion.LaunchTemplateData.SecurityGroupIds",
	"security_groups":         "description.LaunchTemplateVersion.LaunchTemplateData.SecurityGroups",
	"title":                   "description.LaunchTemplateVersion.LaunchTemplateName",
	"version_description":     "description.LaunchTemplateVersion.VersionDescription",
	"version_number":          "description.LaunchTemplateVersion.VersionNumber",
}

func ListEC2LaunchTemplateVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2LaunchTemplateVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplateVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplateVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplateVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplateVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplateVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2LaunchTemplateVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2LaunchTemplateVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2LaunchTemplateVersion NewEC2LaunchTemplateVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2LaunchTemplateVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2LaunchTemplateVersionFilters = map[string]string{
	"create_time":             "description.LaunchTemplateVersion.CreateTime",
	"created_by":              "description.LaunchTemplateVersion.CreatedBy",
	"default_version":         "description.LaunchTemplateVersion.DefaultVersion",
	"disable_api_stop":        "description.LaunchTemplateVersion.LaunchTemplateData.DisableApiStop",
	"disable_api_termination": "description.LaunchTemplateVersion.LaunchTemplateData.DisableApiTermination",
	"ebs_optimized":           "description.LaunchTemplateVersion.LaunchTemplateData.EbsOptimized",
	"image_id":                "description.LaunchTemplateVersion.LaunchTemplateData.ImageId",
	"instance_type":           "description.LaunchTemplateVersion.LaunchTemplateData.InstanceType",
	"kernel_id":               "description.LaunchTemplateVersion.LaunchTemplateData.KernelId",
	"key_name":                "description.LaunchTemplateVersion.LaunchTemplateData.KeyName",
	"launch_template_data":    "description.LaunchTemplateVersion.LaunchTemplateData",
	"launch_template_id":      "description.LaunchTemplateVersion.LaunchTemplateId",
	"launch_template_name":    "description.LaunchTemplateVersion.LaunchTemplateName",
	"ram_disk_id":             "description.LaunchTemplateVersion.LaunchTemplateData.RamDiskId",
	"security_group_ids":      "description.LaunchTemplateVersion.LaunchTemplateData.SecurityGroupIds",
	"security_groups":         "description.LaunchTemplateVersion.LaunchTemplateData.SecurityGroups",
	"title":                   "description.LaunchTemplateVersion.LaunchTemplateName",
	"version_description":     "description.LaunchTemplateVersion.VersionDescription",
	"version_number":          "description.LaunchTemplateVersion.VersionNumber",
}

func GetEC2LaunchTemplateVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2LaunchTemplateVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2LaunchTemplateVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2LaunchTemplateVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2LaunchTemplateVersion =============================

// ==========================  START: EC2InstanceMetricCpuUtilizationHourly =============================

type EC2InstanceMetricCpuUtilizationHourly struct {
	Description   aws.EC2InstanceMetricCpuUtilizationHourlyDescription `json:"description"`
	Metadata      aws.Metadata                                         `json:"metadata"`
	ResourceJobID int                                                  `json:"resource_job_id"`
	SourceJobID   int                                                  `json:"source_job_id"`
	ResourceType  string                                               `json:"resource_type"`
	SourceType    string                                               `json:"source_type"`
	ID            string                                               `json:"id"`
	ARN           string                                               `json:"arn"`
	SourceID      string                                               `json:"source_id"`
}

type EC2InstanceMetricCpuUtilizationHourlyHit struct {
	ID      string                                `json:"_id"`
	Score   float64                               `json:"_score"`
	Index   string                                `json:"_index"`
	Type    string                                `json:"_type"`
	Version int64                                 `json:"_version,omitempty"`
	Source  EC2InstanceMetricCpuUtilizationHourly `json:"_source"`
	Sort    []interface{}                         `json:"sort"`
}

type EC2InstanceMetricCpuUtilizationHourlyHits struct {
	Total essdk.SearchTotal                          `json:"total"`
	Hits  []EC2InstanceMetricCpuUtilizationHourlyHit `json:"hits"`
}

type EC2InstanceMetricCpuUtilizationHourlySearchResponse struct {
	PitID string                                    `json:"pit_id"`
	Hits  EC2InstanceMetricCpuUtilizationHourlyHits `json:"hits"`
}

type EC2InstanceMetricCpuUtilizationHourlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEC2InstanceMetricCpuUtilizationHourlyPaginator(filters []essdk.BoolFilter, limit *int64) (EC2InstanceMetricCpuUtilizationHourlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ec2_instancemetriccpuutilizationhourly", filters, limit)
	if err != nil {
		return EC2InstanceMetricCpuUtilizationHourlyPaginator{}, err
	}

	p := EC2InstanceMetricCpuUtilizationHourlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EC2InstanceMetricCpuUtilizationHourlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EC2InstanceMetricCpuUtilizationHourlyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EC2InstanceMetricCpuUtilizationHourlyPaginator) NextPage(ctx context.Context) ([]EC2InstanceMetricCpuUtilizationHourly, error) {
	var response EC2InstanceMetricCpuUtilizationHourlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EC2InstanceMetricCpuUtilizationHourly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEC2InstanceMetricCpuUtilizationHourlyFilters = map[string]string{
	"account_id":   "account",
	"average":      "description.Average",
	"instance_id":  "description.InstanceId",
	"maximum":      "description.Maximum",
	"minimum":      "description.Minimum",
	"sample_count": "description.SampleCount",
	"sum":          "description.Sum",
	"timestamp":    "description.Timestamp",
}

func ListEC2InstanceMetricCpuUtilizationHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEC2InstanceMetricCpuUtilizationHourly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceMetricCpuUtilizationHourly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceMetricCpuUtilizationHourly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceMetricCpuUtilizationHourly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceMetricCpuUtilizationHourly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceMetricCpuUtilizationHourly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEC2InstanceMetricCpuUtilizationHourlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEC2InstanceMetricCpuUtilizationHourlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEC2InstanceMetricCpuUtilizationHourly NewEC2InstanceMetricCpuUtilizationHourlyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEC2InstanceMetricCpuUtilizationHourly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEC2InstanceMetricCpuUtilizationHourlyFilters = map[string]string{
	"account_id":   "account",
	"average":      "description.Average",
	"instance_id":  "description.InstanceId",
	"maximum":      "description.Maximum",
	"minimum":      "description.Minimum",
	"sample_count": "description.SampleCount",
	"sum":          "description.Sum",
	"timestamp":    "description.Timestamp",
}

func GetEC2InstanceMetricCpuUtilizationHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEC2InstanceMetricCpuUtilizationHourly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEC2InstanceMetricCpuUtilizationHourlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEC2InstanceMetricCpuUtilizationHourlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EC2InstanceMetricCpuUtilizationHourly =============================

// ==========================  START: ElasticLoadBalancingV2SslPolicy =============================

type ElasticLoadBalancingV2SslPolicy struct {
	Description   aws.ElasticLoadBalancingV2SslPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type ElasticLoadBalancingV2SslPolicyHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2SslPolicy `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type ElasticLoadBalancingV2SslPolicyHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []ElasticLoadBalancingV2SslPolicyHit `json:"hits"`
}

type ElasticLoadBalancingV2SslPolicySearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  ElasticLoadBalancingV2SslPolicyHits `json:"hits"`
}

type ElasticLoadBalancingV2SslPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2SslPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2SslPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_sslpolicy", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2SslPolicyPaginator{}, err
	}

	p := ElasticLoadBalancingV2SslPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2SslPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2SslPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticLoadBalancingV2SslPolicyPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2SslPolicy, error) {
	var response ElasticLoadBalancingV2SslPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2SslPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2SslPolicyFilters = map[string]string{
	"ciphers":       "description.SslPolicy.Ciphers",
	"og_account_id": "metadata.SourceID",
	"name":          "description.SslPolicy.Name",
	"ssl_protocols": "description.SslPolicy.SslProtocols",
	"title":         "description.SslPolicy.Name",
}

func ListElasticLoadBalancingV2SslPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2SslPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2SslPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2SslPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2SslPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2SslPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2SslPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticLoadBalancingV2SslPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticLoadBalancingV2SslPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2SslPolicy NewElasticLoadBalancingV2SslPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticLoadBalancingV2SslPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticLoadBalancingV2SslPolicyFilters = map[string]string{
	"ciphers":       "description.SslPolicy.Ciphers",
	"og_account_id": "metadata.SourceID",
	"name":          "description.SslPolicy.Name",
	"region":        "metadata.Region",
	"ssl_protocols": "description.SslPolicy.SslProtocols",
	"title":         "description.SslPolicy.Name",
}

func GetElasticLoadBalancingV2SslPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2SslPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2SslPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticLoadBalancingV2SslPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2SslPolicy =============================

// ==========================  START: ElasticLoadBalancingV2TargetGroup =============================

type ElasticLoadBalancingV2TargetGroup struct {
	Description   aws.ElasticLoadBalancingV2TargetGroupDescription `json:"description"`
	Metadata      aws.Metadata                                     `json:"metadata"`
	ResourceJobID int                                              `json:"resource_job_id"`
	SourceJobID   int                                              `json:"source_job_id"`
	ResourceType  string                                           `json:"resource_type"`
	SourceType    string                                           `json:"source_type"`
	ID            string                                           `json:"id"`
	ARN           string                                           `json:"arn"`
	SourceID      string                                           `json:"source_id"`
}

type ElasticLoadBalancingV2TargetGroupHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2TargetGroup `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type ElasticLoadBalancingV2TargetGroupHits struct {
	Total essdk.SearchTotal                      `json:"total"`
	Hits  []ElasticLoadBalancingV2TargetGroupHit `json:"hits"`
}

type ElasticLoadBalancingV2TargetGroupSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  ElasticLoadBalancingV2TargetGroupHits `json:"hits"`
}

type ElasticLoadBalancingV2TargetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2TargetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2TargetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_targetgroup", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2TargetGroupPaginator{}, err
	}

	p := ElasticLoadBalancingV2TargetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2TargetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2TargetGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticLoadBalancingV2TargetGroupPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2TargetGroup, error) {
	var response ElasticLoadBalancingV2TargetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2TargetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2TargetGroupFilters = map[string]string{
	"health_check_enabled":          "description.TargetGroup.HealthCheckEnabled",
	"health_check_interval_seconds": "description.TargetGroup.HealthCheckIntervalSeconds",
	"health_check_path":             "description.TargetGroup.HealthCheckPath",
	"health_check_port":             "description.TargetGroup.HealthCheckPort",
	"health_check_protocol":         "description.TargetGroup.HealthCheckProtocol",
	"health_check_timeout_seconds":  "description.TargetGroup.HealthCheckTimeoutSeconds",
	"healthy_threshold_count":       "description.TargetGroup.HealthyThresholdCount",
	"og_account_id":                 "metadata.SourceID",
	"load_balancer_arns":            "description.TargetGroup.LoadBalancerArns",
	"matcher_grpc_code":             "description.TargetGroup.Matcher.GrpcCode",
	"matcher_http_code":             "description.TargetGroup.Matcher.HttpCode",
	"port":                          "description.TargetGroup.Port",
	"protocol":                      "description.TargetGroup.Protocol",
	"tags_src":                      "description.Tags",
	"target_group_arn":              "description.TargetGroup.TargetGroupArn",
	"target_group_name":             "description.TargetGroup.TargetGroupName",
	"target_health_descriptions":    "description.Health",
	"target_type":                   "description.TargetGroup.TargetType",
	"title":                         "description.TargetGroup.TargetGroupName",
	"unhealthy_threshold_count":     "description.TargetGroup.UnhealthyThresholdCount",
	"vpc_id":                        "description.TargetGroup.VpcId",
}

func ListElasticLoadBalancingV2TargetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2TargetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2TargetGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2TargetGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2TargetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2TargetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2TargetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticLoadBalancingV2TargetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticLoadBalancingV2TargetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2TargetGroup NewElasticLoadBalancingV2TargetGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticLoadBalancingV2TargetGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticLoadBalancingV2TargetGroupFilters = map[string]string{
	"health_check_enabled":          "description.TargetGroup.HealthCheckEnabled",
	"health_check_interval_seconds": "description.TargetGroup.HealthCheckIntervalSeconds",
	"health_check_path":             "description.TargetGroup.HealthCheckPath",
	"health_check_port":             "description.TargetGroup.HealthCheckPort",
	"health_check_protocol":         "description.TargetGroup.HealthCheckProtocol",
	"health_check_timeout_seconds":  "description.TargetGroup.HealthCheckTimeoutSeconds",
	"healthy_threshold_count":       "description.TargetGroup.HealthyThresholdCount",
	"og_account_id":                 "metadata.SourceID",
	"load_balancer_arns":            "description.TargetGroup.LoadBalancerArns",
	"matcher_grpc_code":             "description.TargetGroup.Matcher.GrpcCode",
	"matcher_http_code":             "description.TargetGroup.Matcher.HttpCode",
	"port":                          "description.TargetGroup.Port",
	"protocol":                      "description.TargetGroup.Protocol",
	"tags_src":                      "description.Tags",
	"target_group_arn":              "description.TargetGroup.TargetGroupArn",
	"target_group_name":             "description.TargetGroup.TargetGroupName",
	"target_health_descriptions":    "description.Health",
	"target_type":                   "description.TargetGroup.TargetType",
	"title":                         "description.TargetGroup.TargetGroupName",
	"unhealthy_threshold_count":     "description.TargetGroup.UnhealthyThresholdCount",
	"vpc_id":                        "description.TargetGroup.VpcId",
}

func GetElasticLoadBalancingV2TargetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2TargetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2TargetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticLoadBalancingV2TargetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2TargetGroup =============================

// ==========================  START: ElasticLoadBalancingV2LoadBalancer =============================

type ElasticLoadBalancingV2LoadBalancer struct {
	Description   aws.ElasticLoadBalancingV2LoadBalancerDescription `json:"description"`
	Metadata      aws.Metadata                                      `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type ElasticLoadBalancingV2LoadBalancerHit struct {
	ID      string                             `json:"_id"`
	Score   float64                            `json:"_score"`
	Index   string                             `json:"_index"`
	Type    string                             `json:"_type"`
	Version int64                              `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2LoadBalancer `json:"_source"`
	Sort    []interface{}                      `json:"sort"`
}

type ElasticLoadBalancingV2LoadBalancerHits struct {
	Total essdk.SearchTotal                       `json:"total"`
	Hits  []ElasticLoadBalancingV2LoadBalancerHit `json:"hits"`
}

type ElasticLoadBalancingV2LoadBalancerSearchResponse struct {
	PitID string                                 `json:"pit_id"`
	Hits  ElasticLoadBalancingV2LoadBalancerHits `json:"hits"`
}

type ElasticLoadBalancingV2LoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2LoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2LoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_loadbalancer", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2LoadBalancerPaginator{}, err
	}

	p := ElasticLoadBalancingV2LoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2LoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2LoadBalancerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticLoadBalancingV2LoadBalancerPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2LoadBalancer, error) {
	var response ElasticLoadBalancingV2LoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2LoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2LoadBalancerFilters = map[string]string{
	"arn":                      "description.LoadBalancer.LoadBalancerArn",
	"availability_zones":       "description.LoadBalancer.AvailabilityZones",
	"canonical_hosted_zone_id": "description.LoadBalancer.CanonicalHostedZoneId",
	"created_time":             "description.LoadBalancer.CreatedTime",
	"customer_owned_ipv4_pool": "description.LoadBalancer.CustomerOwnedIpv4Pool",
	"dns_name":                 "description.LoadBalancer.DNSName",
	"ip_address_type":          "description.LoadBalancer.IpAddressType",
	"og_account_id":            "metadata.SourceID",
	"load_balancer_attributes": "description.Attributes",
	"name":                     "description.LoadBalancer.LoadBalancerName",
	"scheme":                   "description.LoadBalancer.Scheme",
	"security_groups":          "description.LoadBalancer.SecurityGroups",
	"state_code":               "description.LoadBalancer.State.Code",
	"state_reason":             "description.LoadBalancer.State.Reason",
	"tags_src":                 "description.Tags",
	"title":                    "description.LoadBalancer.LoadBalancerName",
	"type":                     "description.LoadBalancer.Type",
	"vpc_id":                   "description.LoadBalancer.VpcId",
}

func ListElasticLoadBalancingV2LoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2LoadBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2LoadBalancer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2LoadBalancer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2LoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2LoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2LoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticLoadBalancingV2LoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticLoadBalancingV2LoadBalancerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2LoadBalancer NewElasticLoadBalancingV2LoadBalancerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticLoadBalancingV2LoadBalancer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticLoadBalancingV2LoadBalancerFilters = map[string]string{
	"arn":                      "description.LoadBalancer.LoadBalancerArn",
	"availability_zones":       "description.LoadBalancer.AvailabilityZones",
	"canonical_hosted_zone_id": "description.LoadBalancer.CanonicalHostedZoneId",
	"created_time":             "description.LoadBalancer.CreatedTime",
	"customer_owned_ipv4_pool": "description.LoadBalancer.CustomerOwnedIpv4Pool",
	"dns_name":                 "description.LoadBalancer.DNSName",
	"ip_address_type":          "description.LoadBalancer.IpAddressType",
	"og_account_id":            "metadata.SourceID",
	"load_balancer_attributes": "description.Attributes",
	"name":                     "description.LoadBalancer.LoadBalancerName",
	"scheme":                   "description.LoadBalancer.Scheme",
	"security_groups":          "description.LoadBalancer.SecurityGroups",
	"state_code":               "description.LoadBalancer.State.Code",
	"state_reason":             "description.LoadBalancer.State.Reason",
	"tags_src":                 "description.Tags",
	"title":                    "description.LoadBalancer.LoadBalancerName",
	"type":                     "description.LoadBalancer.Type",
	"vpc_id":                   "description.LoadBalancer.VpcId",
}

func GetElasticLoadBalancingV2LoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2LoadBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2LoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticLoadBalancingV2LoadBalancerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2LoadBalancer =============================

// ==========================  START: ElasticLoadBalancingLoadBalancer =============================

type ElasticLoadBalancingLoadBalancer struct {
	Description   aws.ElasticLoadBalancingLoadBalancerDescription `json:"description"`
	Metadata      aws.Metadata                                    `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type ElasticLoadBalancingLoadBalancerHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  ElasticLoadBalancingLoadBalancer `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type ElasticLoadBalancingLoadBalancerHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []ElasticLoadBalancingLoadBalancerHit `json:"hits"`
}

type ElasticLoadBalancingLoadBalancerSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  ElasticLoadBalancingLoadBalancerHits `json:"hits"`
}

type ElasticLoadBalancingLoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingLoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingLoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancing_loadbalancer", filters, limit)
	if err != nil {
		return ElasticLoadBalancingLoadBalancerPaginator{}, err
	}

	p := ElasticLoadBalancingLoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingLoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingLoadBalancerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticLoadBalancingLoadBalancerPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingLoadBalancer, error) {
	var response ElasticLoadBalancingLoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingLoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingLoadBalancerFilters = map[string]string{
	"access_log_emit_interval":          "description.Attributes.AccessLog.EmitInterval",
	"access_log_enabled":                "description.Attributes.AccessLog.Enabled",
	"access_log_s3_bucket_name":         "description.Attributes.AccessLog.S3BucketName",
	"access_log_s3_bucket_prefix":       "description.Attributes.AccessLog.S3BucketPrefix",
	"additional_attributes":             "description.Attributes.AdditionalAttributes",
	"app_cookie_stickiness_policies":    "description.LoadBalancer.Policies.AppCookieStickinessPolicies",
	"arn":                               "arn",
	"availability_zones":                "description.LoadBalancer.AvailabilityZones",
	"backend_server_descriptions":       "description.LoadBalancer.BackendServerDescriptions",
	"canonical_hosted_zone_name":        "description.LoadBalancer.CanonicalHostedZoneName",
	"canonical_hosted_zone_name_id":     "description.LoadBalancer.CanonicalHostedZoneNameID",
	"connection_draining_enabled":       "description.Attributes.ConnectionDraining.Enabled",
	"connection_draining_timeout":       "description.Attributes.ConnectionDraining.Timeout",
	"connection_settings_idle_timeout":  "description.Attributes.ConnectionSettings.IdleTimeout",
	"created_time":                      "description.LoadBalancer.CreatedTime",
	"cross_zone_load_balancing_enabled": "description.Attributes.CrossZoneLoadBalancing.Enabled",
	"dns_name":                          "description.LoadBalancer.DNSName",
	"health_check_interval":             "description.LoadBalancer.HealthCheck.Interval",
	"health_check_target":               "description.LoadBalancer.HealthCheck.Target",
	"health_check_timeout":              "description.LoadBalancer.HealthCheck.Timeout",
	"healthy_threshold":                 "description.LoadBalancer.HealthCheck.HealthyThreshold",
	"instances":                         "description.LoadBalancer.Instances",
	"og_account_id":                     "metadata.SourceID",
	"lb_cookie_stickiness_policies":     "description.LoadBalancer.Policies.LBCookieStickinessPolicies",
	"listener_descriptions":             "description.LoadBalancer.ListenerDescriptions",
	"name":                              "description.LoadBalancer.LoadBalancerName",
	"other_policies":                    "description.LoadBalancer.Policies.OtherPolicies",
	"scheme":                            "description.LoadBalancer.Scheme",
	"security_groups":                   "description.LoadBalancer.SecurityGroups",
	"source_security_group_name":        "description.LoadBalancer.SourceSecurityGroup.GroupName",
	"source_security_group_owner_alias": "description.LoadBalancer.SourceSecurityGroup.OwnerAlias",
	"subnets":                           "description.LoadBalancer.Subnets",
	"tags_src":                          "description.Tags",
	"title":                             "description.LoadBalancer.LoadBalancerName",
	"unhealthy_threshold":               "description.LoadBalancer.HealthCheck.UnhealthyThreshold",
	"vpc_id":                            "description.LoadBalancer.VPCId",
}

func ListElasticLoadBalancingLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingLoadBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingLoadBalancer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingLoadBalancer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticLoadBalancingLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticLoadBalancingLoadBalancerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingLoadBalancer NewElasticLoadBalancingLoadBalancerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticLoadBalancingLoadBalancer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticLoadBalancingLoadBalancerFilters = map[string]string{
	"access_log_emit_interval":          "description.Attributes.AccessLog.EmitInterval",
	"access_log_enabled":                "description.Attributes.AccessLog.Enabled",
	"access_log_s3_bucket_name":         "description.Attributes.AccessLog.S3BucketName",
	"access_log_s3_bucket_prefix":       "description.Attributes.AccessLog.S3BucketPrefix",
	"additional_attributes":             "description.Attributes.AdditionalAttributes",
	"app_cookie_stickiness_policies":    "description.LoadBalancer.Policies.AppCookieStickinessPolicies",
	"arn":                               "arn",
	"availability_zones":                "description.LoadBalancer.AvailabilityZones",
	"backend_server_descriptions":       "description.LoadBalancer.BackendServerDescriptions",
	"canonical_hosted_zone_name":        "description.LoadBalancer.CanonicalHostedZoneName",
	"canonical_hosted_zone_name_id":     "description.LoadBalancer.CanonicalHostedZoneNameID",
	"connection_draining_enabled":       "description.Attributes.ConnectionDraining.Enabled",
	"connection_draining_timeout":       "description.Attributes.ConnectionDraining.Timeout",
	"connection_settings_idle_timeout":  "description.Attributes.ConnectionSettings.IdleTimeout",
	"created_time":                      "description.LoadBalancer.CreatedTime",
	"cross_zone_load_balancing_enabled": "description.Attributes.CrossZoneLoadBalancing.Enabled",
	"dns_name":                          "description.LoadBalancer.DNSName",
	"health_check_interval":             "description.LoadBalancer.HealthCheck.Interval",
	"health_check_target":               "description.LoadBalancer.HealthCheck.Target",
	"health_check_timeout":              "description.LoadBalancer.HealthCheck.Timeout",
	"healthy_threshold":                 "description.LoadBalancer.HealthCheck.HealthyThreshold",
	"instances":                         "description.LoadBalancer.Instances",
	"og_account_id":                     "metadata.SourceID",
	"lb_cookie_stickiness_policies":     "description.LoadBalancer.Policies.LBCookieStickinessPolicies",
	"listener_descriptions":             "description.LoadBalancer.ListenerDescriptions",
	"name":                              "description.LoadBalancer.LoadBalancerName",
	"other_policies":                    "description.LoadBalancer.Policies.OtherPolicies",
	"scheme":                            "description.LoadBalancer.Scheme",
	"security_groups":                   "description.LoadBalancer.SecurityGroups",
	"source_security_group_name":        "description.LoadBalancer.SourceSecurityGroup.GroupName",
	"source_security_group_owner_alias": "description.LoadBalancer.SourceSecurityGroup.OwnerAlias",
	"subnets":                           "description.LoadBalancer.Subnets",
	"tags_src":                          "description.Tags",
	"title":                             "description.LoadBalancer.LoadBalancerName",
	"unhealthy_threshold":               "description.LoadBalancer.HealthCheck.UnhealthyThreshold",
	"vpc_id":                            "description.LoadBalancer.VPCId",
}

func GetElasticLoadBalancingLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingLoadBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticLoadBalancingLoadBalancerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingLoadBalancer =============================

// ==========================  START: ElasticLoadBalancingV2Listener =============================

type ElasticLoadBalancingV2Listener struct {
	Description   aws.ElasticLoadBalancingV2ListenerDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type ElasticLoadBalancingV2ListenerHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2Listener `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type ElasticLoadBalancingV2ListenerHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []ElasticLoadBalancingV2ListenerHit `json:"hits"`
}

type ElasticLoadBalancingV2ListenerSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  ElasticLoadBalancingV2ListenerHits `json:"hits"`
}

type ElasticLoadBalancingV2ListenerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2ListenerPaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2ListenerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_listener", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2ListenerPaginator{}, err
	}

	p := ElasticLoadBalancingV2ListenerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2ListenerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2ListenerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticLoadBalancingV2ListenerPaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2Listener, error) {
	var response ElasticLoadBalancingV2ListenerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2Listener
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2ListenerFilters = map[string]string{
	"alpn_policy":       "description.Listener.AlpnPolicy",
	"arn":               "description.Listener.ListenerArn",
	"certificates":      "description.Listener.Certificates",
	"default_actions":   "description.Listener.DefaultActions",
	"og_account_id":     "metadata.SourceID",
	"load_balancer_arn": "description.Listener.LoadBalancerArn",
	"port":              "description.Listener.Port",
	"protocol":          "description.Listener.Protocol",
	"ssl_policy":        "description.Listener.SslPolicy",
}

func ListElasticLoadBalancingV2Listener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2Listener")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Listener NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Listener NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Listener GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Listener GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Listener GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticLoadBalancingV2ListenerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticLoadBalancingV2ListenerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Listener NewElasticLoadBalancingV2ListenerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Listener paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticLoadBalancingV2ListenerFilters = map[string]string{
	"alpn_policy":       "description.Listener.AlpnPolicy",
	"arn":               "description.Listener.ListenerArn",
	"certificates":      "description.Listener.Certificates",
	"default_actions":   "description.Listener.DefaultActions",
	"og_account_id":     "metadata.SourceID",
	"load_balancer_arn": "description.Listener.LoadBalancerArn",
	"port":              "description.Listener.Port",
	"protocol":          "description.Listener.Protocol",
	"ssl_policy":        "description.Listener.SslPolicy",
}

func GetElasticLoadBalancingV2Listener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2Listener")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2ListenerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticLoadBalancingV2ListenerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2Listener =============================

// ==========================  START: ElasticLoadBalancingV2Rule =============================

type ElasticLoadBalancingV2Rule struct {
	Description   aws.ElasticLoadBalancingV2RuleDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type ElasticLoadBalancingV2RuleHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  ElasticLoadBalancingV2Rule `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type ElasticLoadBalancingV2RuleHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []ElasticLoadBalancingV2RuleHit `json:"hits"`
}

type ElasticLoadBalancingV2RuleSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  ElasticLoadBalancingV2RuleHits `json:"hits"`
}

type ElasticLoadBalancingV2RulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewElasticLoadBalancingV2RulePaginator(filters []essdk.BoolFilter, limit *int64) (ElasticLoadBalancingV2RulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_elasticloadbalancingv2_listenerrule", filters, limit)
	if err != nil {
		return ElasticLoadBalancingV2RulePaginator{}, err
	}

	p := ElasticLoadBalancingV2RulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ElasticLoadBalancingV2RulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ElasticLoadBalancingV2RulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ElasticLoadBalancingV2RulePaginator) NextPage(ctx context.Context) ([]ElasticLoadBalancingV2Rule, error) {
	var response ElasticLoadBalancingV2RuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ElasticLoadBalancingV2Rule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listElasticLoadBalancingV2RuleFilters = map[string]string{
	"arn":           "description.Rule.RuleArn",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Rule.RuleArn",
}

func ListElasticLoadBalancingV2Rule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListElasticLoadBalancingV2Rule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Rule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Rule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Rule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Rule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Rule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewElasticLoadBalancingV2RulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listElasticLoadBalancingV2RuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Rule NewElasticLoadBalancingV2RulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListElasticLoadBalancingV2Rule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getElasticLoadBalancingV2RuleFilters = map[string]string{
	"arn":           "description.Rule.RuleArn",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Rule.RuleArn",
}

func GetElasticLoadBalancingV2Rule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetElasticLoadBalancingV2Rule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewElasticLoadBalancingV2RulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getElasticLoadBalancingV2RuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ElasticLoadBalancingV2Rule =============================

// ==========================  START: FSXFileSystem =============================

type FSXFileSystem struct {
	Description   aws.FSXFileSystemDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type FSXFileSystemHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXFileSystem `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXFileSystemHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []FSXFileSystemHit `json:"hits"`
}

type FSXFileSystemSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  FSXFileSystemHits `json:"hits"`
}

type FSXFileSystemPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXFileSystemPaginator(filters []essdk.BoolFilter, limit *int64) (FSXFileSystemPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_filesystem", filters, limit)
	if err != nil {
		return FSXFileSystemPaginator{}, err
	}

	p := FSXFileSystemPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXFileSystemPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXFileSystemPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FSXFileSystemPaginator) NextPage(ctx context.Context) ([]FSXFileSystem, error) {
	var response FSXFileSystemSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXFileSystem
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXFileSystemFilters = map[string]string{
	"administrative_actions":   "description.FileSystem.AdministrativeActions",
	"arn":                      "description.FileSystem.ResourceARN",
	"creation_time":            "description.FileSystem.CreationTime",
	"dns_name":                 "description.FileSystem.DNSName",
	"failure_details":          "description.FileSystem.FailureDetails",
	"file_system_id":           "description.FileSystem.FileSystemId",
	"file_system_type":         "description.FileSystem.FileSystemType",
	"file_system_type_version": "description.FileSystem.FileSystemTypeVersion",
	"og_account_id":            "metadata.SourceID",
	"kms_key_id":               "description.FileSystem.KmsKeyId",
	"lifecycle":                "description.FileSystem.Lifecycle",
	"lustre_configuration":     "description.FileSystem.LustreConfiguration",
	"network_interface_ids":    "description.FileSystem.NetworkInterfaceIds",
	"ontap_configuration":      "description.FileSystem.OntapConfiguration",
	"open_zfs_configuration":   "description.FileSystem.OpenZFSConfiguration",
	"owner_id":                 "description.FileSystem.OwnerId",
	"storage_capacity":         "description.FileSystem.StorageCapacity",
	"storage_type":             "description.FileSystem.StorageType",
	"subnet_ids":               "description.FileSystem.SubnetIds",
	"tags_src":                 "description.FileSystem.Tags",
	"vpc_id":                   "description.FileSystem.VpcId",
	"windows_configuration":    "description.FileSystem.WindowsConfiguration",
}

func ListFSXFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXFileSystem")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXFileSystem NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXFileSystem NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXFileSystem GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXFileSystem GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXFileSystem GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFSXFileSystemPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFSXFileSystemFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXFileSystem NewFSXFileSystemPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFSXFileSystem paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFSXFileSystemFilters = map[string]string{
	"administrative_actions":   "description.FileSystem.AdministrativeActions",
	"arn":                      "description.FileSystem.ResourceARN",
	"creation_time":            "description.FileSystem.CreationTime",
	"dns_name":                 "description.FileSystem.DNSName",
	"failure_details":          "description.FileSystem.FailureDetails",
	"file_system_id":           "description.FileSystem.FileSystemId",
	"file_system_type":         "description.FileSystem.FileSystemType",
	"file_system_type_version": "description.FileSystem.FileSystemTypeVersion",
	"og_account_id":            "metadata.SourceID",
	"kms_key_id":               "description.FileSystem.KmsKeyId",
	"lifecycle":                "description.FileSystem.Lifecycle",
	"lustre_configuration":     "description.FileSystem.LustreConfiguration",
	"network_interface_ids":    "description.FileSystem.NetworkInterfaceIds",
	"ontap_configuration":      "description.FileSystem.OntapConfiguration",
	"open_zfs_configuration":   "description.FileSystem.OpenZFSConfiguration",
	"owner_id":                 "description.FileSystem.OwnerId",
	"storage_capacity":         "description.FileSystem.StorageCapacity",
	"storage_type":             "description.FileSystem.StorageType",
	"subnet_ids":               "description.FileSystem.SubnetIds",
	"tags_src":                 "description.FileSystem.Tags",
	"vpc_id":                   "description.FileSystem.VpcId",
	"windows_configuration":    "description.FileSystem.WindowsConfiguration",
}

func GetFSXFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXFileSystem")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFSXFileSystemPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFSXFileSystemFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FSXFileSystem =============================

// ==========================  START: FSXStorageVirtualMachine =============================

type FSXStorageVirtualMachine struct {
	Description   aws.FSXStorageVirtualMachineDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type FSXStorageVirtualMachineHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  FSXStorageVirtualMachine `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type FSXStorageVirtualMachineHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []FSXStorageVirtualMachineHit `json:"hits"`
}

type FSXStorageVirtualMachineSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  FSXStorageVirtualMachineHits `json:"hits"`
}

type FSXStorageVirtualMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXStorageVirtualMachinePaginator(filters []essdk.BoolFilter, limit *int64) (FSXStorageVirtualMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_storagevirtualmachine", filters, limit)
	if err != nil {
		return FSXStorageVirtualMachinePaginator{}, err
	}

	p := FSXStorageVirtualMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXStorageVirtualMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXStorageVirtualMachinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FSXStorageVirtualMachinePaginator) NextPage(ctx context.Context) ([]FSXStorageVirtualMachine, error) {
	var response FSXStorageVirtualMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXStorageVirtualMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXStorageVirtualMachineFilters = map[string]string{
	"og_account_id":              "metadata.SourceID",
	"name":                       "description.StorageVirtualMachine.Name",
	"resource_arn":               "description.StorageVirtualMachine.ResourceARN",
	"storage_virtual_machine_id": "description.StorageVirtualMachine.StorageVirtualMachineId",
	"title":                      "description.StorageVirtualMachine.StorageVirtualMachineId",
}

func ListFSXStorageVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXStorageVirtualMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXStorageVirtualMachine NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXStorageVirtualMachine NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXStorageVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXStorageVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXStorageVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFSXStorageVirtualMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listFSXStorageVirtualMachineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXStorageVirtualMachine NewFSXStorageVirtualMachinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFSXStorageVirtualMachine paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFSXStorageVirtualMachineFilters = map[string]string{
	"og_account_id":              "metadata.SourceID",
	"name":                       "description.StorageVirtualMachine.Name",
	"resource_arn":               "description.StorageVirtualMachine.ResourceARN",
	"storage_virtual_machine_id": "description.StorageVirtualMachine.StorageVirtualMachineId",
	"title":                      "description.StorageVirtualMachine.StorageVirtualMachineId",
}

func GetFSXStorageVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXStorageVirtualMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFSXStorageVirtualMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getFSXStorageVirtualMachineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FSXStorageVirtualMachine =============================

// ==========================  START: FSXTask =============================

type FSXTask struct {
	Description   aws.FSXTaskDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type FSXTaskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXTask       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXTaskHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FSXTaskHit      `json:"hits"`
}

type FSXTaskSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  FSXTaskHits `json:"hits"`
}

type FSXTaskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXTaskPaginator(filters []essdk.BoolFilter, limit *int64) (FSXTaskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_task", filters, limit)
	if err != nil {
		return FSXTaskPaginator{}, err
	}

	p := FSXTaskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXTaskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXTaskPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FSXTaskPaginator) NextPage(ctx context.Context) ([]FSXTask, error) {
	var response FSXTaskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXTask
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXTaskFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"resource_arn":  "description.Task.ResourceARN",
	"task_id":       "description.Task.TaskId",
	"title":         "description.Task.TaskId",
}

func ListFSXTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXTask")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXTask NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXTask NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFSXTaskPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFSXTaskFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXTask NewFSXTaskPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFSXTask paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFSXTaskFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"resource_arn":  "description.Task.ResourceARN",
	"task_id":       "description.Task.TaskId",
	"title":         "description.Task.TaskId",
}

func GetFSXTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXTask")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFSXTaskPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFSXTaskFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FSXTask =============================

// ==========================  START: FSXVolume =============================

type FSXVolume struct {
	Description   aws.FSXVolumeDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type FSXVolumeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXVolume     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXVolumeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FSXVolumeHit    `json:"hits"`
}

type FSXVolumeSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  FSXVolumeHits `json:"hits"`
}

type FSXVolumePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXVolumePaginator(filters []essdk.BoolFilter, limit *int64) (FSXVolumePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_volume", filters, limit)
	if err != nil {
		return FSXVolumePaginator{}, err
	}

	p := FSXVolumePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXVolumePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXVolumePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FSXVolumePaginator) NextPage(ctx context.Context) ([]FSXVolume, error) {
	var response FSXVolumeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXVolume
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXVolumeFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"name":          "description.Volume.Name",
	"resource_arn":  "description.Volume.ResourceARN",
	"title":         "description.Volume.VolumeId",
	"volume_id":     "description.Volume.VolumeId",
}

func ListFSXVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXVolume")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXVolume NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXVolume NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFSXVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, listFSXVolumeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXVolume NewFSXVolumePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFSXVolume paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFSXVolumeFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"name":          "description.Volume.Name",
	"resource_arn":  "description.Volume.ResourceARN",
	"title":         "description.Volume.VolumeId",
	"volume_id":     "description.Volume.VolumeId",
}

func GetFSXVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXVolume")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFSXVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, getFSXVolumeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FSXVolume =============================

// ==========================  START: FSXSnapshot =============================

type FSXSnapshot struct {
	Description   aws.FSXSnapshotDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type FSXSnapshotHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FSXSnapshot   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FSXSnapshotHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FSXSnapshotHit  `json:"hits"`
}

type FSXSnapshotSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  FSXSnapshotHits `json:"hits"`
}

type FSXSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFSXSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (FSXSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_fsx_snapshot", filters, limit)
	if err != nil {
		return FSXSnapshotPaginator{}, err
	}

	p := FSXSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FSXSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FSXSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FSXSnapshotPaginator) NextPage(ctx context.Context) ([]FSXSnapshot, error) {
	var response FSXSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FSXSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFSXSnapshotFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"name":          "description.Snapshot.Name",
	"resource_arn":  "description.Snapshot.ResourceARN",
	"snapshot_id":   "description.Snapshot.SnapshotId",
	"title":         "description.Snapshot.SnapshotId",
}

func ListFSXSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFSXSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFSXSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFSXSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFSXSnapshot NewFSXSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFSXSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFSXSnapshotFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"name":          "description.Snapshot.Name",
	"resource_arn":  "description.Snapshot.ResourceARN",
	"snapshot_id":   "description.Snapshot.SnapshotId",
	"title":         "description.Snapshot.SnapshotId",
}

func GetFSXSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFSXSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFSXSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFSXSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FSXSnapshot =============================

// ==========================  START: ApplicationAutoScalingTarget =============================

type ApplicationAutoScalingTarget struct {
	Description   aws.ApplicationAutoScalingTargetDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type ApplicationAutoScalingTargetHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  ApplicationAutoScalingTarget `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type ApplicationAutoScalingTargetHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []ApplicationAutoScalingTargetHit `json:"hits"`
}

type ApplicationAutoScalingTargetSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  ApplicationAutoScalingTargetHits `json:"hits"`
}

type ApplicationAutoScalingTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApplicationAutoScalingTargetPaginator(filters []essdk.BoolFilter, limit *int64) (ApplicationAutoScalingTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_applicationautoscaling_target", filters, limit)
	if err != nil {
		return ApplicationAutoScalingTargetPaginator{}, err
	}

	p := ApplicationAutoScalingTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApplicationAutoScalingTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApplicationAutoScalingTargetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApplicationAutoScalingTargetPaginator) NextPage(ctx context.Context) ([]ApplicationAutoScalingTarget, error) {
	var response ApplicationAutoScalingTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApplicationAutoScalingTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApplicationAutoScalingTargetFilters = map[string]string{
	"creation_time":      "description.ScalableTarget.CreationTime",
	"og_account_id":      "metadata.SourceID",
	"max_capacity":       "description.ScalableTarget.MaxCapacity",
	"min_capacity":       "description.ScalableTarget.MinCapacity",
	"resource_id":        "description.ScalableTarget.ResourceId",
	"role_arn":           "description.ScalableTarget.RoleARN",
	"scalable_dimension": "description.ScalableTarget.ScalableDimension",
	"service_namespace":  "description.ScalableTarget.ServiceNamespace",
	"suspended_state":    "description.ScalableTarget.SuspendedState",
	"title":              "description.ScalableTarget.ResourceId",
}

func ListApplicationAutoScalingTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApplicationAutoScalingTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingTarget NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingTarget NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApplicationAutoScalingTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApplicationAutoScalingTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingTarget NewApplicationAutoScalingTargetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApplicationAutoScalingTarget paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApplicationAutoScalingTargetFilters = map[string]string{
	"creation_time":      "description.ScalableTarget.CreationTime",
	"og_account_id":      "metadata.SourceID",
	"max_capacity":       "description.ScalableTarget.MaxCapacity",
	"min_capacity":       "description.ScalableTarget.MinCapacity",
	"resource_id":        "description.ScalableTarget.ResourceId",
	"role_arn":           "description.ScalableTarget.RoleARN",
	"scalable_dimension": "description.ScalableTarget.ScalableDimension",
	"service_namespace":  "description.ScalableTarget.ServiceNamespace",
	"suspended_state":    "description.ScalableTarget.SuspendedState",
	"title":              "description.ScalableTarget.ResourceId",
}

func GetApplicationAutoScalingTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApplicationAutoScalingTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApplicationAutoScalingTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApplicationAutoScalingTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApplicationAutoScalingTarget =============================

// ==========================  START: ApplicationAutoScalingPolicy =============================

type ApplicationAutoScalingPolicy struct {
	Description   aws.ApplicationAutoScalingPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type ApplicationAutoScalingPolicyHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  ApplicationAutoScalingPolicy `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type ApplicationAutoScalingPolicyHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []ApplicationAutoScalingPolicyHit `json:"hits"`
}

type ApplicationAutoScalingPolicySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  ApplicationAutoScalingPolicyHits `json:"hits"`
}

type ApplicationAutoScalingPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApplicationAutoScalingPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (ApplicationAutoScalingPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_applicationautoscaling_policy", filters, limit)
	if err != nil {
		return ApplicationAutoScalingPolicyPaginator{}, err
	}

	p := ApplicationAutoScalingPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApplicationAutoScalingPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApplicationAutoScalingPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApplicationAutoScalingPolicyPaginator) NextPage(ctx context.Context) ([]ApplicationAutoScalingPolicy, error) {
	var response ApplicationAutoScalingPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApplicationAutoScalingPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApplicationAutoScalingPolicyFilters = map[string]string{
	"alarms":                            "description.ScalablePolicy.Alarms",
	"creation_time":                     "description.ScalablePolicy.CreationTime",
	"og_account_id":                     "metadata.SourceID",
	"policy_arn":                        "description.ScalablePolicy.PolicyARN",
	"policy_name":                       "description.ScalablePolicy.PolicyARN",
	"policy_type":                       "description.ScalablePolicy.PolicyType",
	"resource_id":                       "description.ScalablePolicy.ResourceId",
	"scalable_dimension":                "description.ScalablePolicy.ScalableDimension",
	"service_namespace":                 "description.ScalablePolicy.ServiceNamespace",
	"step_scaling_policy_configuration": "description.ScalablePolicy.StepScalingPolicyConfiguration",
	"target_tracking_scaling_policy_configuration": "description.ScalablePolicy.TargetTrackingScalingPolicyConfiguration",
	"title": "description.ScalablePolicy.ResourceId",
}

func ListApplicationAutoScalingPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApplicationAutoScalingPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApplicationAutoScalingPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApplicationAutoScalingPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationAutoScalingPolicy NewApplicationAutoScalingPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApplicationAutoScalingPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApplicationAutoScalingPolicyFilters = map[string]string{
	"alarms":                            "description.ScalablePolicy.Alarms",
	"creation_time":                     "description.ScalablePolicy.CreationTime",
	"og_account_id":                     "metadata.SourceID",
	"policy_arn":                        "description.ScalablePolicy.PolicyARN",
	"policy_name":                       "description.ScalablePolicy.PolicyARN",
	"policy_type":                       "description.ScalablePolicy.PolicyType",
	"resource_id":                       "description.ScalablePolicy.ResourceId",
	"scalable_dimension":                "description.ScalablePolicy.ScalableDimension",
	"service_namespace":                 "description.ScalablePolicy.ServiceNamespace",
	"step_scaling_policy_configuration": "description.ScalablePolicy.StepScalingPolicyConfiguration",
	"target_tracking_scaling_policy_configuration": "description.ScalablePolicy.TargetTrackingScalingPolicyConfiguration",
	"title": "description.ScalablePolicy.ResourceId",
}

func GetApplicationAutoScalingPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApplicationAutoScalingPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApplicationAutoScalingPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApplicationAutoScalingPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApplicationAutoScalingPolicy =============================

// ==========================  START: AutoScalingGroup =============================

type AutoScalingGroup struct {
	Description   aws.AutoScalingGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type AutoScalingGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AutoScalingGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AutoScalingGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []AutoScalingGroupHit `json:"hits"`
}

type AutoScalingGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AutoScalingGroupHits `json:"hits"`
}

type AutoScalingGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutoScalingGroupPaginator(filters []essdk.BoolFilter, limit *int64) (AutoScalingGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_autoscaling_autoscalinggroup", filters, limit)
	if err != nil {
		return AutoScalingGroupPaginator{}, err
	}

	p := AutoScalingGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutoScalingGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutoScalingGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AutoScalingGroupPaginator) NextPage(ctx context.Context) ([]AutoScalingGroup, error) {
	var response AutoScalingGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutoScalingGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutoScalingGroupFilters = map[string]string{
	"autoscaling_group_arn":                       "description.AutoScalingGroup.AutoScalingGroupARN",
	"availability_zones":                          "description.AutoScalingGroup.AvailabilityZones",
	"created_time":                                "description.AutoScalingGroup.CreatedTime",
	"default_cooldown":                            "description.AutoScalingGroup.DefaultCooldown",
	"desired_capacity":                            "description.AutoScalingGroup.DesiredCapacity",
	"enabled_metrics":                             "description.AutoScalingGroup.EnabledMetrics",
	"health_check_grace_period":                   "description.AutoScalingGroup.HealthCheckGracePeriod",
	"health_check_type":                           "description.AutoScalingGroup.HealthCheckType",
	"instances":                                   "description.AutoScalingGroup.Instances",
	"og_account_id":                               "metadata.SourceID",
	"launch_configuration_name":                   "description.AutoScalingGroup.LaunchConfigurationName",
	"launch_template_id":                          "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateId",
	"launch_template_name":                        "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateName",
	"launch_template_version":                     "description.AutoScalingGroup.LaunchTemplate.Version",
	"load_balancer_names":                         "description.AutoScalingGroup.LoadBalancerNames",
	"max_instance_lifetime":                       "description.AutoScalingGroup.MaxInstanceLifetime",
	"max_size":                                    "description.AutoScalingGroup.MaxSize",
	"min_size":                                    "description.AutoScalingGroup.MinSize",
	"mixed_instances_policy_launch_template_id":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateId",
	"mixed_instances_policy_launch_template_name": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName",
	"mixed_instances_policy_launch_template_overrides": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.Overrides",
	"mixed_instances_policy_launch_template_version":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version",
	"name":                                     "description.AutoScalingGroup.AutoScalingGroupName",
	"new_instances_protected_from_scale_in":    "description.AutoScalingGroup.NewInstancesProtectedFromScaleIn",
	"on_demand_allocation_strategy":            "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy",
	"on_demand_base_capacity":                  "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity",
	"on_demand_percentage_above_base_capacity": "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity",
	"placement_group":                          "description.AutoScalingGroup.PlacementGroup",
	"policies":                                 "description.Policies",
	"service_linked_role_arn":                  "description.AutoScalingGroup.ServiceLinkedRoleARN",
	"spot_allocation_strategy":                 "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy",
	"spot_instance_pools":                      "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools",
	"spot_max_price":                           "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice",
	"status":                                   "description.AutoScalingGroup.Status",
	"suspended_processes":                      "description.AutoScalingGroup.SuspendedProcesses",
	"tags_src":                                 "description.AutoScalingGroup.Tags",
	"target_group_arns":                        "description.AutoScalingGroup.TargetGroupARNs",
	"termination_policies":                     "description.AutoScalingGroup.TerminationPolicies",
	"title":                                    "description.AutoScalingGroup.AutoScalingGroupName",
	"vpc_zone_identifier":                      "description.AutoScalingGroup.VPCZoneIdentifier",
}

func ListAutoScalingGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutoScalingGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAutoScalingGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAutoScalingGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingGroup NewAutoScalingGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAutoScalingGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAutoScalingGroupFilters = map[string]string{
	"autoscaling_group_arn":                       "description.AutoScalingGroup.AutoScalingGroupARN",
	"availability_zones":                          "description.AutoScalingGroup.AvailabilityZones",
	"created_time":                                "description.AutoScalingGroup.CreatedTime",
	"default_cooldown":                            "description.AutoScalingGroup.DefaultCooldown",
	"desired_capacity":                            "description.AutoScalingGroup.DesiredCapacity",
	"enabled_metrics":                             "description.AutoScalingGroup.EnabledMetrics",
	"health_check_grace_period":                   "description.AutoScalingGroup.HealthCheckGracePeriod",
	"health_check_type":                           "description.AutoScalingGroup.HealthCheckType",
	"instances":                                   "description.AutoScalingGroup.Instances",
	"og_account_id":                               "metadata.SourceID",
	"launch_configuration_name":                   "description.AutoScalingGroup.LaunchConfigurationName",
	"launch_template_id":                          "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateId",
	"launch_template_name":                        "description.AutoScalingGroup.LaunchTemplate.LaunchTemplateName",
	"launch_template_version":                     "description.AutoScalingGroup.LaunchTemplate.Version",
	"load_balancer_names":                         "description.AutoScalingGroup.LoadBalancerNames",
	"max_instance_lifetime":                       "description.AutoScalingGroup.MaxInstanceLifetime",
	"max_size":                                    "description.AutoScalingGroup.MaxSize",
	"min_size":                                    "description.AutoScalingGroup.MinSize",
	"mixed_instances_policy_launch_template_id":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateId",
	"mixed_instances_policy_launch_template_name": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.LaunchTemplateName",
	"mixed_instances_policy_launch_template_overrides": "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.Overrides",
	"mixed_instances_policy_launch_template_version":   "description.AutoScalingGroup.MixedInstancesPolicy.LaunchTemplate.LaunchTemplateSpecification.Version",
	"name":                                     "description.AutoScalingGroup.AutoScalingGroupName",
	"new_instances_protected_from_scale_in":    "description.AutoScalingGroup.NewInstancesProtectedFromScaleIn",
	"on_demand_allocation_strategy":            "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandAllocationStrategy",
	"on_demand_base_capacity":                  "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandBaseCapacity",
	"on_demand_percentage_above_base_capacity": "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.OnDemandPercentageAboveBaseCapacity",
	"placement_group":                          "description.AutoScalingGroup.PlacementGroup",
	"policies":                                 "description.Policies",
	"service_linked_role_arn":                  "description.AutoScalingGroup.ServiceLinkedRoleARN",
	"spot_allocation_strategy":                 "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotAllocationStrategy",
	"spot_instance_pools":                      "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotInstancePools",
	"spot_max_price":                           "description.AutoScalingGroup.MixedInstancesPolicy.InstancesDistribution.SpotMaxPrice",
	"status":                                   "description.AutoScalingGroup.Status",
	"suspended_processes":                      "description.AutoScalingGroup.SuspendedProcesses",
	"tags_src":                                 "description.AutoScalingGroup.Tags",
	"target_group_arns":                        "description.AutoScalingGroup.TargetGroupARNs",
	"termination_policies":                     "description.AutoScalingGroup.TerminationPolicies",
	"title":                                    "description.AutoScalingGroup.AutoScalingGroupName",
	"vpc_zone_identifier":                      "description.AutoScalingGroup.VPCZoneIdentifier",
}

func GetAutoScalingGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutoScalingGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAutoScalingGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAutoScalingGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AutoScalingGroup =============================

// ==========================  START: AutoScalingLaunchConfiguration =============================

type AutoScalingLaunchConfiguration struct {
	Description   aws.AutoScalingLaunchConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type AutoScalingLaunchConfigurationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  AutoScalingLaunchConfiguration `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type AutoScalingLaunchConfigurationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []AutoScalingLaunchConfigurationHit `json:"hits"`
}

type AutoScalingLaunchConfigurationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  AutoScalingLaunchConfigurationHits `json:"hits"`
}

type AutoScalingLaunchConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutoScalingLaunchConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (AutoScalingLaunchConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_autoscaling_launchconfiguration", filters, limit)
	if err != nil {
		return AutoScalingLaunchConfigurationPaginator{}, err
	}

	p := AutoScalingLaunchConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutoScalingLaunchConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutoScalingLaunchConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AutoScalingLaunchConfigurationPaginator) NextPage(ctx context.Context) ([]AutoScalingLaunchConfiguration, error) {
	var response AutoScalingLaunchConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutoScalingLaunchConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutoScalingLaunchConfigurationFilters = map[string]string{
	"associate_public_ip_address":             "description.LaunchConfiguration.AssociatePublicIpAddress",
	"block_device_mappings":                   "description.LaunchConfiguration.BlockDeviceMappings",
	"classic_link_vpc_id":                     "description.LaunchConfiguration.ClassicLinkVPCId",
	"classic_link_vpc_security_groups":        "description.LaunchConfiguration.ClassicLinkVPCSecurityGroups",
	"created_time":                            "description.LaunchConfiguration.CreatedTime",
	"ebs_optimized":                           "description.LaunchConfiguration.EbsOptimized",
	"iam_instance_profile":                    "description.LaunchConfiguration.IamInstanceProfile",
	"image_id":                                "description.LaunchConfiguration.ImageId",
	"instance_monitoring_enabled":             "description.LaunchConfiguration.InstanceMonitoring.Enabled",
	"instance_type":                           "description.LaunchConfiguration.InstanceType",
	"og_account_id":                           "metadata.SourceID",
	"kernel_id":                               "description.LaunchConfiguration.KernelId",
	"key_name":                                "description.LaunchConfiguration.KeyName",
	"launch_configuration_arn":                "description.LaunchConfiguration.LaunchConfigurationARN",
	"metadata_options_http_endpoint":          "description.LaunchConfiguration.MetadataOptions.HttpEndpoint",
	"metadata_options_http_tokens":            "description.LaunchConfiguration.MetadataOptions.HttpTokens",
	"metadata_options_put_response_hop_limit": "description.LaunchConfiguration.MetadataOptions.HttpPutResponseHopLimit",
	"name":              "description.LaunchConfiguration.LaunchConfigurationName",
	"placement_tenancy": "description.LaunchConfiguration.PlacementTenancy",
	"ramdisk_id":        "description.LaunchConfiguration.RamdiskId",
	"security_groups":   "description.LaunchConfiguration.SecurityGroups",
	"spot_price":        "description.LaunchConfiguration.SpotPrice",
	"title":             "description.LaunchConfiguration.LaunchConfigurationName",
}

func ListAutoScalingLaunchConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutoScalingLaunchConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingLaunchConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingLaunchConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingLaunchConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingLaunchConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingLaunchConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAutoScalingLaunchConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAutoScalingLaunchConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoScalingLaunchConfiguration NewAutoScalingLaunchConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAutoScalingLaunchConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAutoScalingLaunchConfigurationFilters = map[string]string{
	"associate_public_ip_address":             "description.LaunchConfiguration.AssociatePublicIpAddress",
	"block_device_mappings":                   "description.LaunchConfiguration.BlockDeviceMappings",
	"classic_link_vpc_id":                     "description.LaunchConfiguration.ClassicLinkVPCId",
	"classic_link_vpc_security_groups":        "description.LaunchConfiguration.ClassicLinkVPCSecurityGroups",
	"created_time":                            "description.LaunchConfiguration.CreatedTime",
	"ebs_optimized":                           "description.LaunchConfiguration.EbsOptimized",
	"iam_instance_profile":                    "description.LaunchConfiguration.IamInstanceProfile",
	"image_id":                                "description.LaunchConfiguration.ImageId",
	"instance_monitoring_enabled":             "description.LaunchConfiguration.InstanceMonitoring.Enabled",
	"instance_type":                           "description.LaunchConfiguration.InstanceType",
	"og_account_id":                           "metadata.SourceID",
	"kernel_id":                               "description.LaunchConfiguration.KernelId",
	"key_name":                                "description.LaunchConfiguration.KeyName",
	"launch_configuration_arn":                "description.LaunchConfiguration.LaunchConfigurationARN",
	"metadata_options_http_endpoint":          "description.LaunchConfiguration.MetadataOptions.HttpEndpoint",
	"metadata_options_http_tokens":            "description.LaunchConfiguration.MetadataOptions.HttpTokens",
	"metadata_options_put_response_hop_limit": "description.LaunchConfiguration.MetadataOptions.HttpPutResponseHopLimit",
	"name":              "description.LaunchConfiguration.LaunchConfigurationName",
	"placement_tenancy": "description.LaunchConfiguration.PlacementTenancy",
	"ramdisk_id":        "description.LaunchConfiguration.RamdiskId",
	"security_groups":   "description.LaunchConfiguration.SecurityGroups",
	"spot_price":        "description.LaunchConfiguration.SpotPrice",
	"title":             "description.LaunchConfiguration.LaunchConfigurationName",
}

func GetAutoScalingLaunchConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutoScalingLaunchConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAutoScalingLaunchConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAutoScalingLaunchConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AutoScalingLaunchConfiguration =============================

// ==========================  START: CertificateManagerCertificate =============================

type CertificateManagerCertificate struct {
	Description   aws.CertificateManagerCertificateDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CertificateManagerCertificateHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CertificateManagerCertificate `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CertificateManagerCertificateHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CertificateManagerCertificateHit `json:"hits"`
}

type CertificateManagerCertificateSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CertificateManagerCertificateHits `json:"hits"`
}

type CertificateManagerCertificatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCertificateManagerCertificatePaginator(filters []essdk.BoolFilter, limit *int64) (CertificateManagerCertificatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_certificatemanager_certificate", filters, limit)
	if err != nil {
		return CertificateManagerCertificatePaginator{}, err
	}

	p := CertificateManagerCertificatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CertificateManagerCertificatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CertificateManagerCertificatePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CertificateManagerCertificatePaginator) NextPage(ctx context.Context) ([]CertificateManagerCertificate, error) {
	var response CertificateManagerCertificateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CertificateManagerCertificate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCertificateManagerCertificateFilters = map[string]string{
	"certificate":       "description.Attributes.Certificate",
	"certificate_arn":   "description.Certificate.CertificateArn",
	"certificate_chain": "description.Attributes.CertificateChain",
	"certificate_transparency_logging_preference": "description.Certificate.Options.CertificateTransparencyLoggingPreference",
	"created_at":                "description.Certificate.CreatedAt",
	"domain_name":               "description.Certificate.DomainName",
	"domain_validation_options": "description.Certificate.DomainValidationOptions",
	"extended_key_usages":       "description.Certificate.ExtendedKeyUsages",
	"failure_reason":            "description.Certificate.FailureReason",
	"imported_at":               "description.Certificate.ImportedAt",
	"in_use_by":                 "description.Certificate.InUseBy",
	"issued_at":                 "description.Certificate.IssuedAt",
	"issuer":                    "description.Certificate.Issuer",
	"og_account_id":             "metadata.SourceID",
	"key_algorithm":             "description.Certificate.KeyAlgorithm",
	"not_after":                 "description.Certificate.NotAfter",
	"not_before":                "description.Certificate.NotBefore",
	"renewal_eligibility":       "description.Certificate.RenewalEligibility",
	"revocation_reason":         "description.Certificate.RevocationReason",
	"revoked_at":                "description.Certificate.RevokedAt",
	"serial":                    "description.Certificate.Serial",
	"signature_algorithm":       "description.Certificate.SignatureAlgorithm",
	"status":                    "description.Certificate.Status",
	"subject":                   "description.Certificate.Subject",
	"subject_alternative_names": "description.Certificate.SubjectAlternativeNames",
	"tags_src":                  "description.Tags",
	"type":                      "description.Certificate.Type",
}

func ListCertificateManagerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCertificateManagerCertificate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCertificateManagerCertificate NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCertificateManagerCertificate NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCertificateManagerCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCertificateManagerCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCertificateManagerCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCertificateManagerCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCertificateManagerCertificateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCertificateManagerCertificate NewCertificateManagerCertificatePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCertificateManagerCertificate paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCertificateManagerCertificateFilters = map[string]string{
	"certificate":       "description.Attributes.Certificate",
	"certificate_arn":   "description.Certificate.CertificateArn",
	"certificate_chain": "description.Attributes.CertificateChain",
	"certificate_transparency_logging_preference": "description.Certificate.Options.CertificateTransparencyLoggingPreference",
	"created_at":                "description.Certificate.CreatedAt",
	"domain_name":               "description.Certificate.DomainName",
	"domain_validation_options": "description.Certificate.DomainValidationOptions",
	"extended_key_usages":       "description.Certificate.ExtendedKeyUsages",
	"failure_reason":            "description.Certificate.FailureReason",
	"imported_at":               "description.Certificate.ImportedAt",
	"in_use_by":                 "description.Certificate.InUseBy",
	"issued_at":                 "description.Certificate.IssuedAt",
	"issuer":                    "description.Certificate.Issuer",
	"og_account_id":             "metadata.SourceID",
	"key_algorithm":             "description.Certificate.KeyAlgorithm",
	"not_after":                 "description.Certificate.NotAfter",
	"not_before":                "description.Certificate.NotBefore",
	"renewal_eligibility":       "description.Certificate.RenewalEligibility",
	"revocation_reason":         "description.Certificate.RevocationReason",
	"revoked_at":                "description.Certificate.RevokedAt",
	"serial":                    "description.Certificate.Serial",
	"signature_algorithm":       "description.Certificate.SignatureAlgorithm",
	"status":                    "description.Certificate.Status",
	"subject":                   "description.Certificate.Subject",
	"subject_alternative_names": "description.Certificate.SubjectAlternativeNames",
	"tags_src":                  "description.Tags",
	"type":                      "description.Certificate.Type",
}

func GetCertificateManagerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCertificateManagerCertificate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCertificateManagerCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCertificateManagerCertificateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CertificateManagerCertificate =============================

// ==========================  START: CloudTrailTrail =============================

type CloudTrailTrail struct {
	Description   aws.CloudTrailTrailDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CloudTrailTrailHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CloudTrailTrail `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CloudTrailTrailHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CloudTrailTrailHit `json:"hits"`
}

type CloudTrailTrailSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CloudTrailTrailHits `json:"hits"`
}

type CloudTrailTrailPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailTrailPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailTrailPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_trail", filters, limit)
	if err != nil {
		return CloudTrailTrailPaginator{}, err
	}

	p := CloudTrailTrailPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailTrailPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailTrailPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudTrailTrailPaginator) NextPage(ctx context.Context) ([]CloudTrailTrail, error) {
	var response CloudTrailTrailSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailTrail
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailTrailFilters = map[string]string{
	"advanced_event_selectors":              "description.AdvancedEventSelectors",
	"arn":                                   "description.Trail.TrailARN",
	"cloudwatch_logs_role_arn":              "description.Trail.CloudWatchLogsRoleArn",
	"event_selectors":                       "description.EventSelectors",
	"has_custom_event_selectors":            "description.Trail.HasCustomEventSelectors",
	"has_insight_selectors":                 "description.Trail.HasInsightSelectors",
	"home_region":                           "description.Trail.HomeRegion",
	"include_global_service_events":         "description.Trail.IncludeGlobalServiceEvents",
	"insight_selectors":                     "description.Trail.HasInsightSelectors",
	"is_logging":                            "description.TrailStatus.IsLogging",
	"is_multi_region_trail":                 "description.Trail.IsMultiRegionTrail",
	"is_organization_trail":                 "description.Trail.IsOrganizationTrail",
	"og_account_id":                         "metadata.SourceID",
	"kms_key_id":                            "description.Trail.KmsKeyId",
	"latest_cloudwatch_logs_delivery_error": "description.TrailStatus.LatestCloudWatchLogsDeliveryError",
	"latest_cloudwatch_logs_delivery_time":  "description.TrailStatus.LatestCloudWatchLogsDeliveryTime",
	"latest_delivery_error":                 "description.TrailStatus.LatestDeliveryError",
	"latest_delivery_time":                  "description.TrailStatus.LatestDeliveryTime",
	"latest_digest_delivery_error":          "description.TrailStatus.LatestDigestDeliveryError",
	"latest_digest_delivery_time":           "description.TrailStatus.LatestDigestDeliveryTime",
	"latest_notification_error":             "description.TrailStatus.LatestNotificationError",
	"latest_notification_time":              "description.TrailStatus.LatestNotificationTime",
	"log_file_validation_enabled":           "description.Trail.LogFileValidationEnabled",
	"log_group_arn":                         "description.Trail.CloudWatchLogsLogGroupArn",
	"name":                                  "description.Trail.Name",
	"s3_bucket_name":                        "description.Trail.S3BucketName",
	"s3_key_prefix":                         "description.Trail.S3KeyPrefix",
	"sns_topic_arn":                         "description.Trail.SnsTopicARN",
	"start_logging_time":                    "description.TrailStatus.StartLoggingTime",
	"stop_logging_time":                     "description.TrailStatus.StopLoggingTime",
	"tags_src":                              "description.Tags",
	"title":                                 "description.Trail.Name",
}

func ListCloudTrailTrail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailTrail")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrail NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrail NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrail GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrail GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrail GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudTrailTrailPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudTrailTrailFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrail NewCloudTrailTrailPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudTrailTrail paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudTrailTrailFilters = map[string]string{
	"advanced_event_selectors":              "description.AdvancedEventSelectors",
	"arn":                                   "description.Trail.TrailARN",
	"cloudwatch_logs_role_arn":              "description.Trail.CloudWatchLogsRoleArn",
	"event_selectors":                       "description.EventSelectors",
	"has_custom_event_selectors":            "description.Trail.HasCustomEventSelectors",
	"has_insight_selectors":                 "description.Trail.HasInsightSelectors",
	"home_region":                           "description.Trail.HomeRegion",
	"include_global_service_events":         "description.Trail.IncludeGlobalServiceEvents",
	"insight_selectors":                     "description.Trail.HasInsightSelectors",
	"is_logging":                            "description.TrailStatus.IsLogging",
	"is_multi_region_trail":                 "description.Trail.IsMultiRegionTrail",
	"is_organization_trail":                 "description.Trail.IsOrganizationTrail",
	"og_account_id":                         "metadata.SourceID",
	"kms_key_id":                            "description.Trail.KmsKeyId",
	"latest_cloudwatch_logs_delivery_error": "description.TrailStatus.LatestCloudWatchLogsDeliveryError",
	"latest_cloudwatch_logs_delivery_time":  "description.TrailStatus.LatestCloudWatchLogsDeliveryTime",
	"latest_delivery_error":                 "description.TrailStatus.LatestDeliveryError",
	"latest_delivery_time":                  "description.TrailStatus.LatestDeliveryTime",
	"latest_digest_delivery_error":          "description.TrailStatus.LatestDigestDeliveryError",
	"latest_digest_delivery_time":           "description.TrailStatus.LatestDigestDeliveryTime",
	"latest_notification_error":             "description.TrailStatus.LatestNotificationError",
	"latest_notification_time":              "description.TrailStatus.LatestNotificationTime",
	"log_file_validation_enabled":           "description.Trail.LogFileValidationEnabled",
	"log_group_arn":                         "description.Trail.CloudWatchLogsLogGroupArn",
	"name":                                  "description.Trail.Name",
	"s3_bucket_name":                        "description.Trail.S3BucketName",
	"s3_key_prefix":                         "description.Trail.S3KeyPrefix",
	"sns_topic_arn":                         "description.Trail.SnsTopicARN",
	"start_logging_time":                    "description.TrailStatus.StartLoggingTime",
	"stop_logging_time":                     "description.TrailStatus.StopLoggingTime",
	"tags_src":                              "description.Tags",
	"title":                                 "description.Trail.Name",
}

func GetCloudTrailTrail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailTrail")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudTrailTrailPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudTrailTrailFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudTrailTrail =============================

// ==========================  START: CloudTrailChannel =============================

type CloudTrailChannel struct {
	Description   aws.CloudTrailChannelDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type CloudTrailChannelHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  CloudTrailChannel `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type CloudTrailChannelHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []CloudTrailChannelHit `json:"hits"`
}

type CloudTrailChannelSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  CloudTrailChannelHits `json:"hits"`
}

type CloudTrailChannelPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailChannelPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailChannelPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_channel", filters, limit)
	if err != nil {
		return CloudTrailChannelPaginator{}, err
	}

	p := CloudTrailChannelPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailChannelPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailChannelPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudTrailChannelPaginator) NextPage(ctx context.Context) ([]CloudTrailChannel, error) {
	var response CloudTrailChannelSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailChannel
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailChannelFilters = map[string]string{
	"advanced_event_selectors": "description.Channel.SourceConfig.AdvancedEventSelectors",
	"apply_to_all_regions":     "description.Channel.SourceConfig.ApplyToAllRegions",
	"arn":                      "description.Channel.ChannelArn",
	"destinations":             "description.Channel.Destinations",
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.Channel.Name",
	"source":                   "description.Channel.Source",
	"source_config":            "description.Channel.SourceConfig",
	"title":                    "description.Channel.Name",
}

func ListCloudTrailChannel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailChannel")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailChannel NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailChannel NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailChannel GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailChannel GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailChannel GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudTrailChannelPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudTrailChannelFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailChannel NewCloudTrailChannelPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudTrailChannel paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudTrailChannelFilters = map[string]string{
	"advanced_event_selectors": "description.Channel.SourceConfig.AdvancedEventSelectors",
	"apply_to_all_regions":     "description.Channel.SourceConfig.ApplyToAllRegions",
	"arn":                      "description.Channel.ChannelArn",
	"destinations":             "description.Channel.Destinations",
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.Channel.Name",
	"source":                   "description.Channel.Source",
	"source_config":            "description.Channel.SourceConfig",
	"title":                    "description.Channel.Name",
}

func GetCloudTrailChannel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailChannel")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudTrailChannelPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudTrailChannelFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudTrailChannel =============================

// ==========================  START: CloudTrailEventDataStore =============================

type CloudTrailEventDataStore struct {
	Description   aws.CloudTrailEventDataStoreDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type CloudTrailEventDataStoreHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  CloudTrailEventDataStore `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type CloudTrailEventDataStoreHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []CloudTrailEventDataStoreHit `json:"hits"`
}

type CloudTrailEventDataStoreSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  CloudTrailEventDataStoreHits `json:"hits"`
}

type CloudTrailEventDataStorePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailEventDataStorePaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailEventDataStorePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_eventdatastore", filters, limit)
	if err != nil {
		return CloudTrailEventDataStorePaginator{}, err
	}

	p := CloudTrailEventDataStorePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailEventDataStorePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailEventDataStorePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudTrailEventDataStorePaginator) NextPage(ctx context.Context) ([]CloudTrailEventDataStore, error) {
	var response CloudTrailEventDataStoreSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailEventDataStore
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailEventDataStoreFilters = map[string]string{
	"advanced_event_selectors":       "description.EventDataStore.AdvancedEventSelectors",
	"arn":                            "description.EventDataStore.EventDataStoreArn",
	"created_timestamp":              "description.EventDataStore.CreatedTimestamp",
	"og_account_id":                  "metadata.SourceID",
	"multi_region_enabled":           "description.EventDataStore.MultiRegionEnabled",
	"name":                           "description.EventDataStore.Name",
	"organization_enabled":           "description.EventDataStore.OrganizationEnabled",
	"retention_period":               "description.EventDataStore.RetentionPeriod",
	"status":                         "description.EventDataStore.Status",
	"termination_protection_enabled": "description.EventDataStore.TerminationProtectionEnabled",
	"title":                          "description.EventDataStore.Name",
	"updated_timestamp":              "description.EventDataStore.UpdatedTimestamp",
}

func ListCloudTrailEventDataStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailEventDataStore")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailEventDataStore NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailEventDataStore NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailEventDataStore GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailEventDataStore GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailEventDataStore GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudTrailEventDataStorePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudTrailEventDataStoreFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailEventDataStore NewCloudTrailEventDataStorePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudTrailEventDataStore paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudTrailEventDataStoreFilters = map[string]string{
	"advanced_event_selectors":       "description.EventDataStore.AdvancedEventSelectors",
	"arn":                            "description.EventDataStore.EventDataStoreArn",
	"created_timestamp":              "description.EventDataStore.CreatedTimestamp",
	"og_account_id":                  "metadata.SourceID",
	"multi_region_enabled":           "description.EventDataStore.MultiRegionEnabled",
	"name":                           "description.EventDataStore.Name",
	"organization_enabled":           "description.EventDataStore.OrganizationEnabled",
	"retention_period":               "description.EventDataStore.RetentionPeriod",
	"status":                         "description.EventDataStore.Status",
	"termination_protection_enabled": "description.EventDataStore.TerminationProtectionEnabled",
	"title":                          "description.EventDataStore.Name",
	"updated_timestamp":              "description.EventDataStore.UpdatedTimestamp",
}

func GetCloudTrailEventDataStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailEventDataStore")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudTrailEventDataStorePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudTrailEventDataStoreFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudTrailEventDataStore =============================

// ==========================  START: CloudTrailImport =============================

type CloudTrailImport struct {
	Description   aws.CloudTrailImportDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type CloudTrailImportHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CloudTrailImport `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CloudTrailImportHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CloudTrailImportHit `json:"hits"`
}

type CloudTrailImportSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CloudTrailImportHits `json:"hits"`
}

type CloudTrailImportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailImportPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailImportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_import", filters, limit)
	if err != nil {
		return CloudTrailImportPaginator{}, err
	}

	p := CloudTrailImportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailImportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailImportPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudTrailImportPaginator) NextPage(ctx context.Context) ([]CloudTrailImport, error) {
	var response CloudTrailImportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailImport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailImportFilters = map[string]string{
	"created_timestamp": "description.Import.CreatedTimestamp",
	"destinations":      "description.Import.Destinations",
	"end_event_time":    "description.Import.EndEventTime",
	"import_id":         "description.Import.ImportId",
	"import_source":     "description.Import.ImportSource",
	"import_statistics": "description.Import.ImportStatistics",
	"import_status":     "description.Import.ImportStatus",
	"og_account_id":     "metadata.SourceID",
	"start_event_time":  "description.Import.StartEventTime",
	"title":             "description.Import.ImportId",
	"updated_timestamp": "description.Import.UpdatedTimestamp",
}

func ListCloudTrailImport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailImport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailImport NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailImport NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailImport GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailImport GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailImport GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudTrailImportPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudTrailImportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailImport NewCloudTrailImportPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudTrailImport paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudTrailImportFilters = map[string]string{
	"created_timestamp": "description.Import.CreatedTimestamp",
	"destinations":      "description.Import.Destinations",
	"end_event_time":    "description.Import.EndEventTime",
	"import_id":         "description.Import.ImportId",
	"import_source":     "description.Import.ImportSource",
	"import_statistics": "description.Import.ImportStatistics",
	"import_status":     "description.Import.ImportStatus",
	"og_account_id":     "metadata.SourceID",
	"start_event_time":  "description.Import.StartEventTime",
	"title":             "description.Import.ImportId",
	"updated_timestamp": "description.Import.UpdatedTimestamp",
}

func GetCloudTrailImport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailImport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudTrailImportPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudTrailImportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudTrailImport =============================

// ==========================  START: CloudTrailQuery =============================

type CloudTrailQuery struct {
	Description   aws.CloudTrailQueryDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CloudTrailQueryHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CloudTrailQuery `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CloudTrailQueryHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CloudTrailQueryHit `json:"hits"`
}

type CloudTrailQuerySearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CloudTrailQueryHits `json:"hits"`
}

type CloudTrailQueryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailQueryPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailQueryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_query", filters, limit)
	if err != nil {
		return CloudTrailQueryPaginator{}, err
	}

	p := CloudTrailQueryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailQueryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailQueryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudTrailQueryPaginator) NextPage(ctx context.Context) ([]CloudTrailQuery, error) {
	var response CloudTrailQuerySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailQuery
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailQueryFilters = map[string]string{
	"bytes_scanned":            "description.Query.QueryStatistics.BytesScanned",
	"creation_time":            "description.Query.QueryStatistics.CreationTime",
	"delivery_s3_uri":          "description.Query.DeliveryS3Uri",
	"delivery_status":          "description.Query.DeliveryStatus",
	"error_message":            "description.Query.ErrorMessage",
	"event_data_store_arn":     "description.EventDataStoreARN",
	"events_matched":           "description.Query.QueryStatistics.EventsMatched",
	"events_scanned":           "description.Query.QueryStatistics.EventsScanned",
	"execution_time_in_millis": "description.Query.QueryStatistics.ExecutionTimeInMillis",
	"og_account_id":            "metadata.SourceID",
	"query_id":                 "description.Query.QueryId",
	"query_status":             "description.Query.QueryStatus",
	"query_string":             "description.Query.QueryString",
	"title":                    "description.Query.QueryId",
}

func ListCloudTrailQuery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailQuery")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailQuery NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailQuery NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailQuery GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailQuery GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailQuery GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudTrailQueryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudTrailQueryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailQuery NewCloudTrailQueryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudTrailQuery paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudTrailQueryFilters = map[string]string{
	"bytes_scanned":            "description.Query.QueryStatistics.BytesScanned",
	"creation_time":            "description.Query.QueryStatistics.CreationTime",
	"delivery_s3_uri":          "description.Query.DeliveryS3Uri",
	"delivery_status":          "description.Query.DeliveryStatus",
	"error_message":            "description.Query.ErrorMessage",
	"event_data_store_arn":     "description.EventDataStoreARN",
	"events_matched":           "description.Query.QueryStatistics.EventsMatched",
	"events_scanned":           "description.Query.QueryStatistics.EventsScanned",
	"execution_time_in_millis": "description.Query.QueryStatistics.ExecutionTimeInMillis",
	"og_account_id":            "metadata.SourceID",
	"query_id":                 "description.Query.QueryId",
	"query_status":             "description.Query.QueryStatus",
	"query_string":             "description.Query.QueryString",
	"title":                    "description.Query.QueryId",
}

func GetCloudTrailQuery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailQuery")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudTrailQueryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudTrailQueryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudTrailQuery =============================

// ==========================  START: CloudTrailTrailEvent =============================

type CloudTrailTrailEvent struct {
	Description   aws.CloudTrailTrailEventDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type CloudTrailTrailEventHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  CloudTrailTrailEvent `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type CloudTrailTrailEventHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []CloudTrailTrailEventHit `json:"hits"`
}

type CloudTrailTrailEventSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  CloudTrailTrailEventHits `json:"hits"`
}

type CloudTrailTrailEventPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudTrailTrailEventPaginator(filters []essdk.BoolFilter, limit *int64) (CloudTrailTrailEventPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudtrail_trailevent", filters, limit)
	if err != nil {
		return CloudTrailTrailEventPaginator{}, err
	}

	p := CloudTrailTrailEventPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudTrailTrailEventPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudTrailTrailEventPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudTrailTrailEventPaginator) NextPage(ctx context.Context) ([]CloudTrailTrailEvent, error) {
	var response CloudTrailTrailEventSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudTrailTrailEvent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudTrailTrailEventFilters = map[string]string{
	"access_key_id":   "userIdentity.AccessKeyId",
	"og_account_id":   "metadata.SourceID",
	"log_group_name":  "description.LogGroupName",
	"log_stream_name": "description.TrailEvent.LogStreamName",
	"timestamp":       "description.TrailEvent.Timestamp",
	"timestamp_ms":    "description.TrailEvent.Timestamp",
	"user_identifier": "userIdentity.Arn",
	"user_type":       "userIdentity.Type",
	"username":        "userIdentity.Username",
}

func ListCloudTrailTrailEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudTrailTrailEvent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrailEvent NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrailEvent NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrailEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrailEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrailEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudTrailTrailEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudTrailTrailEventFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudTrailTrailEvent NewCloudTrailTrailEventPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudTrailTrailEvent paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudTrailTrailEventFilters = map[string]string{
	"access_key_id":   "userIdentity.AccessKeyId",
	"og_account_id":   "metadata.SourceID",
	"log_group_name":  "description.LogGroupName",
	"log_stream_name": "description.TrailEvent.LogStreamName",
	"timestamp_ms":    "description.TrailEvent.Timestamp",
	"user_identifier": "userIdentity.Arn",
	"user_type":       "userIdentity.Type",
	"username":        "userIdentity.Username",
}

func GetCloudTrailTrailEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudTrailTrailEvent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudTrailTrailEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudTrailTrailEventFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudTrailTrailEvent =============================

// ==========================  START: IAMAccount =============================

type IAMAccount struct {
	Description   aws.IAMAccountDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type IAMAccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMAccount    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMAccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMAccountHit   `json:"hits"`
}

type IAMAccountSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  IAMAccountHits `json:"hits"`
}

type IAMAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccountPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_account_account", filters, limit)
	if err != nil {
		return IAMAccountPaginator{}, err
	}

	p := IAMAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMAccountPaginator) NextPage(ctx context.Context) ([]IAMAccount, error) {
	var response IAMAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccountFilters = map[string]string{
	"account_aliases":                     "description.Aliases",
	"account_email":                       "description.Account.Email",
	"account_id":                          "description.Account.Id",
	"account_status":                      "description.Account.Status",
	"arn":                                 "description.Account.Arn",
	"og_account_id":                       "metadata.SourceID",
	"name":                                "description.Account.Name",
	"organization_arn":                    "description.Organization.Arn",
	"organization_available_policy_types": "description.Organization.AvailablePolicyTypes",
	"organization_feature_set":            "description.Organization.FeatureSet",
	"organization_id":                     "description.Organization.Id",
	"organization_master_account_arn":     "description.Organization.MasterAccountArn",
	"organization_master_account_email":   "description.Organization.MasterAccountEmail",
	"organization_master_account_id":      "description.Organization.MasterAccountId",
	"title":                               "description.Account.Name",
}

func ListIAMAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMAccountFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccount NewIAMAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMAccountFilters = map[string]string{
	"account_aliases":                     "description.Aliases",
	"account_email":                       "description.Account.Email",
	"account_id":                          "description.Account.Id",
	"account_status":                      "description.Account.Status",
	"arn":                                 "description.Account.Arn",
	"og_account_id":                       "metadata.SourceID",
	"name":                                "description.Account.Name",
	"organization_arn":                    "description.Organization.Arn",
	"organization_available_policy_types": "description.Organization.AvailablePolicyTypes",
	"organization_feature_set":            "description.Organization.FeatureSet",
	"organization_id":                     "description.Organization.Id",
	"organization_master_account_arn":     "description.Organization.MasterAccountArn",
	"organization_master_account_email":   "description.Organization.MasterAccountEmail",
	"organization_master_account_id":      "description.Organization.MasterAccountId",
	"title":                               "description.Account.Name",
}

func GetIAMAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMAccountFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMAccount =============================

// ==========================  START: IAMAccessAdvisor =============================

type IAMAccessAdvisor struct {
	Description   aws.IAMAccessAdvisorDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type IAMAccessAdvisorHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  IAMAccessAdvisor `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type IAMAccessAdvisorHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []IAMAccessAdvisorHit `json:"hits"`
}

type IAMAccessAdvisorSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  IAMAccessAdvisorHits `json:"hits"`
}

type IAMAccessAdvisorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccessAdvisorPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccessAdvisorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_accessadvisor", filters, limit)
	if err != nil {
		return IAMAccessAdvisorPaginator{}, err
	}

	p := IAMAccessAdvisorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccessAdvisorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccessAdvisorPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMAccessAdvisorPaginator) NextPage(ctx context.Context) ([]IAMAccessAdvisor, error) {
	var response IAMAccessAdvisorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccessAdvisor
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccessAdvisorFilters = map[string]string{
	"og_account_id":                 "metadata.SourceID",
	"last_authenticated":            "description.ServiceLastAccessed.LastAuthenticated",
	"last_authenticated_entity":     "description.ServiceLastAccessed.LastAuthenticatedEntity",
	"last_authenticated_region":     "description.ServiceLastAccessed.LastAuthenticatedRegion",
	"principal_arn":                 "description.PrincipalArn",
	"service_name":                  "description.ServiceLastAccessed.ServiceName",
	"service_namespace":             "description.ServiceLastAccessed.ServiceNamespace",
	"total_authenticated_entities":  "description.ServiceLastAccessed.TotalAuthenticatedEntities",
	"tracked_actions_last_accessed": "description.ServiceLastAccessed.TrackedActionsLastAccessed",
}

func ListIAMAccessAdvisor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccessAdvisor")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessAdvisor NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessAdvisor NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessAdvisor GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessAdvisor GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessAdvisor GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMAccessAdvisorPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMAccessAdvisorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessAdvisor NewIAMAccessAdvisorPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMAccessAdvisor paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMAccessAdvisorFilters = map[string]string{
	"og_account_id":                 "metadata.SourceID",
	"last_authenticated":            "description.ServiceLastAccessed.LastAuthenticated",
	"last_authenticated_entity":     "description.ServiceLastAccessed.LastAuthenticatedEntity",
	"last_authenticated_region":     "description.ServiceLastAccessed.LastAuthenticatedRegion",
	"principal_arn":                 "description.PrincipalArn",
	"service_name":                  "description.ServiceLastAccessed.ServiceName",
	"service_namespace":             "description.ServiceLastAccessed.ServiceNamespace",
	"total_authenticated_entities":  "description.ServiceLastAccessed.TotalAuthenticatedEntities",
	"tracked_actions_last_accessed": "description.ServiceLastAccessed.TrackedActionsLastAccessed",
}

func GetIAMAccessAdvisor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccessAdvisor")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMAccessAdvisorPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMAccessAdvisorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMAccessAdvisor =============================

// ==========================  START: IAMAccountSummary =============================

type IAMAccountSummary struct {
	Description   aws.IAMAccountSummaryDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type IAMAccountSummaryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  IAMAccountSummary `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type IAMAccountSummaryHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []IAMAccountSummaryHit `json:"hits"`
}

type IAMAccountSummarySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  IAMAccountSummaryHits `json:"hits"`
}

type IAMAccountSummaryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccountSummaryPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccountSummaryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_accountsummary", filters, limit)
	if err != nil {
		return IAMAccountSummaryPaginator{}, err
	}

	p := IAMAccountSummaryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccountSummaryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccountSummaryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMAccountSummaryPaginator) NextPage(ctx context.Context) ([]IAMAccountSummary, error) {
	var response IAMAccountSummarySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccountSummary
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccountSummaryFilters = map[string]string{
	"access_keys_per_user_quota":           "description.AccountSummary.AccessKeysPerUserQuota",
	"account_access_keys_present":          "description.AccountSummary.AccountAccessKeysPresent",
	"account_signing_certificates_present": "description.AccountSummary.AccountSigningCertificatesPresent",
	"assume_role_policy_size_quota":        "description.AccountSummary.AssumeRolePolicySizeQuota",
	"attached_policies_per_group_quota":    "description.AccountSummary.AttachedPoliciesPerGroupQuota",
	"attached_policies_per_role_quota":     "description.AccountSummary.AttachedPoliciesPerRoleQuota",
	"attached_policies_per_user_quota":     "description.AccountSummary.AttachedPoliciesPerUserQuota",
	"global_endpoint_token_version":        "description.AccountSummary.GlobalEndpointTokenVersion",
	"group_policy_size_quota":              "description.AccountSummary.GroupPolicySizeQuota",
	"groups":                               "description.AccountSummary.Groups",
	"groups_per_user_quota":                "description.AccountSummary.GroupsPerUserQuota",
	"groups_quota":                         "description.AccountSummary.GroupsQuota",
	"instance_profiles":                    "description.AccountSummary.InstanceProfiles",
	"instance_profiles_quota":              "description.AccountSummary.InstanceProfilesQuota",
	"og_account_id":                        "metadata.SourceID",
	"mfa_devices":                          "description.AccountSummary.MFADevices",
	"mfa_devices_in_use":                   "description.AccountSummary.MFADevicesInUse",
	"policies":                             "description.AccountSummary.Policies",
	"policies_quota":                       "description.AccountSummary.PoliciesQuota",
	"policy_size_quota":                    "description.AccountSummary.PolicySizeQuota",
	"policy_versions_in_use":               "description.AccountSummary.PolicyVersionsInUse",
	"policy_versions_in_use_quota":         "description.AccountSummary.PolicyVersionsInUseQuota",
	"providers":                            "description.AccountSummary.Providers",
	"role_policy_size_quota":               "description.AccountSummary.RolePolicySizeQuota",
	"roles":                                "description.AccountSummary.Roles",
	"roles_quota":                          "description.AccountSummary.RolesQuota",
	"server_certificates":                  "description.AccountSummary.ServerCertificates",
	"server_certificates_quota":            "description.AccountSummary.ServerCertificatesQuota",
	"signing_certificates_per_user_quota":  "description.AccountSummary.SigningCertificatesPerUserQuota",
	"user_policy_size_quota":               "description.AccountSummary.UserPolicySizeQuota",
	"users":                                "description.AccountSummary.Users",
	"users_quota":                          "description.AccountSummary.UsersQuota",
	"versions_per_policy_quota":            "description.AccountSummary.VersionsPerPolicyQuota",
}

func ListIAMAccountSummary(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccountSummary")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountSummary NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountSummary NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountSummary GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountSummary GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountSummary GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMAccountSummaryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMAccountSummaryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountSummary NewIAMAccountSummaryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMAccountSummary paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMAccountSummaryFilters = map[string]string{
	"access_keys_per_user_quota":           "description.AccountSummary.AccessKeysPerUserQuota",
	"account_access_keys_present":          "description.AccountSummary.AccountAccessKeysPresent",
	"account_signing_certificates_present": "description.AccountSummary.AccountSigningCertificatesPresent",
	"assume_role_policy_size_quota":        "description.AccountSummary.AssumeRolePolicySizeQuota",
	"attached_policies_per_group_quota":    "description.AccountSummary.AttachedPoliciesPerGroupQuota",
	"attached_policies_per_role_quota":     "description.AccountSummary.AttachedPoliciesPerRoleQuota",
	"attached_policies_per_user_quota":     "description.AccountSummary.AttachedPoliciesPerUserQuota",
	"global_endpoint_token_version":        "description.AccountSummary.GlobalEndpointTokenVersion",
	"group_policy_size_quota":              "description.AccountSummary.GroupPolicySizeQuota",
	"groups":                               "description.AccountSummary.Groups",
	"groups_per_user_quota":                "description.AccountSummary.GroupsPerUserQuota",
	"groups_quota":                         "description.AccountSummary.GroupsQuota",
	"instance_profiles":                    "description.AccountSummary.InstanceProfiles",
	"instance_profiles_quota":              "description.AccountSummary.InstanceProfilesQuota",
	"og_account_id":                        "metadata.SourceID",
	"mfa_devices":                          "description.AccountSummary.MFADevices",
	"mfa_devices_in_use":                   "description.AccountSummary.MFADevicesInUse",
	"policies":                             "description.AccountSummary.Policies",
	"policies_quota":                       "description.AccountSummary.PoliciesQuota",
	"policy_size_quota":                    "description.AccountSummary.PolicySizeQuota",
	"policy_versions_in_use":               "description.AccountSummary.PolicyVersionsInUse",
	"policy_versions_in_use_quota":         "description.AccountSummary.PolicyVersionsInUseQuota",
	"providers":                            "description.AccountSummary.Providers",
	"role_policy_size_quota":               "description.AccountSummary.RolePolicySizeQuota",
	"roles":                                "description.AccountSummary.Roles",
	"roles_quota":                          "description.AccountSummary.RolesQuota",
	"server_certificates":                  "description.AccountSummary.ServerCertificates",
	"server_certificates_quota":            "description.AccountSummary.ServerCertificatesQuota",
	"signing_certificates_per_user_quota":  "description.AccountSummary.SigningCertificatesPerUserQuota",
	"user_policy_size_quota":               "description.AccountSummary.UserPolicySizeQuota",
	"users":                                "description.AccountSummary.Users",
	"users_quota":                          "description.AccountSummary.UsersQuota",
	"versions_per_policy_quota":            "description.AccountSummary.VersionsPerPolicyQuota",
}

func GetIAMAccountSummary(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccountSummary")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMAccountSummaryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMAccountSummaryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMAccountSummary =============================

// ==========================  START: IAMAccessKey =============================

type IAMAccessKey struct {
	Description   aws.IAMAccessKeyDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type IAMAccessKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMAccessKey  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMAccessKeyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMAccessKeyHit `json:"hits"`
}

type IAMAccessKeySearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  IAMAccessKeyHits `json:"hits"`
}

type IAMAccessKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccessKeyPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccessKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_accesskey", filters, limit)
	if err != nil {
		return IAMAccessKeyPaginator{}, err
	}

	p := IAMAccessKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccessKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccessKeyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMAccessKeyPaginator) NextPage(ctx context.Context) ([]IAMAccessKey, error) {
	var response IAMAccessKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccessKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccessKeyFilters = map[string]string{
	"access_key_id":                "description.AccessKey.AccessKeyId",
	"access_key_last_used_date":    "description.AccessKeyLastUsed.LastUsedData",
	"access_key_last_used_region":  "description.AccessKeyLastUsed.Region",
	"access_key_last_used_service": "description.AccessKeyLastUsed.ServiceName",
	"create_date":                  "description.AccessKey.CreateDate",
	"og_account_id":                "metadata.SourceID",
	"status":                       "description.AccessKey.Status",
	"title":                        "description.AccessKey.AccessKeyId",
	"user_name":                    "description.AccessKey.UserName",
}

func ListIAMAccessKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccessKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessKey NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessKey NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMAccessKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMAccessKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccessKey NewIAMAccessKeyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMAccessKey paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMAccessKeyFilters = map[string]string{
	"access_key_id":                "description.AccessKey.AccessKeyId",
	"access_key_last_used_date":    "description.AccessKeyLastUsed.LastUsedData",
	"access_key_last_used_region":  "description.AccessKeyLastUsed.Region",
	"access_key_last_used_service": "description.AccessKeyLastUsed.ServiceName",
	"create_date":                  "description.AccessKey.CreateDate",
	"og_account_id":                "metadata.SourceID",
	"status":                       "description.AccessKey.Status",
	"title":                        "description.AccessKey.AccessKeyId",
	"user_name":                    "description.AccessKey.UserName",
}

func GetIAMAccessKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccessKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMAccessKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMAccessKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMAccessKey =============================

// ==========================  START: IAMSSHPublicKey =============================

type IAMSSHPublicKey struct {
	Description   aws.IAMSSHPublicKeyDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type IAMSSHPublicKeyHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  IAMSSHPublicKey `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type IAMSSHPublicKeyHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []IAMSSHPublicKeyHit `json:"hits"`
}

type IAMSSHPublicKeySearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  IAMSSHPublicKeyHits `json:"hits"`
}

type IAMSSHPublicKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMSSHPublicKeyPaginator(filters []essdk.BoolFilter, limit *int64) (IAMSSHPublicKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_sshpublickey", filters, limit)
	if err != nil {
		return IAMSSHPublicKeyPaginator{}, err
	}

	p := IAMSSHPublicKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMSSHPublicKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMSSHPublicKeyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMSSHPublicKeyPaginator) NextPage(ctx context.Context) ([]IAMSSHPublicKey, error) {
	var response IAMSSHPublicKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMSSHPublicKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMSSHPublicKeyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"ssh_public_key_id": "description.SSHPublicKeyKey.SSHPublicKeyId",
	"status":            "description.SSHPublicKeyKey.Status",
	"title":             "description.SSHPublicKeyKey.SSHPublicKeyId",
	"update_date":       "description.SSHPublicKeyKey.UploadDate",
	"user_name":         "description.SSHPublicKeyKey.UserName",
}

func ListIAMSSHPublicKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMSSHPublicKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSSHPublicKey NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSSHPublicKey NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSSHPublicKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSSHPublicKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSSHPublicKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMSSHPublicKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMSSHPublicKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSSHPublicKey NewIAMSSHPublicKeyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMSSHPublicKey paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMSSHPublicKeyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"ssh_public_key_id": "description.SSHPublicKeyKey.SSHPublicKeyId",
	"status":            "description.SSHPublicKeyKey.Status",
	"title":             "description.SSHPublicKeyKey.SSHPublicKeyId",
	"update_date":       "description.SSHPublicKeyKey.UploadDate",
	"user_name":         "description.SSHPublicKeyKey.UserName",
}

func GetIAMSSHPublicKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMSSHPublicKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMSSHPublicKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMSSHPublicKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMSSHPublicKey =============================

// ==========================  START: IAMAccountPasswordPolicy =============================

type IAMAccountPasswordPolicy struct {
	Description   aws.IAMAccountPasswordPolicyDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type IAMAccountPasswordPolicyHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  IAMAccountPasswordPolicy `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type IAMAccountPasswordPolicyHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []IAMAccountPasswordPolicyHit `json:"hits"`
}

type IAMAccountPasswordPolicySearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  IAMAccountPasswordPolicyHits `json:"hits"`
}

type IAMAccountPasswordPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMAccountPasswordPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (IAMAccountPasswordPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_accountpasswordpolicy", filters, limit)
	if err != nil {
		return IAMAccountPasswordPolicyPaginator{}, err
	}

	p := IAMAccountPasswordPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMAccountPasswordPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMAccountPasswordPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMAccountPasswordPolicyPaginator) NextPage(ctx context.Context) ([]IAMAccountPasswordPolicy, error) {
	var response IAMAccountPasswordPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMAccountPasswordPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMAccountPasswordPolicyFilters = map[string]string{
	"allow_users_to_change_password": "description.PasswordPolicy.AllowUsersToChangePassword",
	"expire_passwords":               "description.PasswordPolicy.ExpirePasswords",
	"hard_expiry":                    "description.PasswordPolicy.HardExpiry",
	"og_account_id":                  "metadata.SourceID",
	"max_password_age":               "description.PasswordPolicy.MaxPasswordAge",
	"minimum_password_length":        "description.PasswordPolicy.MinimumPasswordLength",
	"password_reuse_prevention":      "description.PasswordPolicy.PasswordReusePrevention",
	"require_lowercase_characters":   "description.PasswordPolicy.RequireLowercaseCharacters",
	"require_numbers":                "description.PasswordPolicy.RequireNumbers",
	"require_symbols":                "description.PasswordPolicy.RequireSymbols",
	"require_uppercase_characters":   "description.PasswordPolicy.RequireUppercaseCharacters",
}

func ListIAMAccountPasswordPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMAccountPasswordPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountPasswordPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountPasswordPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountPasswordPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountPasswordPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountPasswordPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMAccountPasswordPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMAccountPasswordPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMAccountPasswordPolicy NewIAMAccountPasswordPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMAccountPasswordPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMAccountPasswordPolicyFilters = map[string]string{
	"allow_users_to_change_password": "description.PasswordPolicy.AllowUsersToChangePassword",
	"expire_passwords":               "description.PasswordPolicy.ExpirePasswords",
	"hard_expiry":                    "description.PasswordPolicy.HardExpiry",
	"og_account_id":                  "metadata.SourceID",
	"max_password_age":               "description.PasswordPolicy.MaxPasswordAge",
	"minimum_password_length":        "description.PasswordPolicy.MinimumPasswordLength",
	"password_reuse_prevention":      "description.PasswordPolicy.PasswordReusePrevention",
	"require_lowercase_characters":   "description.PasswordPolicy.RequireLowercaseCharacters",
	"require_numbers":                "description.PasswordPolicy.RequireNumbers",
	"require_symbols":                "description.PasswordPolicy.RequireSymbols",
	"require_uppercase_characters":   "description.PasswordPolicy.RequireUppercaseCharacters",
}

func GetIAMAccountPasswordPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMAccountPasswordPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMAccountPasswordPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMAccountPasswordPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMAccountPasswordPolicy =============================

// ==========================  START: IAMUser =============================

type IAMUser struct {
	Description   aws.IAMUserDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type IAMUserHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMUser       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMUserHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMUserHit      `json:"hits"`
}

type IAMUserSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  IAMUserHits `json:"hits"`
}

type IAMUserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMUserPaginator(filters []essdk.BoolFilter, limit *int64) (IAMUserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_user", filters, limit)
	if err != nil {
		return IAMUserPaginator{}, err
	}

	p := IAMUserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMUserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMUserPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMUserPaginator) NextPage(ctx context.Context) ([]IAMUser, error) {
	var response IAMUserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMUser
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMUserFilters = map[string]string{
	"arn":                       "description.User.Arn",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.User.CreateDate",
	"groups":                    "description.Groups",
	"inline_policies":           "description.InlinePolicies",
	"og_account_id":             "metadata.SourceID",
	"login_profile":             "description.LoginProfile",
	"mfa_devices":               "description.MFADevices",
	"name":                      "description.User.UserName",
	"password_last_used":        "description.User.PasswordLastUsed",
	"path":                      "description.User.Path",
	"permissions_boundary_arn":  "description.User.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.User.PermissionsBoundary.PermissionsBoundaryType",
	"tags_src":                  "description.User.Tags",
	"title":                     "description.User.UserName",
	"user_id":                   "description.User.UserId",
}

func ListIAMUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMUser NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMUser NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMUserFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMUser NewIAMUserPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMUser paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMUserFilters = map[string]string{
	"arn":                       "description.User.Arn",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.User.CreateDate",
	"groups":                    "description.Groups",
	"inline_policies":           "description.InlinePolicies",
	"og_account_id":             "metadata.SourceID",
	"login_profile":             "description.LoginProfile",
	"mfa_devices":               "description.MFADevices",
	"name":                      "description.User.UserName",
	"password_last_used":        "description.User.PasswordLastUsed",
	"path":                      "description.User.Path",
	"permissions_boundary_arn":  "description.User.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.User.PermissionsBoundary.PermissionsBoundaryType",
	"tags_src":                  "description.User.Tags",
	"title":                     "description.User.UserName",
	"user_id":                   "description.User.UserId",
}

func GetIAMUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMUserFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMUser =============================

// ==========================  START: IAMGroup =============================

type IAMGroup struct {
	Description   aws.IAMGroupDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type IAMGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMGroup      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMGroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMGroupHit     `json:"hits"`
}

type IAMGroupSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  IAMGroupHits `json:"hits"`
}

type IAMGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMGroupPaginator(filters []essdk.BoolFilter, limit *int64) (IAMGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_group", filters, limit)
	if err != nil {
		return IAMGroupPaginator{}, err
	}

	p := IAMGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMGroupPaginator) NextPage(ctx context.Context) ([]IAMGroup, error) {
	var response IAMGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMGroupFilters = map[string]string{
	"arn":                  "description.Group.Arn",
	"attached_policy_arns": "description.AttachedPolicyArns",
	"create_date":          "description.Group.CreateDate",
	"group_id":             "description.Group.GroupId",
	"inline_policies":      "description.InlinePolicies",
	"og_account_id":        "metadata.SourceID",
	"name":                 "description.Group.GroupName",
	"path":                 "description.Group.Path",
	"title":                "description.Group.GroupName",
	"users":                "description.Users",
}

func ListIAMGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMGroup NewIAMGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMGroupFilters = map[string]string{
	"arn":                  "description.Group.Arn",
	"attached_policy_arns": "description.AttachedPolicyArns",
	"create_date":          "description.Group.CreateDate",
	"group_id":             "description.Group.GroupId",
	"inline_policies":      "description.InlinePolicies",
	"og_account_id":        "metadata.SourceID",
	"name":                 "description.Group.GroupName",
	"path":                 "description.Group.Path",
	"title":                "description.Group.GroupName",
	"users":                "description.Users",
}

func GetIAMGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMGroup =============================

// ==========================  START: IAMRole =============================

type IAMRole struct {
	Description   aws.IAMRoleDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type IAMRoleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMRole       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMRoleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMRoleHit      `json:"hits"`
}

type IAMRoleSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  IAMRoleHits `json:"hits"`
}

type IAMRolePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMRolePaginator(filters []essdk.BoolFilter, limit *int64) (IAMRolePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_role", filters, limit)
	if err != nil {
		return IAMRolePaginator{}, err
	}

	p := IAMRolePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMRolePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMRolePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMRolePaginator) NextPage(ctx context.Context) ([]IAMRole, error) {
	var response IAMRoleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMRole
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMRoleFilters = map[string]string{
	"arn":                       "description.Role.Arn",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.Role.CreateDate",
	"description":               "description.Role.Description",
	"inline_policies":           "description.InlinePolicies",
	"instance_profile_arns":     "description.InstanceProfileArns",
	"og_account_id":             "metadata.SourceID",
	"max_session_duration":      "description.Role.MaxSessionDuration",
	"name":                      "description.Role.RoleName",
	"path":                      "description.Role.Path",
	"permissions_boundary_arn":  "description.Role.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.Role.PermissionsBoundary.PermissionsBoundaryType",
	"role_id":                   "description.Role.RoleId",
	"role_last_used_date":       "description.Role.RoleLastUsed.LastUsedDate",
	"role_last_used_region":     "description.Role.RoleLastUsed.Region",
	"tags_src":                  "description.Role.Tags",
	"title":                     "description.Role.RoleName",
}

func ListIAMRole(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMRole")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMRole NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMRole NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMRole GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMRole GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMRole GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMRolePaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMRoleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMRole NewIAMRolePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMRole paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMRoleFilters = map[string]string{
	"arn":                       "description.Role.Arn",
	"attached_policy_arns":      "description.AttachedPolicyArns",
	"create_date":               "description.Role.CreateDate",
	"description":               "description.Role.Description",
	"inline_policies":           "description.InlinePolicies",
	"instance_profile_arns":     "description.InstanceProfileArns",
	"og_account_id":             "metadata.SourceID",
	"max_session_duration":      "description.Role.MaxSessionDuration",
	"name":                      "description.Role.RoleName",
	"path":                      "description.Role.Path",
	"permissions_boundary_arn":  "description.Role.PermissionsBoundary.PermissionsBoundaryArn",
	"permissions_boundary_type": "description.Role.PermissionsBoundary.PermissionsBoundaryType",
	"role_id":                   "description.Role.RoleId",
	"role_last_used_date":       "description.Role.RoleLastUsed.LastUsedDate",
	"role_last_used_region":     "description.Role.RoleLastUsed.Region",
	"tags_src":                  "description.Role.Tags",
	"title":                     "description.Role.RoleName",
}

func GetIAMRole(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMRole")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMRolePaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMRoleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMRole =============================

// ==========================  START: IAMServerCertificate =============================

type IAMServerCertificate struct {
	Description   aws.IAMServerCertificateDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type IAMServerCertificateHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  IAMServerCertificate `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type IAMServerCertificateHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []IAMServerCertificateHit `json:"hits"`
}

type IAMServerCertificateSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  IAMServerCertificateHits `json:"hits"`
}

type IAMServerCertificatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMServerCertificatePaginator(filters []essdk.BoolFilter, limit *int64) (IAMServerCertificatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_servercertificate", filters, limit)
	if err != nil {
		return IAMServerCertificatePaginator{}, err
	}

	p := IAMServerCertificatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMServerCertificatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMServerCertificatePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMServerCertificatePaginator) NextPage(ctx context.Context) ([]IAMServerCertificate, error) {
	var response IAMServerCertificateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMServerCertificate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMServerCertificateFilters = map[string]string{
	"arn":                     "description.ServerCertificate.ServerCertificateMetadata.Arn",
	"certificate_body":        "description.ServerCertificate.CertificateBody",
	"certificate_body_length": "description.BodyLength",
	"certificate_chain":       "description.ServerCertificate.CertificateChain",
	"expiration":              "description.ServerCertificate.ServerCertificateMetadata.Expiration",
	"og_account_id":           "metadata.SourceID",
	"name":                    "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"path":                    "description.ServerCertificate.ServerCertificateMetadata.Path",
	"server_certificate_id":   "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateId",
	"tags":                    "description.ServerCertificate.Tags",
	"tags_src":                "description.ServerCertificate.Tags",
	"title":                   "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"upload_date":             "description.ServerCertificate.ServerCertificateMetadata.UploadDate",
}

func ListIAMServerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMServerCertificate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServerCertificate NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServerCertificate NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServerCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServerCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServerCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMServerCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMServerCertificateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServerCertificate NewIAMServerCertificatePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMServerCertificate paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMServerCertificateFilters = map[string]string{
	"arn":                     "description.ServerCertificate.ServerCertificateMetadata.Arn",
	"certificate_body":        "description.ServerCertificate.CertificateBody",
	"certificate_body_length": "description.BodyLength",
	"certificate_chain":       "description.ServerCertificate.CertificateChain",
	"expiration":              "description.ServerCertificate.ServerCertificateMetadata.Expiration",
	"og_account_id":           "metadata.SourceID",
	"name":                    "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"path":                    "description.ServerCertificate.ServerCertificateMetadata.Path",
	"server_certificate_id":   "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateId",
	"tags":                    "description.ServerCertificate.Tags",
	"tags_src":                "description.ServerCertificate.Tags",
	"title":                   "description.ServerCertificate.ServerCertificateMetadata.ServerCertificateName",
	"upload_date":             "description.ServerCertificate.ServerCertificateMetadata.UploadDate",
}

func GetIAMServerCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMServerCertificate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMServerCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMServerCertificateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMServerCertificate =============================

// ==========================  START: IAMPolicy =============================

type IAMPolicy struct {
	Description   aws.IAMPolicyDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type IAMPolicyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IAMPolicy     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IAMPolicyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IAMPolicyHit    `json:"hits"`
}

type IAMPolicySearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  IAMPolicyHits `json:"hits"`
}

type IAMPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (IAMPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_policy", filters, limit)
	if err != nil {
		return IAMPolicyPaginator{}, err
	}

	p := IAMPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMPolicyPaginator) NextPage(ctx context.Context) ([]IAMPolicy, error) {
	var response IAMPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMPolicyFilters = map[string]string{
	"arn":                              "description.Policy.Arn",
	"attachment_count":                 "description.Policy.AttachmentCount",
	"create_date":                      "description.Policy.CreateDate",
	"default_version_id":               "description.Policy.DefaultVersionId",
	"is_attachable":                    "description.Policy.IsAttachable",
	"og_account_id":                    "metadata.SourceID",
	"name":                             "description.Policy.PolicyName",
	"path":                             "description.Policy.Path",
	"permissions_boundary_usage_count": "description.Policy.PermissionsBoundaryUsageCount",
	"policy_id":                        "description.Policy.PolicyId",
	"tags_src":                         "description.Policy.Tags",
	"title":                            "description.Policy.PolicyName",
	"update_date":                      "description.Policy.UpdateDate",
}

func ListIAMPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicy NewIAMPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMPolicyFilters = map[string]string{
	"arn":                              "description.Policy.Arn",
	"attachment_count":                 "description.Policy.AttachmentCount",
	"create_date":                      "description.Policy.CreateDate",
	"default_version_id":               "description.Policy.DefaultVersionId",
	"is_attachable":                    "description.Policy.IsAttachable",
	"og_account_id":                    "metadata.SourceID",
	"name":                             "description.Policy.PolicyName",
	"path":                             "description.Policy.Path",
	"permissions_boundary_usage_count": "description.Policy.PermissionsBoundaryUsageCount",
	"policy_id":                        "description.Policy.PolicyId",
	"tags_src":                         "description.Policy.Tags",
	"title":                            "description.Policy.PolicyName",
	"update_date":                      "description.Policy.UpdateDate",
}

func GetIAMPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMPolicy =============================

// ==========================  START: IAMCredentialReport =============================

type IAMCredentialReport struct {
	Description   aws.IAMCredentialReportDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type IAMCredentialReportHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  IAMCredentialReport `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type IAMCredentialReportHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []IAMCredentialReportHit `json:"hits"`
}

type IAMCredentialReportSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  IAMCredentialReportHits `json:"hits"`
}

type IAMCredentialReportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMCredentialReportPaginator(filters []essdk.BoolFilter, limit *int64) (IAMCredentialReportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_credentialreport", filters, limit)
	if err != nil {
		return IAMCredentialReportPaginator{}, err
	}

	p := IAMCredentialReportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMCredentialReportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMCredentialReportPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMCredentialReportPaginator) NextPage(ctx context.Context) ([]IAMCredentialReport, error) {
	var response IAMCredentialReportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMCredentialReport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMCredentialReportFilters = map[string]string{
	"access_key_1_active":            "description.CredentialReport.AccessKey1Active",
	"access_key_1_last_rotated":      "description.CredentialReport.AccessKey1LastRotated",
	"access_key_1_last_used_date":    "description.CredentialReport.AccessKey1LastUsedDate",
	"access_key_1_last_used_region":  "description.CredentialReport.AccessKey1LastUsedRegion",
	"access_key_1_last_used_service": "description.CredentialReport.AccessKey1LastUsedService",
	"access_key_2_active":            "description.CredentialReport.AccessKey2Active",
	"access_key_2_last_rotated":      "description.CredentialReport.AccessKey2LastRotated",
	"access_key_2_last_used_date":    "description.CredentialReport.AccessKey2LastUsedDate",
	"access_key_2_last_used_region":  "description.CredentialReport.AccessKey2LastUsedRegion",
	"access_key_2_last_used_service": "description.CredentialReport.AccessKey2LastUsedService",
	"cert_1_active":                  "description.CredentialReport.Cert1Active",
	"cert_1_last_rotated":            "description.CredentialReport.Cert1LastRotated",
	"cert_2_active":                  "description.CredentialReport.Cert2Active",
	"cert_2_last_rotated":            "description.CredentialReport.Cert2LastRotated",
	"generated_time":                 "description.CredentialReport.GeneratedTime",
	"og_account_id":                  "metadata.SourceID",
	"mfa_active":                     "description.CredentialReport.MFAActive",
	"password_last_changed":          "description.CredentialReport.PasswordLastChanged",
	"password_last_used":             "description.CredentialReport.PasswordLastUsed",
	"password_next_rotation":         "description.CredentialReport.PasswordNextRotation",
	"user_arn":                       "description.CredentialReport.UserArn",
	"user_creation_time":             "description.CredentialReport.UserCreationTime",
	"user_name":                      "description.CredentialReport.UserName",
}

func ListIAMCredentialReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMCredentialReport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMCredentialReport NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMCredentialReport NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMCredentialReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMCredentialReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMCredentialReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMCredentialReportPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMCredentialReportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMCredentialReport NewIAMCredentialReportPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMCredentialReport paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMCredentialReportFilters = map[string]string{
	"access_key_1_active":            "description.CredentialReport.AccessKey1Active",
	"access_key_1_last_rotated":      "description.CredentialReport.AccessKey1LastRotated",
	"access_key_1_last_used_date":    "description.CredentialReport.AccessKey1LastUsedDate",
	"access_key_1_last_used_region":  "description.CredentialReport.AccessKey1LastUsedRegion",
	"access_key_1_last_used_service": "description.CredentialReport.AccessKey1LastUsedService",
	"access_key_2_active":            "description.CredentialReport.AccessKey2Active",
	"access_key_2_last_rotated":      "description.CredentialReport.AccessKey2LastRotated",
	"access_key_2_last_used_date":    "description.CredentialReport.AccessKey2LastUsedDate",
	"access_key_2_last_used_region":  "description.CredentialReport.AccessKey2LastUsedRegion",
	"access_key_2_last_used_service": "description.CredentialReport.AccessKey2LastUsedService",
	"cert_1_active":                  "description.CredentialReport.Cert1Active",
	"cert_1_last_rotated":            "description.CredentialReport.Cert1LastRotated",
	"cert_2_active":                  "description.CredentialReport.Cert2Active",
	"cert_2_last_rotated":            "description.CredentialReport.Cert2LastRotated",
	"generated_time":                 "description.CredentialReport.GeneratedTime",
	"og_account_id":                  "metadata.SourceID",
	"mfa_active":                     "description.CredentialReport.MFAActive",
	"password_last_changed":          "description.CredentialReport.PasswordLastChanged",
	"password_last_used":             "description.CredentialReport.PasswordLastUsed",
	"password_next_rotation":         "description.CredentialReport.PasswordNextRotation",
	"user_arn":                       "description.CredentialReport.UserArn",
	"user_creation_time":             "description.CredentialReport.UserCreationTime",
	"user_name":                      "description.CredentialReport.UserName",
}

func GetIAMCredentialReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMCredentialReport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMCredentialReportPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMCredentialReportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMCredentialReport =============================

// ==========================  START: IAMVirtualMFADevice =============================

type IAMVirtualMFADevice struct {
	Description   aws.IAMVirtualMFADeviceDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type IAMVirtualMFADeviceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  IAMVirtualMFADevice `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type IAMVirtualMFADeviceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []IAMVirtualMFADeviceHit `json:"hits"`
}

type IAMVirtualMFADeviceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  IAMVirtualMFADeviceHits `json:"hits"`
}

type IAMVirtualMFADevicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMVirtualMFADevicePaginator(filters []essdk.BoolFilter, limit *int64) (IAMVirtualMFADevicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_virtualmfadevice", filters, limit)
	if err != nil {
		return IAMVirtualMFADevicePaginator{}, err
	}

	p := IAMVirtualMFADevicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMVirtualMFADevicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMVirtualMFADevicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMVirtualMFADevicePaginator) NextPage(ctx context.Context) ([]IAMVirtualMFADevice, error) {
	var response IAMVirtualMFADeviceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMVirtualMFADevice
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMVirtualMFADeviceFilters = map[string]string{
	"enable_date":   "description.VirtualMFADevice.EnableDate",
	"og_account_id": "metadata.SourceID",
	"serial_number": "description.VirtualMFADevice.SerialNumber",
	"tags_src":      "description.Tags",
	"title":         "description.VirtualMFADevice.SerialNumber",
	"user":          "description.VirtualMFADevice.User",
	"user_id":       "description.VirtualMFADevice.User.UserId",
	"user_name":     "description.VirtualMFADevice.User.UserName",
}

func ListIAMVirtualMFADevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMVirtualMFADevice")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMVirtualMFADevice NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMVirtualMFADevice NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMVirtualMFADevice GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMVirtualMFADevice GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMVirtualMFADevice GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMVirtualMFADevicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMVirtualMFADeviceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMVirtualMFADevice NewIAMVirtualMFADevicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMVirtualMFADevice paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMVirtualMFADeviceFilters = map[string]string{
	"enable_date":   "description.VirtualMFADevice.EnableDate",
	"og_account_id": "metadata.SourceID",
	"serial_number": "description.VirtualMFADevice.SerialNumber",
	"tags_src":      "description.Tags",
	"title":         "description.VirtualMFADevice.SerialNumber",
	"user":          "description.VirtualMFADevice.User",
	"user_id":       "description.VirtualMFADevice.User.UserId",
	"user_name":     "description.VirtualMFADevice.User.UserName",
}

func GetIAMVirtualMFADevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMVirtualMFADevice")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMVirtualMFADevicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMVirtualMFADeviceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMVirtualMFADevice =============================

// ==========================  START: IAMPolicyAttachment =============================

type IAMPolicyAttachment struct {
	Description   aws.IAMPolicyAttachmentDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type IAMPolicyAttachmentHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  IAMPolicyAttachment `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type IAMPolicyAttachmentHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []IAMPolicyAttachmentHit `json:"hits"`
}

type IAMPolicyAttachmentSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  IAMPolicyAttachmentHits `json:"hits"`
}

type IAMPolicyAttachmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMPolicyAttachmentPaginator(filters []essdk.BoolFilter, limit *int64) (IAMPolicyAttachmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_policyattachment", filters, limit)
	if err != nil {
		return IAMPolicyAttachmentPaginator{}, err
	}

	p := IAMPolicyAttachmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMPolicyAttachmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMPolicyAttachmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMPolicyAttachmentPaginator) NextPage(ctx context.Context) ([]IAMPolicyAttachment, error) {
	var response IAMPolicyAttachmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMPolicyAttachment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMPolicyAttachmentFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"policy_arn":    "description.PolicyArn",
	"policy_groups": "description.PolicyGroups",
	"policy_roles":  "description.PolicyRoles",
	"policy_users":  "description.PolicyUsers",
}

func ListIAMPolicyAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMPolicyAttachment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicyAttachment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicyAttachment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicyAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicyAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicyAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMPolicyAttachmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMPolicyAttachmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMPolicyAttachment NewIAMPolicyAttachmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMPolicyAttachment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMPolicyAttachmentFilters = map[string]string{
	"is_attached":   "description.IsAttached",
	"og_account_id": "metadata.SourceID",
	"policy_arn":    "description.PolicyArn",
	"policy_groups": "description.PolicyGroups",
	"policy_roles":  "description.PolicyRoles",
	"policy_users":  "description.PolicyUsers",
}

func GetIAMPolicyAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMPolicyAttachment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMPolicyAttachmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMPolicyAttachmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMPolicyAttachment =============================

// ==========================  START: IAMSamlProvider =============================

type IAMSamlProvider struct {
	Description   aws.IAMSamlProviderDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type IAMSamlProviderHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  IAMSamlProvider `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type IAMSamlProviderHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []IAMSamlProviderHit `json:"hits"`
}

type IAMSamlProviderSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  IAMSamlProviderHits `json:"hits"`
}

type IAMSamlProviderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMSamlProviderPaginator(filters []essdk.BoolFilter, limit *int64) (IAMSamlProviderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_samlprovider", filters, limit)
	if err != nil {
		return IAMSamlProviderPaginator{}, err
	}

	p := IAMSamlProviderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMSamlProviderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMSamlProviderPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMSamlProviderPaginator) NextPage(ctx context.Context) ([]IAMSamlProvider, error) {
	var response IAMSamlProviderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMSamlProvider
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMSamlProviderFilters = map[string]string{
	"arn":                    "arn",
	"create_date":            "description.SamlProvider.CreateDate",
	"og_account_id":          "metadata.SourceID",
	"saml_metadata_document": "description.SamlProvider.SAMLMetadataDocument",
	"tags_src":               "description.SamlProvider.Tags",
	"valid_until":            "description.SamlProvider.ValidUntil",
}

func ListIAMSamlProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMSamlProvider")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSamlProvider NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSamlProvider NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSamlProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSamlProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSamlProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMSamlProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMSamlProviderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMSamlProvider NewIAMSamlProviderPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMSamlProvider paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMSamlProviderFilters = map[string]string{
	"arn":                    "ARN",
	"create_date":            "description.SamlProvider.CreateDate",
	"og_account_id":          "metadata.SourceID",
	"saml_metadata_document": "description.SamlProvider.SAMLMetadataDocument",
	"tags_src":               "description.SamlProvider.Tags",
	"valid_until":            "description.SamlProvider.ValidUntil",
}

func GetIAMSamlProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMSamlProvider")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMSamlProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMSamlProviderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMSamlProvider =============================

// ==========================  START: IAMServiceSpecificCredential =============================

type IAMServiceSpecificCredential struct {
	Description   aws.IAMServiceSpecificCredentialDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type IAMServiceSpecificCredentialHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  IAMServiceSpecificCredential `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type IAMServiceSpecificCredentialHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []IAMServiceSpecificCredentialHit `json:"hits"`
}

type IAMServiceSpecificCredentialSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  IAMServiceSpecificCredentialHits `json:"hits"`
}

type IAMServiceSpecificCredentialPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMServiceSpecificCredentialPaginator(filters []essdk.BoolFilter, limit *int64) (IAMServiceSpecificCredentialPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_servicespecificcredential", filters, limit)
	if err != nil {
		return IAMServiceSpecificCredentialPaginator{}, err
	}

	p := IAMServiceSpecificCredentialPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMServiceSpecificCredentialPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMServiceSpecificCredentialPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMServiceSpecificCredentialPaginator) NextPage(ctx context.Context) ([]IAMServiceSpecificCredential, error) {
	var response IAMServiceSpecificCredentialSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMServiceSpecificCredential
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMServiceSpecificCredentialFilters = map[string]string{
	"create_date":                    "description.ServiceSpecificCredential.CreateDate",
	"og_account_id":                  "metadata.SourceID",
	"service_name":                   "description.ServiceSpecificCredential.ServiceName",
	"service_specific_credential_id": "description.ServiceSpecificCredential.ServiceSpecificCredentialId",
	"service_user_name":              "description.ServiceSpecificCredential.ServiceUserName",
	"status":                         "description.ServiceSpecificCredential.Status",
	"title":                          "description.ServiceSpecificCredential.ServiceName",
	"user_name":                      "description.ServiceSpecificCredential.UserName",
}

func ListIAMServiceSpecificCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMServiceSpecificCredential")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServiceSpecificCredential NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServiceSpecificCredential NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServiceSpecificCredential GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServiceSpecificCredential GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServiceSpecificCredential GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMServiceSpecificCredentialPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMServiceSpecificCredentialFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMServiceSpecificCredential NewIAMServiceSpecificCredentialPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMServiceSpecificCredential paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMServiceSpecificCredentialFilters = map[string]string{
	"create_date":                    "description.ServiceSpecificCredential.CreateDate",
	"og_account_id":                  "metadata.SourceID",
	"service_name":                   "description.ServiceSpecificCredential.ServiceName",
	"service_specific_credential_id": "description.ServiceSpecificCredential.ServiceSpecificCredentialId",
	"service_user_name":              "description.ServiceSpecificCredential.ServiceUserName",
	"status":                         "description.ServiceSpecificCredential.Status",
	"title":                          "description.ServiceSpecificCredential.ServiceName",
	"user_name":                      "description.ServiceSpecificCredential.UserName",
}

func GetIAMServiceSpecificCredential(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMServiceSpecificCredential")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMServiceSpecificCredentialPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMServiceSpecificCredentialFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMServiceSpecificCredential =============================

// ==========================  START: IAMOpenIdConnectProvider =============================

type IAMOpenIdConnectProvider struct {
	Description   aws.IAMOpenIdConnectProviderDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type IAMOpenIdConnectProviderHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  IAMOpenIdConnectProvider `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type IAMOpenIdConnectProviderHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []IAMOpenIdConnectProviderHit `json:"hits"`
}

type IAMOpenIdConnectProviderSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  IAMOpenIdConnectProviderHits `json:"hits"`
}

type IAMOpenIdConnectProviderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIAMOpenIdConnectProviderPaginator(filters []essdk.BoolFilter, limit *int64) (IAMOpenIdConnectProviderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_iam_openidconnectprovider", filters, limit)
	if err != nil {
		return IAMOpenIdConnectProviderPaginator{}, err
	}

	p := IAMOpenIdConnectProviderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IAMOpenIdConnectProviderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IAMOpenIdConnectProviderPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IAMOpenIdConnectProviderPaginator) NextPage(ctx context.Context) ([]IAMOpenIdConnectProvider, error) {
	var response IAMOpenIdConnectProviderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IAMOpenIdConnectProvider
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIAMOpenIdConnectProviderFilters = map[string]string{
	"client_id_list":  "description.ClientIDList",
	"create_date":     "description.CreateDate",
	"og_account_id":   "metadata.SourceID",
	"tags_src":        "description.Tags",
	"thumbprint_list": "description.ThumbprintList",
	"url":             "description.URL",
}

func ListIAMOpenIdConnectProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIAMOpenIdConnectProvider")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMOpenIdConnectProvider NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMOpenIdConnectProvider NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMOpenIdConnectProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMOpenIdConnectProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMOpenIdConnectProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIAMOpenIdConnectProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIAMOpenIdConnectProviderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIAMOpenIdConnectProvider NewIAMOpenIdConnectProviderPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIAMOpenIdConnectProvider paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIAMOpenIdConnectProviderFilters = map[string]string{
	"client_id_list":  "description.ClientIDList",
	"create_date":     "description.CreateDate",
	"og_account_id":   "metadata.SourceID",
	"tags_src":        "description.Tags",
	"thumbprint_list": "description.ThumbprintList",
	"url":             "description.URL",
}

func GetIAMOpenIdConnectProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIAMOpenIdConnectProvider")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIAMOpenIdConnectProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIAMOpenIdConnectProviderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IAMOpenIdConnectProvider =============================

// ==========================  START: RDSDBCluster =============================

type RDSDBCluster struct {
	Description   aws.RDSDBClusterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type RDSDBClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RDSDBClusterHit `json:"hits"`
}

type RDSDBClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  RDSDBClusterHits `json:"hits"`
}

type RDSDBClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBClusterPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbcluster", filters, limit)
	if err != nil {
		return RDSDBClusterPaginator{}, err
	}

	p := RDSDBClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBClusterPaginator) NextPage(ctx context.Context) ([]RDSDBCluster, error) {
	var response RDSDBClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBClusterFilters = map[string]string{
	"activity_stream_kinesis_stream_name": "description.DBCluster.ActivityStreamKinesisStreamName",
	"activity_stream_kms_key_id":          "description.DBCluster.ActivityStreamKmsKeyId",
	"activity_stream_mode":                "description.DBCluster.ActivityStreamMode",
	"activity_stream_status":              "description.DBCluster.ActivityStreamStatus",
	"allocated_storage":                   "description.DBCluster.AllocatedStorage",
	"arn":                                 "arn",
	"associated_roles":                    "description.DBCluster.AssociatedRoles",
	"auto_minor_version_upgrade":          "description.DBCluster.AutoMinorVersionUpgrade",
	"availability_zones":                  "description.DBCluster.AvailabilityZones",
	"backtrack_consumed_change_records":   "description.DBCluster.BacktrackConsumedChangeRecords",
	"backtrack_window":                    "description.DBCluster.BacktrackWindow",
	"backup_retention_period":             "description.DBCluster.BackupRetentionPeriod",
	"capacity":                            "description.DBCluster.Capacity",
	"character_set_name":                  "description.DBCluster.CharacterSetName",
	"clone_group_id":                      "description.DBCluster.CloneGroupId",
	"copy_tags_to_snapshot":               "description.DBCluster.CopyTagsToSnapshot",
	"create_time":                         "description.DBCluster.ClusterCreateTime",
	"cross_account_clone":                 "description.DBCluster.CrossAccountClone",
	"custom_endpoints":                    "description.DBCluster.CustomEndpoints",
	"database_name":                       "description.DBCluster.DatabaseName",
	"db_cluster_identifier":               "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":          "description.DBCluster.DBClusterParameterGroup",
	"db_subnet_group":                     "description.DBCluster.DBSubnetGroup",
	"deletion_protection":                 "description.DBCluster.DeletionProtection",
	"domain_memberships":                  "description.DBCluster.DomainMemberships",
	"earliest_backtrack_time":             "description.DBCluster.EarliestBacktrackTime",
	"earliest_restorable_time":            "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.DBCluster.Endpoint",
	"engine":                              "description.DBCluster.Engine",
	"engine_mode":                         "description.DBCluster.EngineMode",
	"engine_version":                      "description.DBCluster.EngineVersion",
	"global_write_forwarding_requested":   "description.DBCluster.GlobalWriteForwardingRequested",
	"global_write_forwarding_status":      "description.DBCluster.GlobalWriteForwardingStatus",
	"hosted_zone_id":                      "description.DBCluster.HostedZoneId",
	"http_endpoint_enabled":               "description.DBCluster.HttpEndpointEnabled",
	"iam_database_authentication_enabled": "description.DBCluster.IAMDatabaseAuthenticationEnabled",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.DBCluster.KmsKeyId",
	"latest_restorable_time":              "description.DBCluster.LatestRestorableTime",
	"master_user_name":                    "description.DBCluster.MasterUsername",
	"members":                             "description.DBCluster.DBClusterMembers",
	"multi_az":                            "description.DBCluster.MultiAZ",
	"option_group_memberships":            "description.DBCluster.DBClusterOptionGroupMemberships",
	"pending_maintenance_actions":         "description.PendingMaintenanceActions",
	"percent_progress":                    "description.DBCluster.PercentProgress",
	"port":                                "description.DBCluster.Port",
	"preferred_backup_window":             "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.DBCluster.ReaderEndpoint",
	"resource_id":                         "description.DBCluster.DbClusterResourceId",
	"status":                              "description.DBCluster.Status",
	"storage_encrypted":                   "description.DBCluster.StorageEncrypted",
	"tags_src":                            "description.DBCluster.TagList",
	"title":                               "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.DBCluster.VpcSecurityGroups",
}

func ListRDSDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBCluster NewRDSDBClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBClusterFilters = map[string]string{
	"activity_stream_kinesis_stream_name": "description.DBCluster.ActivityStreamKinesisStreamName",
	"activity_stream_kms_key_id":          "description.DBCluster.ActivityStreamKmsKeyId",
	"activity_stream_mode":                "description.DBCluster.ActivityStreamMode",
	"activity_stream_status":              "description.DBCluster.ActivityStreamStatus",
	"allocated_storage":                   "description.DBCluster.AllocatedStorage",
	"arn":                                 "arn",
	"associated_roles":                    "description.DBCluster.AssociatedRoles",
	"auto_minor_version_upgrade":          "description.DBCluster.AutoMinorVersionUpgrade",
	"availability_zones":                  "description.DBCluster.AvailabilityZones",
	"backtrack_consumed_change_records":   "description.DBCluster.BacktrackConsumedChangeRecords",
	"backtrack_window":                    "description.DBCluster.BacktrackWindow",
	"backup_retention_period":             "description.DBCluster.BackupRetentionPeriod",
	"capacity":                            "description.DBCluster.Capacity",
	"character_set_name":                  "description.DBCluster.CharacterSetName",
	"clone_group_id":                      "description.DBCluster.CloneGroupId",
	"copy_tags_to_snapshot":               "description.DBCluster.CopyTagsToSnapshot",
	"create_time":                         "description.DBCluster.ClusterCreateTime",
	"cross_account_clone":                 "description.DBCluster.CrossAccountClone",
	"custom_endpoints":                    "description.DBCluster.CustomEndpoints",
	"database_name":                       "description.DBCluster.DatabaseName",
	"db_cluster_identifier":               "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":          "description.DBCluster.DBClusterParameterGroup",
	"db_subnet_group":                     "description.DBCluster.DBSubnetGroup",
	"deletion_protection":                 "description.DBCluster.DeletionProtection",
	"domain_memberships":                  "description.DBCluster.DomainMemberships",
	"earliest_backtrack_time":             "description.DBCluster.EarliestBacktrackTime",
	"earliest_restorable_time":            "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.DBCluster.Endpoint",
	"engine":                              "description.DBCluster.Engine",
	"engine_mode":                         "description.DBCluster.EngineMode",
	"engine_version":                      "description.DBCluster.EngineVersion",
	"global_write_forwarding_requested":   "description.DBCluster.GlobalWriteForwardingRequested",
	"global_write_forwarding_status":      "description.DBCluster.GlobalWriteForwardingStatus",
	"hosted_zone_id":                      "description.DBCluster.HostedZoneId",
	"http_endpoint_enabled":               "description.DBCluster.HttpEndpointEnabled",
	"iam_database_authentication_enabled": "description.DBCluster.IAMDatabaseAuthenticationEnabled",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.DBCluster.KmsKeyId",
	"latest_restorable_time":              "description.DBCluster.LatestRestorableTime",
	"master_user_name":                    "description.DBCluster.MasterUsername",
	"members":                             "description.DBCluster.DBClusterMembers",
	"multi_az":                            "description.DBCluster.MultiAZ",
	"option_group_memberships":            "description.DBCluster.DBClusterOptionGroupMemberships",
	"pending_maintenance_actions":         "description.PendingMaintenanceActions",
	"percent_progress":                    "description.DBCluster.PercentProgress",
	"port":                                "description.DBCluster.Port",
	"preferred_backup_window":             "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.DBCluster.ReaderEndpoint",
	"resource_id":                         "description.DBCluster.DbClusterResourceId",
	"status":                              "description.DBCluster.Status",
	"storage_encrypted":                   "description.DBCluster.StorageEncrypted",
	"tags_src":                            "description.DBCluster.TagList",
	"title":                               "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.DBCluster.VpcSecurityGroups",
}

func GetRDSDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBCluster =============================

// ==========================  START: RDSDBClusterParameterGroup =============================

type RDSDBClusterParameterGroup struct {
	Description   aws.RDSDBClusterParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type RDSDBClusterParameterGroupHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  RDSDBClusterParameterGroup `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type RDSDBClusterParameterGroupHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []RDSDBClusterParameterGroupHit `json:"hits"`
}

type RDSDBClusterParameterGroupSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  RDSDBClusterParameterGroupHits `json:"hits"`
}

type RDSDBClusterParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBClusterParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBClusterParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbclusterparametergroup", filters, limit)
	if err != nil {
		return RDSDBClusterParameterGroupPaginator{}, err
	}

	p := RDSDBClusterParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBClusterParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBClusterParameterGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBClusterParameterGroupPaginator) NextPage(ctx context.Context) ([]RDSDBClusterParameterGroup, error) {
	var response RDSDBClusterParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBClusterParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBClusterParameterGroupFilters = map[string]string{
	"arn":                       "description.DBClusterParameterGroup.DBClusterParameterGroupArn",
	"db_parameter_group_family": "description.DBClusterParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBClusterParameterGroup.Description",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.DBClusterParameterGroup.DBClusterParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBClusterParameterGroup.DBClusterParameterGroupName",
}

func ListRDSDBClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBClusterParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterParameterGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterParameterGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBClusterParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBClusterParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterParameterGroup NewRDSDBClusterParameterGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBClusterParameterGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBClusterParameterGroupFilters = map[string]string{
	"arn":                       "description.DBClusterParameterGroup.DBClusterParameterGroupArn",
	"db_parameter_group_family": "description.DBClusterParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBClusterParameterGroup.Description",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.DBClusterParameterGroup.DBClusterParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBClusterParameterGroup.DBClusterParameterGroupName",
}

func GetRDSDBClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBClusterParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBClusterParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBClusterParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBClusterParameterGroup =============================

// ==========================  START: RDSOptionGroup =============================

type RDSOptionGroup struct {
	Description   aws.RDSOptionGroupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type RDSOptionGroupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RDSOptionGroup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RDSOptionGroupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RDSOptionGroupHit `json:"hits"`
}

type RDSOptionGroupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RDSOptionGroupHits `json:"hits"`
}

type RDSOptionGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSOptionGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSOptionGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_optiongroup", filters, limit)
	if err != nil {
		return RDSOptionGroupPaginator{}, err
	}

	p := RDSOptionGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSOptionGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSOptionGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSOptionGroupPaginator) NextPage(ctx context.Context) ([]RDSOptionGroup, error) {
	var response RDSOptionGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSOptionGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSOptionGroupFilters = map[string]string{
	"allows_vpc_and_non_vpc_instance_memberships": "description.OptionGroup.AllowsVpcAndNonVpcInstanceMemberships",
	"arn":                  "description.OptionGroup.OptionGroupArn",
	"description":          "description.OptionGroup.OptionGroupDescription",
	"engine_name":          "description.OptionGroup.EngineName",
	"og_account_id":        "metadata.SourceID",
	"major_engine_version": "description.OptionGroup.MajorEngineVersion",
	"name":                 "description.OptionGroup.OptionGroupName",
	"options":              "description.OptionGroup.Options",
	"tags_src":             "description.Tags.TagList",
	"title":                "description.OptionGroup.OptionGroupName",
	"vpc_id":               "description.OptionGroup.VpcId",
}

func ListRDSOptionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSOptionGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSOptionGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSOptionGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSOptionGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSOptionGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSOptionGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSOptionGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSOptionGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSOptionGroup NewRDSOptionGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSOptionGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSOptionGroupFilters = map[string]string{
	"allows_vpc_and_non_vpc_instance_memberships": "description.OptionGroup.AllowsVpcAndNonVpcInstanceMemberships",
	"arn":                  "description.OptionGroup.OptionGroupArn",
	"description":          "description.OptionGroup.OptionGroupDescription",
	"engine_name":          "description.OptionGroup.EngineName",
	"og_account_id":        "metadata.SourceID",
	"major_engine_version": "description.OptionGroup.MajorEngineVersion",
	"name":                 "description.OptionGroup.OptionGroupName",
	"options":              "description.OptionGroup.Options",
	"tags_src":             "description.Tags.TagList",
	"title":                "description.OptionGroup.OptionGroupName",
	"vpc_id":               "description.OptionGroup.VpcId",
}

func GetRDSOptionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSOptionGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSOptionGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSOptionGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSOptionGroup =============================

// ==========================  START: RDSDBParameterGroup =============================

type RDSDBParameterGroup struct {
	Description   aws.RDSDBParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type RDSDBParameterGroupHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RDSDBParameterGroup `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RDSDBParameterGroupHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RDSDBParameterGroupHit `json:"hits"`
}

type RDSDBParameterGroupSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RDSDBParameterGroupHits `json:"hits"`
}

type RDSDBParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbparametergroup", filters, limit)
	if err != nil {
		return RDSDBParameterGroupPaginator{}, err
	}

	p := RDSDBParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBParameterGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBParameterGroupPaginator) NextPage(ctx context.Context) ([]RDSDBParameterGroup, error) {
	var response RDSDBParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBParameterGroupFilters = map[string]string{
	"arn":                       "arn",
	"db_parameter_group_family": "description.DBParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBParameterGroup.Description",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.DBParameterGroup.DBParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBParameterGroup.DBParameterGroupName",
}

func ListRDSDBParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBParameterGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBParameterGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBParameterGroup NewRDSDBParameterGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBParameterGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBParameterGroupFilters = map[string]string{
	"arn":                       "arn",
	"db_parameter_group_family": "description.DBParameterGroup.DBParameterGroupFamily",
	"description":               "description.DBParameterGroup.Description",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.DBParameterGroup.DBParameterGroupName",
	"parameters":                "description.Parameters",
	"tags_src":                  "description.Tags",
	"title":                     "description.DBParameterGroup.DBParameterGroupName",
}

func GetRDSDBParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBParameterGroup =============================

// ==========================  START: RDSDBProxy =============================

type RDSDBProxy struct {
	Description   aws.RDSDBProxyDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type RDSDBProxyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBProxy    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBProxyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RDSDBProxyHit   `json:"hits"`
}

type RDSDBProxySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RDSDBProxyHits `json:"hits"`
}

type RDSDBProxyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBProxyPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBProxyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbproxy", filters, limit)
	if err != nil {
		return RDSDBProxyPaginator{}, err
	}

	p := RDSDBProxyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBProxyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBProxyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBProxyPaginator) NextPage(ctx context.Context) ([]RDSDBProxy, error) {
	var response RDSDBProxySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBProxy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBProxyFilters = map[string]string{
	"auth":                   "description.DBProxy.Auth",
	"created_date":           "description.DBProxy.CreatedDate",
	"db_proxy_arn":           "description.DBProxy.DBProxyArn",
	"db_proxy_name":          "description.DBProxy.DBProxyName",
	"debug_logging":          "description.DBProxy.DebugLogging",
	"endpoint":               "description.DBProxy.Endpoint",
	"engine_family":          "description.DBProxy.EngineFamily",
	"idle_client_timeout":    "description.DBProxy.IdleClientTimeout",
	"og_account_id":          "metadata.SourceID",
	"require_tls":            "description.DBProxy.RequireTLS",
	"role_arn":               "description.DBProxy.RoleArn",
	"status":                 "description.DBProxy.Status",
	"tags":                   "description.Tags",
	"title":                  "description.DBProxy.DBProxyName",
	"updated_date":           "description.DBProxy.UpdatedDate",
	"vpc_id":                 "description.DBProxy.VpcId",
	"vpc_security_group_ids": "description.DBProxy.VpcSecurityGroupIds",
	"vpc_subnet_ids":         "description.DBProxy.VpcSubnetIds",
}

func ListRDSDBProxy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBProxy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBProxy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBProxy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBProxy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBProxy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBProxy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBProxyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBProxyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBProxy NewRDSDBProxyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBProxy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBProxyFilters = map[string]string{
	"auth":                   "description.DBProxy.Auth",
	"created_date":           "description.DBProxy.CreatedDate",
	"db_proxy_arn":           "description.DBProxy.DBProxyArn",
	"db_proxy_name":          "description.DBProxy.DBProxyName",
	"debug_logging":          "description.DBProxy.DebugLogging",
	"endpoint":               "description.DBProxy.Endpoint",
	"engine_family":          "description.DBProxy.EngineFamily",
	"idle_client_timeout":    "description.DBProxy.IdleClientTimeout",
	"og_account_id":          "metadata.SourceID",
	"require_tls":            "description.DBProxy.RequireTLS",
	"role_arn":               "description.DBProxy.RoleArn",
	"status":                 "description.DBProxy.Status",
	"tags":                   "description.Tags",
	"title":                  "description.DBProxy.DBProxyName",
	"updated_date":           "description.DBProxy.UpdatedDate",
	"vpc_id":                 "description.DBProxy.VpcId",
	"vpc_security_group_ids": "description.DBProxy.VpcSecurityGroupIds",
	"vpc_subnet_ids":         "description.DBProxy.VpcSubnetIds",
}

func GetRDSDBProxy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBProxy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBProxyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBProxyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBProxy =============================

// ==========================  START: RDSDBSubnetGroup =============================

type RDSDBSubnetGroup struct {
	Description   aws.RDSDBSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RDSDBSubnetGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  RDSDBSubnetGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type RDSDBSubnetGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []RDSDBSubnetGroupHit `json:"hits"`
}

type RDSDBSubnetGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  RDSDBSubnetGroupHits `json:"hits"`
}

type RDSDBSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbsubnetgroup", filters, limit)
	if err != nil {
		return RDSDBSubnetGroupPaginator{}, err
	}

	p := RDSDBSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBSubnetGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBSubnetGroupPaginator) NextPage(ctx context.Context) ([]RDSDBSubnetGroup, error) {
	var response RDSDBSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBSubnetGroupFilters = map[string]string{
	"arn":           "description.DBSubnetGroup.DBSubnetGroupArn",
	"description":   "description.DBSubnetGroup.DBSubnetGroupDescription",
	"og_account_id": "metadata.SourceID",
	"name":          "description.DBSubnetGroup.DBSubnetGroupName",
	"status":        "description.DBSubnetGroup.SubnetGroupStatus",
	"subnets":       "description.DBSubnetGroup.Subnets",
	"tags_src":      "description.Tags.TagList",
	"title":         "description.DBSubnetGroup.DBSubnetGroupName",
	"vpc_id":        "description.DBSubnetGroup.VpcId",
}

func ListRDSDBSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSubnetGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSubnetGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSubnetGroup NewRDSDBSubnetGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBSubnetGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBSubnetGroupFilters = map[string]string{
	"arn":           "description.DBSubnetGroup.DBSubnetGroupArn",
	"description":   "description.DBSubnetGroup.DBSubnetGroupDescription",
	"og_account_id": "metadata.SourceID",
	"name":          "description.DBSubnetGroup.DBSubnetGroupName",
	"status":        "description.DBSubnetGroup.SubnetGroupStatus",
	"subnets":       "description.DBSubnetGroup.Subnets",
	"tags_src":      "description.Tags.TagList",
	"title":         "description.DBSubnetGroup.DBSubnetGroupName",
	"vpc_id":        "description.DBSubnetGroup.VpcId",
}

func GetRDSDBSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBSubnetGroup =============================

// ==========================  START: RDSDBClusterSnapshot =============================

type RDSDBClusterSnapshot struct {
	Description   aws.RDSDBClusterSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type RDSDBClusterSnapshotHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  RDSDBClusterSnapshot `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type RDSDBClusterSnapshotHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []RDSDBClusterSnapshotHit `json:"hits"`
}

type RDSDBClusterSnapshotSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  RDSDBClusterSnapshotHits `json:"hits"`
}

type RDSDBClusterSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBClusterSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBClusterSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbclustersnapshot", filters, limit)
	if err != nil {
		return RDSDBClusterSnapshotPaginator{}, err
	}

	p := RDSDBClusterSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBClusterSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBClusterSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBClusterSnapshotPaginator) NextPage(ctx context.Context) ([]RDSDBClusterSnapshot, error) {
	var response RDSDBClusterSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBClusterSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBClusterSnapshotFilters = map[string]string{
	"allocated_storage":                   "description.DBClusterSnapshot.AllocatedStorage",
	"arn":                                 "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"availability_zones":                  "description.DBClusterSnapshot.AvailabilityZones",
	"cluster_create_time":                 "description.DBClusterSnapshot.ClusterCreateTime",
	"create_time":                         "description.DBClusterSnapshot.ClusterCreateTime",
	"db_cluster_identifier":               "description.DBClusterSnapshot.DBClusterIdentifier",
	"db_cluster_snapshot_attributes":      "description.Attributes.DBClusterSnapshotAttributes",
	"db_cluster_snapshot_identifier":      "description.DBClusterSnapshot.DBClusterSnapshotIdentifier",
	"engine":                              "description.DBClusterSnapshot.Engine",
	"engine_version":                      "description.DBClusterSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBClusterSnapshot.IAMDatabaseAuthenticationEnabled",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.DBClusterSnapshot.KmsKeyId",
	"license_model":                       "description.DBClusterSnapshot.LicenseModel",
	"master_user_name":                    "description.DBClusterSnapshot.MasterUsername",
	"percent_progress":                    "description.DBClusterSnapshot.PercentProgress",
	"port":                                "description.DBClusterSnapshot.Port",
	"source_db_cluster_snapshot_arn":      "description.DBClusterSnapshot.SourceDBClusterSnapshotArn",
	"status":                              "description.DBClusterSnapshot.Status",
	"storage_encrypted":                   "description.DBClusterSnapshot.StorageEncrypted",
	"tags_src":                            "description.DBClusterSnapshot.TagList",
	"title":                               "description.DBClusterSnapshot.DBClusterSnapshotIdentifier",
	"type":                                "description.DBClusterSnapshot.SnapshotType",
	"vpc_id":                              "description.DBClusterSnapshot.VpcId",
}

func ListRDSDBClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBClusterSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBClusterSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBClusterSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBClusterSnapshot NewRDSDBClusterSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBClusterSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBClusterSnapshotFilters = map[string]string{
	"allocated_storage":                   "description.DBClusterSnapshot.AllocatedStorage",
	"arn":                                 "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"availability_zones":                  "description.DBClusterSnapshot.AvailabilityZones",
	"cluster_create_time":                 "description.DBClusterSnapshot.ClusterCreateTime",
	"create_time":                         "description.DBClusterSnapshot.ClusterCreateTime",
	"db_cluster_identifier":               "description.DBClusterSnapshot.DBClusterIdentifier",
	"db_cluster_snapshot_attributes":      "description.Attributes.DBClusterSnapshotAttributes",
	"db_cluster_snapshot_identifier":      "description.DBClusterSnapshot.DBClusterIdentifier",
	"engine":                              "description.DBClusterSnapshot.Engine",
	"engine_version":                      "description.DBClusterSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBClusterSnapshot.IAMDatabaseAuthenticationEnabled",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.DBClusterSnapshot.KmsKeyId",
	"license_model":                       "description.DBClusterSnapshot.LicenseModel",
	"master_user_name":                    "description.DBClusterSnapshot.MasterUsername",
	"percent_progress":                    "description.DBClusterSnapshot.PercentProgress",
	"port":                                "description.DBClusterSnapshot.Port",
	"source_db_cluster_snapshot_arn":      "description.DBClusterSnapshot.SourceDBClusterSnapshotArn",
	"status":                              "description.DBClusterSnapshot.Status",
	"storage_encrypted":                   "description.DBClusterSnapshot.StorageEncrypted",
	"tags_src":                            "description.DBClusterSnapshot.TagList",
	"title":                               "description.DBClusterSnapshot.DBClusterSnapshotIdentifier",
	"type":                                "description.DBClusterSnapshot.SnapshotType",
	"vpc_id":                              "description.DBClusterSnapshot.VpcId",
}

func GetRDSDBClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBClusterSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBClusterSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBClusterSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBClusterSnapshot =============================

// ==========================  START: RDSDBEventSubscription =============================

type RDSDBEventSubscription struct {
	Description   aws.RDSDBEventSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type RDSDBEventSubscriptionHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  RDSDBEventSubscription `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type RDSDBEventSubscriptionHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []RDSDBEventSubscriptionHit `json:"hits"`
}

type RDSDBEventSubscriptionSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  RDSDBEventSubscriptionHits `json:"hits"`
}

type RDSDBEventSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBEventSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBEventSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbeventsubscription", filters, limit)
	if err != nil {
		return RDSDBEventSubscriptionPaginator{}, err
	}

	p := RDSDBEventSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBEventSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBEventSubscriptionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBEventSubscriptionPaginator) NextPage(ctx context.Context) ([]RDSDBEventSubscription, error) {
	var response RDSDBEventSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBEventSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBEventSubscriptionFilters = map[string]string{
	"arn":                   "description.EventSubscription.EventSubscriptionArn",
	"cust_subscription_id":  "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":       "description.EventSubscription.CustomerAwsId",
	"enabled":               "description.EventSubscription.Enabled",
	"event_categories_list": "description.EventSubscription.EventCategoriesList",
	"og_account_id":         "metadata.SourceID",
	"sns_topic_arn":         "description.EventSubscription.SnsTopicArn",
	"source_ids_list":       "description.EventSubscription.SourceIdsList",
	"source_type":           "description.EventSubscription.SourceType",
	"status":                "description.EventSubscription.Status",
	"title":                 "description.EventSubscription.CustSubscriptionId",
}

func ListRDSDBEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBEventSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEventSubscription NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEventSubscription NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEventSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEventSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEventSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBEventSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBEventSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEventSubscription NewRDSDBEventSubscriptionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBEventSubscription paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBEventSubscriptionFilters = map[string]string{
	"arn":                   "description.EventSubscription.EventSubscriptionArn",
	"cust_subscription_id":  "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":       "description.EventSubscription.CustomerAwsId",
	"enabled":               "description.EventSubscription.Enabled",
	"event_categories_list": "description.EventSubscription.EventCategoriesList",
	"og_account_id":         "metadata.SourceID",
	"sns_topic_arn":         "description.EventSubscription.SnsTopicArn",
	"source_ids_list":       "description.EventSubscription.SourceIdsList",
	"source_type":           "description.EventSubscription.SourceType",
	"status":                "description.EventSubscription.Status",
	"title":                 "description.EventSubscription.CustSubscriptionId",
}

func GetRDSDBEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBEventSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBEventSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBEventSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBEventSubscription =============================

// ==========================  START: RDSDBInstance =============================

type RDSDBInstance struct {
	Description   aws.RDSDBInstanceDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type RDSDBInstanceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBInstance `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBInstanceHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []RDSDBInstanceHit `json:"hits"`
}

type RDSDBInstanceSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  RDSDBInstanceHits `json:"hits"`
}

type RDSDBInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBInstancePaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbinstance", filters, limit)
	if err != nil {
		return RDSDBInstancePaginator{}, err
	}

	p := RDSDBInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBInstancePaginator) NextPage(ctx context.Context) ([]RDSDBInstance, error) {
	var response RDSDBInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBInstanceFilters = map[string]string{
	"allocated_storage":                          "description.DBInstance.AllocatedStorage",
	"arn":                                        "description.DBInstance.DBInstanceArn",
	"associated_roles":                           "description.DBInstance.AssociatedRoles",
	"auto_minor_version_upgrade":                 "description.DBInstance.AutoMinorVersionUpgrade",
	"availability_zone":                          "description.DBInstance.AvailabilityZone",
	"backup_retention_period":                    "description.DBInstance.BackupRetentionPeriod",
	"ca_certificate_identifier":                  "description.DBInstance.CACertificateIdentifier",
	"certificate":                                "description.Certificate",
	"character_set_name":                         "description.DBInstance.CharacterSetName",
	"class":                                      "description.DBInstance.DBInstanceClass",
	"copy_tags_to_snapshot":                      "description.DBInstance.CopyTagsToSnapshot",
	"create_time":                                "description.DBInstance.InstanceCreateTime",
	"customer_owned_ip_enabled":                  "description.DBInstance.CustomerOwnedIpEnabled",
	"db_cluster_identifier":                      "description.DBInstance.DBClusterIdentifier",
	"db_instance_identifier":                     "description.DBInstance.DBInstanceIdentifier",
	"db_name":                                    "description.DBInstance.DBName",
	"db_parameter_groups":                        "description.DBInstance.DBParameterGroups",
	"db_security_groups":                         "description.DBInstance.DBSecurityGroups",
	"db_subnet_group_arn":                        "description.DBInstance.DBSubnetGroup.DBSubnetGroupArn",
	"db_subnet_group_description":                "description.DBInstance.DBSubnetGroup.DBSubnetGroupDescription",
	"db_subnet_group_name":                       "description.DBInstance.DBSubnetGroup.DBSubnetGroupName",
	"db_subnet_group_status":                     "description.DBInstance.DBSubnetGroup.SubnetGroupStatus",
	"deletion_protection":                        "description.DBInstance.DeletionProtection",
	"domain_memberships":                         "description.DBInstance.DomainMemberships",
	"enabled_cloudwatch_logs_exports":            "description.DBInstance.EnabledCloudwatchLogsExports",
	"endpoint_address":                           "description.DBInstance.Endpoint.Address",
	"endpoint_hosted_zone_id":                    "description.DBInstance.Endpoint.HostedZoneId",
	"endpoint_port":                              "description.DBInstance.Endpoint.Port",
	"engine":                                     "description.DBInstance.Engine",
	"engine_version":                             "description.DBInstance.EngineVersion",
	"enhanced_monitoring_resource_arn":           "description.DBInstance.EnhancedMonitoringResourceArn",
	"iam_database_authentication_enabled":        "description.DBInstance.IAMDatabaseAuthenticationEnabled",
	"iops":                                       "description.DBInstance.Iops",
	"og_account_id":                              "metadata.SourceID",
	"kms_key_id":                                 "description.DBInstance.KmsKeyId",
	"latest_restorable_time":                     "description.DBInstance.LatestRestorableTime",
	"license_model":                              "description.DBInstance.LicenseModel",
	"master_user_name":                           "description.DBInstance.MasterUsername",
	"max_allocated_storage":                      "description.DBInstance.MaxAllocatedStorage",
	"monitoring_interval":                        "description.DBInstance.MonitoringInterval",
	"monitoring_role_arn":                        "description.DBInstance.MonitoringRoleArn",
	"multi_az":                                   "description.DBInstance.MultiAZ",
	"nchar_character_set_name":                   "description.DBInstance.NcharCharacterSetName",
	"option_group_memberships":                   "description.DBInstance.OptionGroupMemberships",
	"pending_maintenance_actions":                "description.PendingMaintenance",
	"performance_insights_enabled":               "description.DBInstance.PerformanceInsightsEnabled",
	"performance_insights_kms_key_id":            "description.DBInstance.PerformanceInsightsKMSKeyId",
	"performance_insights_retention_period":      "description.DBInstance.PerformanceInsightsRetentionPeriod",
	"port":                                       "description.DBInstance.DbInstancePort",
	"preferred_backup_window":                    "description.DBInstance.PreferredBackupWindow",
	"preferred_maintenance_window":               "description.DBInstance.PreferredMaintenanceWindow",
	"processor_features":                         "description.DBInstance.ProcessorFeatures",
	"promotion_tier":                             "description.DBInstance.PromotionTier",
	"publicly_accessible":                        "description.DBInstance.PubliclyAccessible",
	"read_replica_db_cluster_identifiers":        "description.DBInstance.ReadReplicaDBClusterIdentifiers",
	"read_replica_db_instance_identifiers":       "description.DBInstance.ReadReplicaDBInstanceIdentifiers",
	"read_replica_source_db_instance_identifier": "description.DBInstance.ReadReplicaSourceDBInstanceIdentifier",
	"replica_mode":                               "description.DBInstance.ReplicaMode",
	"resource_id":                                "description.DBInstance.DbiResourceId",
	"secondary_availability_zone":                "description.DBInstance.SecondaryAvailabilityZone",
	"status":                                     "description.DBInstance.DBInstanceStatus",
	"status_infos":                               "description.DBInstance.StatusInfos",
	"storage_encrypted":                          "description.DBInstance.StorageEncrypted",
	"storage_throughput":                         "description.DBInstance.StorageThroughput",
	"storage_type":                               "description.DBInstance.StorageType",
	"subnets":                                    "description.DBInstance.DBSubnetGroup.Subnets",
	"tags_src":                                   "description.DBInstance.TagList",
	"tde_credential_arn":                         "description.DBInstance.TdeCredentialArn",
	"timezone":                                   "description.DBInstance.Timezone",
	"title":                                      "description.DBInstance.DBInstanceIdentifier",
	"vpc_id":                                     "description.DBInstance.DBSubnetGroup.VpcId",
	"vpc_security_groups":                        "description.DBInstance.VpcSecurityGroups",
}

func ListRDSDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstance NewRDSDBInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBInstanceFilters = map[string]string{
	"allocated_storage":                          "description.DBInstance.AllocatedStorage",
	"arn":                                        "description.DBInstance.DBInstanceArn",
	"associated_roles":                           "description.DBInstance.AssociatedRoles",
	"auto_minor_version_upgrade":                 "description.DBInstance.AutoMinorVersionUpgrade",
	"availability_zone":                          "description.DBInstance.AvailabilityZone",
	"backup_retention_period":                    "description.DBInstance.BackupRetentionPeriod",
	"ca_certificate_identifier":                  "description.DBInstance.CACertificateIdentifier",
	"certificate":                                "description.Certificate",
	"character_set_name":                         "description.DBInstance.CharacterSetName",
	"class":                                      "description.DBInstance.DBInstanceClass",
	"copy_tags_to_snapshot":                      "description.DBInstance.CopyTagsToSnapshot",
	"create_time":                                "description.DBInstance.InstanceCreateTime",
	"customer_owned_ip_enabled":                  "description.DBInstance.CustomerOwnedIpEnabled",
	"db_cluster_identifier":                      "description.DBInstance.DBClusterIdentifier",
	"db_instance_identifier":                     "description.DBInstance.DBInstanceIdentifier",
	"db_name":                                    "description.DBInstance.DBName",
	"db_parameter_groups":                        "description.DBInstance.DBParameterGroups",
	"db_security_groups":                         "description.DBInstance.DBSecurityGroups",
	"db_subnet_group_arn":                        "description.DBInstance.DBSubnetGroup.DBSubnetGroupArn",
	"db_subnet_group_description":                "description.DBInstance.DBSubnetGroup.DBSubnetGroupDescription",
	"db_subnet_group_name":                       "description.DBInstance.DBSubnetGroup.DBSubnetGroupName",
	"db_subnet_group_status":                     "description.DBInstance.DBSubnetGroup.SubnetGroupStatus",
	"deletion_protection":                        "description.DBInstance.DeletionProtection",
	"domain_memberships":                         "description.DBInstance.DomainMemberships",
	"enabled_cloudwatch_logs_exports":            "description.DBInstance.EnabledCloudwatchLogsExports",
	"endpoint_address":                           "description.DBInstance.Endpoint.Address",
	"endpoint_hosted_zone_id":                    "description.DBInstance.Endpoint.HostedZoneId",
	"endpoint_port":                              "description.DBInstance.Endpoint.Port",
	"engine":                                     "description.DBInstance.Engine",
	"engine_version":                             "description.DBInstance.EngineVersion",
	"enhanced_monitoring_resource_arn":           "description.DBInstance.EnhancedMonitoringResourceArn",
	"iam_database_authentication_enabled":        "description.DBInstance.IAMDatabaseAuthenticationEnabled",
	"iops":                                       "description.DBInstance.Iops",
	"og_account_id":                              "metadata.SourceID",
	"kms_key_id":                                 "description.DBInstance.KmsKeyId",
	"latest_restorable_time":                     "description.DBInstance.LatestRestorableTime",
	"license_model":                              "description.DBInstance.LicenseModel",
	"master_user_name":                           "description.DBInstance.MasterUsername",
	"max_allocated_storage":                      "description.DBInstance.MaxAllocatedStorage",
	"monitoring_interval":                        "description.DBInstance.MonitoringInterval",
	"monitoring_role_arn":                        "description.DBInstance.MonitoringRoleArn",
	"multi_az":                                   "description.DBInstance.MultiAZ",
	"nchar_character_set_name":                   "description.DBInstance.NcharCharacterSetName",
	"option_group_memberships":                   "description.DBInstance.OptionGroupMemberships",
	"pending_maintenance_actions":                "description.PendingMaintenance",
	"performance_insights_enabled":               "description.DBInstance.PerformanceInsightsEnabled",
	"performance_insights_kms_key_id":            "description.DBInstance.PerformanceInsightsKMSKeyId",
	"performance_insights_retention_period":      "description.DBInstance.PerformanceInsightsRetentionPeriod",
	"port":                                       "description.DBInstance.DbInstancePort",
	"preferred_backup_window":                    "description.DBInstance.PreferredBackupWindow",
	"preferred_maintenance_window":               "description.DBInstance.PreferredMaintenanceWindow",
	"processor_features":                         "description.DBInstance.ProcessorFeatures",
	"promotion_tier":                             "description.DBInstance.PromotionTier",
	"publicly_accessible":                        "description.DBInstance.PubliclyAccessible",
	"read_replica_db_cluster_identifiers":        "description.DBInstance.ReadReplicaDBClusterIdentifiers",
	"read_replica_db_instance_identifiers":       "description.DBInstance.ReadReplicaDBInstanceIdentifiers",
	"read_replica_source_db_instance_identifier": "description.DBInstance.ReadReplicaSourceDBInstanceIdentifier",
	"replica_mode":                               "description.DBInstance.ReplicaMode",
	"resource_id":                                "description.DBInstance.DbiResourceId",
	"secondary_availability_zone":                "description.DBInstance.SecondaryAvailabilityZone",
	"status":                                     "description.DBInstance.DBInstanceStatus",
	"status_infos":                               "description.DBInstance.StatusInfos",
	"storage_encrypted":                          "description.DBInstance.StorageEncrypted",
	"storage_throughput":                         "description.DBInstance.StorageThroughput",
	"storage_type":                               "description.DBInstance.StorageType",
	"subnets":                                    "description.DBInstance.DBSubnetGroup.Subnets",
	"tags_src":                                   "description.DBInstance.TagList",
	"tde_credential_arn":                         "description.DBInstance.TdeCredentialArn",
	"timezone":                                   "description.DBInstance.Timezone",
	"title":                                      "description.DBInstance.DBInstanceIdentifier",
	"vpc_id":                                     "description.DBInstance.DBSubnetGroup.VpcId",
	"vpc_security_groups":                        "description.DBInstance.VpcSecurityGroups",
}

func GetRDSDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBInstance =============================

// ==========================  START: RDSDBSnapshot =============================

type RDSDBSnapshot struct {
	Description   aws.RDSDBSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type RDSDBSnapshotHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RDSDBSnapshot `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RDSDBSnapshotHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []RDSDBSnapshotHit `json:"hits"`
}

type RDSDBSnapshotSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  RDSDBSnapshotHits `json:"hits"`
}

type RDSDBSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbsnapshot", filters, limit)
	if err != nil {
		return RDSDBSnapshotPaginator{}, err
	}

	p := RDSDBSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBSnapshotPaginator) NextPage(ctx context.Context) ([]RDSDBSnapshot, error) {
	var response RDSDBSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBSnapshotFilters = map[string]string{
	"allocated_storage":                   "description.DBSnapshot.AllocatedStorage",
	"arn":                                 "description.DBSnapshot.DBSnapshotArn",
	"availability_zone":                   "description.DBSnapshot.AvailabilityZone",
	"create_time":                         "description.DBSnapshot.SnapshotCreateTime",
	"db_instance_identifier":              "description.DBSnapshot.DBInstanceIdentifier",
	"db_snapshot_attributes":              "description.DBSnapshotAttributes",
	"db_snapshot_identifier":              "description.DBSnapshot.DBSnapshotIdentifier",
	"dbi_resource_id":                     "description.DBSnapshot.DbiResourceId",
	"encrypted":                           "description.DBSnapshot.Encrypted",
	"engine":                              "description.DBSnapshot.Engine",
	"engine_version":                      "description.DBSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBSnapshot.IAMDatabaseAuthenticationEnabled",
	"instance_create_time":                "description.DBSnapshot.InstanceCreateTime",
	"iops":                                "description.DBSnapshot.Iops",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.DBSnapshot.KmsKeyId",
	"license_model":                       "description.DBSnapshot.LicenseModel",
	"master_user_name":                    "description.DBSnapshot.MasterUsername",
	"option_group_name":                   "description.DBSnapshot.OptionGroupName",
	"percent_progress":                    "description.DBSnapshot.PercentProgress",
	"port":                                "description.DBSnapshot.Port",
	"processor_features":                  "description.DBSnapshot.ProcessorFeatures",
	"source_db_snapshot_identifier":       "description.DBSnapshot.SourceDBSnapshotIdentifier",
	"source_region":                       "description.DBSnapshot.SourceRegion",
	"status":                              "description.DBSnapshot.Status",
	"storage_type":                        "description.DBSnapshot.StorageType",
	"tags_src":                            "description.DBSnapshot.TagList",
	"tde_credential_arn":                  "description.DBSnapshot.TdeCredentialArn",
	"timezone":                            "description.DBSnapshot.Timezone",
	"title":                               "description.DBSnapshot.DBSnapshotIdentifier",
	"type":                                "description.DBSnapshot.SnapshotType",
	"vpc_id":                              "description.DBSnapshot.VpcId",
}

func ListRDSDBSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBSnapshot NewRDSDBSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBSnapshotFilters = map[string]string{
	"allocated_storage":                   "description.DBSnapshot.AllocatedStorage",
	"arn":                                 "description.DBSnapshot.DBSnapshotArn",
	"availability_zone":                   "description.DBSnapshot.AvailabilityZone",
	"create_time":                         "description.DBSnapshot.SnapshotCreateTime",
	"db_instance_identifier":              "description.DBSnapshot.DBInstanceIdentifier",
	"db_snapshot_attributes":              "description.DBSnapshotAttributes",
	"db_snapshot_identifier":              "description.DBSnapshot.DBInstanceIdentifier",
	"dbi_resource_id":                     "description.DBSnapshot.DbiResourceId",
	"encrypted":                           "description.DBSnapshot.Encrypted",
	"engine":                              "description.DBSnapshot.Engine",
	"engine_version":                      "description.DBSnapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.DBSnapshot.IAMDatabaseAuthenticationEnabled",
	"instance_create_time":                "description.DBSnapshot.InstanceCreateTime",
	"iops":                                "description.DBSnapshot.Iops",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.DBSnapshot.KmsKeyId",
	"license_model":                       "description.DBSnapshot.LicenseModel",
	"master_user_name":                    "description.DBSnapshot.MasterUsername",
	"option_group_name":                   "description.DBSnapshot.OptionGroupName",
	"percent_progress":                    "description.DBSnapshot.PercentProgress",
	"port":                                "description.DBSnapshot.Port",
	"processor_features":                  "description.DBSnapshot.ProcessorFeatures",
	"source_db_snapshot_identifier":       "description.DBSnapshot.SourceDBSnapshotIdentifier",
	"source_region":                       "description.DBSnapshot.SourceRegion",
	"status":                              "description.DBSnapshot.Status",
	"storage_type":                        "description.DBSnapshot.StorageType",
	"tags_src":                            "description.DBSnapshot.TagList",
	"tde_credential_arn":                  "description.DBSnapshot.TdeCredentialArn",
	"timezone":                            "description.DBSnapshot.Timezone",
	"title":                               "description.DBSnapshot.DBSnapshotIdentifier",
	"type":                                "description.DBSnapshot.SnapshotType",
	"vpc_id":                              "description.DBSnapshot.VpcId",
}

func GetRDSDBSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBSnapshot =============================

// ==========================  START: RDSGlobalCluster =============================

type RDSGlobalCluster struct {
	Description   aws.RDSGlobalClusterDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RDSGlobalClusterHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  RDSGlobalCluster `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type RDSGlobalClusterHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []RDSGlobalClusterHit `json:"hits"`
}

type RDSGlobalClusterSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  RDSGlobalClusterHits `json:"hits"`
}

type RDSGlobalClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSGlobalClusterPaginator(filters []essdk.BoolFilter, limit *int64) (RDSGlobalClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_globalcluster", filters, limit)
	if err != nil {
		return RDSGlobalClusterPaginator{}, err
	}

	p := RDSGlobalClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSGlobalClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSGlobalClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSGlobalClusterPaginator) NextPage(ctx context.Context) ([]RDSGlobalCluster, error) {
	var response RDSGlobalClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSGlobalCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSGlobalClusterFilters = map[string]string{
	"global_cluster_arn":        "description.GlobalCluster.GlobalClusterArn",
	"global_cluster_identifier": "description.GlobalCluster.GlobalClusterIdentifier",
	"og_account_id":             "metadata.SourceID",
	"title":                     "description.GlobalCluster.GlobalClusterIdentifier",
}

func ListRDSGlobalCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSGlobalCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSGlobalCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSGlobalCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSGlobalCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSGlobalCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSGlobalCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSGlobalClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSGlobalClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSGlobalCluster NewRDSGlobalClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSGlobalCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSGlobalClusterFilters = map[string]string{
	"global_cluster_arn":        "description.GlobalCluster.GlobalClusterArn",
	"global_cluster_identifier": "description.DBGlobalCluster.GlobalClusterIdentifier",
	"og_account_id":             "metadata.SourceID",
	"title":                     "description.GlobalCluster.GlobalClusterIdentifier",
}

func GetRDSGlobalCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSGlobalCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSGlobalClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSGlobalClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSGlobalCluster =============================

// ==========================  START: RDSReservedDBInstance =============================

type RDSReservedDBInstance struct {
	Description   aws.RDSReservedDBInstanceDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type RDSReservedDBInstanceHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  RDSReservedDBInstance `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type RDSReservedDBInstanceHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []RDSReservedDBInstanceHit `json:"hits"`
}

type RDSReservedDBInstanceSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  RDSReservedDBInstanceHits `json:"hits"`
}

type RDSReservedDBInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSReservedDBInstancePaginator(filters []essdk.BoolFilter, limit *int64) (RDSReservedDBInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_reserveddbinstance", filters, limit)
	if err != nil {
		return RDSReservedDBInstancePaginator{}, err
	}

	p := RDSReservedDBInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSReservedDBInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSReservedDBInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSReservedDBInstancePaginator) NextPage(ctx context.Context) ([]RDSReservedDBInstance, error) {
	var response RDSReservedDBInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSReservedDBInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSReservedDBInstanceFilters = map[string]string{
	"arn":                               "description.ReservedDBInstance.ReservedDBInstanceArn",
	"class":                             "description.ReservedDBInstance.DBInstanceClass",
	"currency_code":                     "description.ReservedDBInstance.CurrencyCode",
	"db_instance_count":                 "description.ReservedDBInstance.DBInstanceCount",
	"duration":                          "description.ReservedDBInstance.Duration",
	"fixed_price":                       "description.ReservedDBInstance.FixedPrice",
	"og_account_id":                     "metadata.SourceID",
	"lease_id":                          "description.ReservedDBInstance.LeaseId",
	"multi_az":                          "description.ReservedDBInstance.MultiAZ",
	"offering_type":                     "description.ReservedDBInstance.OfferingType",
	"product_description":               "description.ReservedDBInstance.ProductDescription",
	"recurring_charges":                 "description.ReservedDBInstance.RecurringCharges",
	"reserved_db_instance_id":           "description.ReservedDBInstance.ReservedDBInstanceId",
	"reserved_db_instances_offering_id": "description.ReservedDBInstance.ReservedDBInstancesOfferingId",
	"start_time":                        "description.ReservedDBInstance.StartTime",
	"state":                             "description.ReservedDBInstance.State",
	"title":                             "description.ReservedDBInstance.ReservedDBInstanceId",
	"usage_price":                       "description.ReservedDBInstance.UsagePrice",
}

func ListRDSReservedDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSReservedDBInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSReservedDBInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSReservedDBInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSReservedDBInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSReservedDBInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSReservedDBInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSReservedDBInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSReservedDBInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSReservedDBInstance NewRDSReservedDBInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSReservedDBInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSReservedDBInstanceFilters = map[string]string{
	"arn":                               "description.ReservedDBInstance.ReservedDBInstanceArn",
	"class":                             "description.ReservedDBInstance.DBInstanceClass",
	"currency_code":                     "description.ReservedDBInstance.CurrencyCode",
	"db_instance_count":                 "description.ReservedDBInstance.DBInstanceCount",
	"duration":                          "description.ReservedDBInstance.Duration",
	"fixed_price":                       "description.ReservedDBInstance.FixedPrice",
	"og_account_id":                     "metadata.SourceID",
	"lease_id":                          "description.ReservedDBInstance.LeaseId",
	"multi_az":                          "description.ReservedDBInstance.MultiAZ",
	"offering_type":                     "description.ReservedDBInstance.OfferingType",
	"product_description":               "description.ReservedDBInstance.ProductDescription",
	"recurring_charges":                 "description.ReservedDBInstance.RecurringCharges",
	"reserved_db_instance_id":           "description.ReservedDBInstance.ReservedDBInstanceId",
	"reserved_db_instances_offering_id": "description.ReservedDBInstance.ReservedDBInstancesOfferingId",
	"start_time":                        "description.ReservedDBInstance.StartTime",
	"state":                             "description.ReservedDBInstance.State",
	"title":                             "description.ReservedDBInstance.ReservedDBInstanceId",
	"usage_price":                       "description.ReservedDBInstance.UsagePrice",
}

func GetRDSReservedDBInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSReservedDBInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSReservedDBInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSReservedDBInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSReservedDBInstance =============================

// ==========================  START: RDSDBInstanceAutomatedBackup =============================

type RDSDBInstanceAutomatedBackup struct {
	Description   aws.RDSDBInstanceAutomatedBackupDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type RDSDBInstanceAutomatedBackupHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  RDSDBInstanceAutomatedBackup `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type RDSDBInstanceAutomatedBackupHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []RDSDBInstanceAutomatedBackupHit `json:"hits"`
}

type RDSDBInstanceAutomatedBackupSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  RDSDBInstanceAutomatedBackupHits `json:"hits"`
}

type RDSDBInstanceAutomatedBackupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBInstanceAutomatedBackupPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBInstanceAutomatedBackupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbinstanceautomatedbackup", filters, limit)
	if err != nil {
		return RDSDBInstanceAutomatedBackupPaginator{}, err
	}

	p := RDSDBInstanceAutomatedBackupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBInstanceAutomatedBackupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBInstanceAutomatedBackupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBInstanceAutomatedBackupPaginator) NextPage(ctx context.Context) ([]RDSDBInstanceAutomatedBackup, error) {
	var response RDSDBInstanceAutomatedBackupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBInstanceAutomatedBackup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBInstanceAutomatedBackupFilters = map[string]string{
	"allocated_storage":       "description.InstanceAutomatedBackup.AllocatedStorage",
	"arn":                     "description.InstanceAutomatedBackup.DBInstanceAutomatedBackupsArn",
	"availability_zone":       "description.InstanceAutomatedBackup.AvailabilityZone",
	"backup_retention_period": "description.InstanceAutomatedBackup.BackupRetentionPeriod",
	"backup_target":           "description.InstanceAutomatedBackup.BackupTarget",
	"db_instance_arn":         "description.InstanceAutomatedBackup.DBInstanceArn",
	"db_instance_automated_backups_replications": "description.InstanceAutomatedBackup.DBInstanceAutomatedBackupsReplications",
	"db_instance_identifier":                     "description.InstanceAutomatedBackup.DBInstanceIdentifier",
	"dbi_resource_id":                            "description.InstanceAutomatedBackup.DbiResourceId",
	"encrypted":                                  "description.InstanceAutomatedBackup.Encrypted",
	"engine":                                     "description.InstanceAutomatedBackup.Engine",
	"engine_version":                             "description.InstanceAutomatedBackup.EngineVersion",
	"iam_database_authentication_enabled":        "description.InstanceAutomatedBackup.IAMDatabaseAuthenticationEnabled",
	"instance_create_time":                       "description.InstanceAutomatedBackup.InstanceCreateTime",
	"iops":                                       "description.InstanceAutomatedBackup.Iops",
	"og_account_id":                              "metadata.SourceID",
	"kms_key_id":                                 "description.InstanceAutomatedBackup.KmsKeyId",
	"license_model":                              "description.InstanceAutomatedBackup.LicenseModel",
	"master_username":                            "description.InstanceAutomatedBackup.MasterUsername",
	"option_group_name":                          "description.InstanceAutomatedBackup.OptionGroupName",
	"port":                                       "description.InstanceAutomatedBackup.Port",
	"restore_window":                             "description.InstanceAutomatedBackup.RestoreWindow",
	"status":                                     "description.InstanceAutomatedBackup.Status",
	"storage_type":                               "description.InstanceAutomatedBackup.StorageType",
	"tde_credential_arn":                         "description.InstanceAutomatedBackup.TdeCredentialArn",
	"timezone":                                   "description.InstanceAutomatedBackup.Timezone",
	"title":                                      "description.InstanceAutomatedBackup.DBInstanceIdentifier",
	"vpc_id":                                     "description.InstanceAutomatedBackup.VpcId",
}

func ListRDSDBInstanceAutomatedBackup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBInstanceAutomatedBackup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstanceAutomatedBackup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstanceAutomatedBackup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstanceAutomatedBackup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstanceAutomatedBackup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstanceAutomatedBackup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBInstanceAutomatedBackupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBInstanceAutomatedBackupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBInstanceAutomatedBackup NewRDSDBInstanceAutomatedBackupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBInstanceAutomatedBackup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBInstanceAutomatedBackupFilters = map[string]string{
	"allocated_storage":       "description.InstanceAutomatedBackup.AllocatedStorage",
	"arn":                     "description.InstanceAutomatedBackup.DBInstanceAutomatedBackupsArn",
	"availability_zone":       "description.InstanceAutomatedBackup.AvailabilityZone",
	"backup_retention_period": "description.InstanceAutomatedBackup.BackupRetentionPeriod",
	"backup_target":           "description.InstanceAutomatedBackup.BackupTarget",
	"db_cluster_identifier":   "description.DBCluster.DBClusterIdentifier",
	"db_instance_arn":         "description.InstanceAutomatedBackup.DBInstanceArn",
	"db_instance_automated_backups_replications": "description.InstanceAutomatedBackup.DBInstanceAutomatedBackupsReplications",
	"db_instance_identifier":                     "description.InstanceAutomatedBackup.DBInstanceIdentifier",
	"dbi_resource_id":                            "description.InstanceAutomatedBackup.DbiResourceId",
	"encrypted":                                  "description.InstanceAutomatedBackup.Encrypted",
	"engine":                                     "description.InstanceAutomatedBackup.Engine",
	"engine_version":                             "description.InstanceAutomatedBackup.EngineVersion",
	"iam_database_authentication_enabled":        "description.InstanceAutomatedBackup.IAMDatabaseAuthenticationEnabled",
	"instance_create_time":                       "description.InstanceAutomatedBackup.InstanceCreateTime",
	"iops":                                       "description.InstanceAutomatedBackup.Iops",
	"og_account_id":                              "metadata.SourceID",
	"kms_key_id":                                 "description.InstanceAutomatedBackup.KmsKeyId",
	"license_model":                              "description.InstanceAutomatedBackup.LicenseModel",
	"master_username":                            "description.InstanceAutomatedBackup.MasterUsername",
	"option_group_name":                          "description.InstanceAutomatedBackup.OptionGroupName",
	"port":                                       "description.InstanceAutomatedBackup.Port",
	"restore_window":                             "description.InstanceAutomatedBackup.RestoreWindow",
	"status":                                     "description.InstanceAutomatedBackup.Status",
	"storage_type":                               "description.InstanceAutomatedBackup.StorageType",
	"tde_credential_arn":                         "description.InstanceAutomatedBackup.TdeCredentialArn",
	"timezone":                                   "description.InstanceAutomatedBackup.Timezone",
	"title":                                      "description.InstanceAutomatedBackup.DBInstanceIdentifier",
	"vpc_id":                                     "description.InstanceAutomatedBackup.VpcId",
}

func GetRDSDBInstanceAutomatedBackup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBInstanceAutomatedBackup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBInstanceAutomatedBackupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBInstanceAutomatedBackupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBInstanceAutomatedBackup =============================

// ==========================  START: RDSDBEngineVersion =============================

type RDSDBEngineVersion struct {
	Description   aws.RDSDBEngineVersionDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type RDSDBEngineVersionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  RDSDBEngineVersion `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type RDSDBEngineVersionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []RDSDBEngineVersionHit `json:"hits"`
}

type RDSDBEngineVersionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  RDSDBEngineVersionHits `json:"hits"`
}

type RDSDBEngineVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBEngineVersionPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBEngineVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbengineversion", filters, limit)
	if err != nil {
		return RDSDBEngineVersionPaginator{}, err
	}

	p := RDSDBEngineVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBEngineVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBEngineVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBEngineVersionPaginator) NextPage(ctx context.Context) ([]RDSDBEngineVersion, error) {
	var response RDSDBEngineVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBEngineVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBEngineVersionFilters = map[string]string{
	"arn":                               "description.EngineVersion.DBEngineVersionArn",
	"create_time":                       "description.EngineVersion.CreateTime",
	"custom_db_engine_version_manifest": "description.EngineVersion.CustomDBEngineVersionManifest",
	"database_installation_files_s3_bucket_name":    "description.EngineVersion.DatabaseInstallationFilesS3BucketName",
	"database_installation_files_s3_prefix":         "description.EngineVersion.DatabaseInstallationFilesS3Prefix",
	"db_engine_description":                         "description.EngineVersion.DBEngineDescription",
	"db_engine_media_type":                          "description.EngineVersion.DBEngineMediaType",
	"db_engine_version_description":                 "description.EngineVersion.DBEngineVersionDescription",
	"db_parameter_group_family":                     "description.EngineVersion.DBParameterGroupFamily",
	"engine":                                        "description.EngineVersion.Engine",
	"engine_version":                                "description.EngineVersion.EngineVersion",
	"exportable_log_types":                          "description.EngineVersion.ExportableLogTypes",
	"image":                                         "description.EngineVersion.Image",
	"kms_key_id":                                    "description.EngineVersion.KMSKeyId",
	"list_supported_character_sets":                 "description.EngineVersion.CustomDBEngineVersionManifest",
	"major_engine_version":                          "description.EngineVersion.MajorEngineVersion",
	"status":                                        "description.EngineVersion.Status",
	"supported_feature_names":                       "description.EngineVersion.SupportedFeatureNames",
	"supported_nchar_character_sets":                "description.EngineVersion.SupportedNcharCharacterSets",
	"supported_timezones":                           "description.EngineVersion.SupportedTimezones",
	"supports_babelfish":                            "description.EngineVersion.SupportsBabelfish",
	"supports_certificate_rotation_without_restart": "description.EngineVersion.SupportsCertificateRotationWithoutRestart",
	"supports_global_databases":                     "description.EngineVersion.SupportsGlobalDatabases",
	"supports_log_exports_to_cloudwatch_logs":       "description.EngineVersion.SupportsLogExportsToCloudwatchLogs",
	"supports_parallel_query":                       "description.EngineVersion.SupportsParallelQuery",
	"supports_read_replica":                         "description.EngineVersion.SupportsReadReplica",
	"tag_list":                                      "description.EngineVersion.TagList",
	"title":                                         "description.EngineVersion.EngineVersion",
	"valid_upgrade_target":                          "description.EngineVersion.ValidUpgradeTarget",
}

func ListRDSDBEngineVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBEngineVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEngineVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEngineVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEngineVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEngineVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEngineVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBEngineVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBEngineVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBEngineVersion NewRDSDBEngineVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBEngineVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBEngineVersionFilters = map[string]string{
	"arn":                               "description.EngineVersion.DBEngineVersionArn",
	"create_time":                       "description.EngineVersion.CreateTime",
	"custom_db_engine_version_manifest": "description.EngineVersion.CustomDBEngineVersionManifest",
	"database_installation_files_s3_bucket_name":    "description.EngineVersion.DatabaseInstallationFilesS3BucketName",
	"database_installation_files_s3_prefix":         "description.EngineVersion.DatabaseInstallationFilesS3Prefix",
	"db_engine_description":                         "description.EngineVersion.DBEngineDescription",
	"db_engine_media_type":                          "description.EngineVersion.DBEngineMediaType",
	"db_engine_version_description":                 "description.EngineVersion.DBEngineVersionDescription",
	"db_parameter_group_family":                     "description.EngineVersion.DBParameterGroupFamily",
	"engine":                                        "description.EngineVersion.Engine",
	"engine_version":                                "description.EngineVersion.EngineVersion",
	"exportable_log_types":                          "description.EngineVersion.ExportableLogTypes",
	"image":                                         "description.EngineVersion.Image",
	"kms_key_id":                                    "description.EngineVersion.KMSKeyId",
	"list_supported_character_sets":                 "description.EngineVersion.CustomDBEngineVersionManifest",
	"major_engine_version":                          "description.EngineVersion.MajorEngineVersion",
	"status":                                        "description.EngineVersion.Status",
	"supported_feature_names":                       "description.EngineVersion.SupportedFeatureNames",
	"supported_nchar_character_sets":                "description.EngineVersion.SupportedNcharCharacterSets",
	"supported_timezones":                           "description.EngineVersion.SupportedTimezones",
	"supports_babelfish":                            "description.EngineVersion.SupportsBabelfish",
	"supports_certificate_rotation_without_restart": "description.EngineVersion.SupportsCertificateRotationWithoutRestart",
	"supports_global_databases":                     "description.EngineVersion.SupportsGlobalDatabases",
	"supports_log_exports_to_cloudwatch_logs":       "description.EngineVersion.SupportsLogExportsToCloudwatchLogs",
	"supports_parallel_query":                       "description.EngineVersion.SupportsParallelQuery",
	"supports_read_replica":                         "description.EngineVersion.SupportsReadReplica",
	"tag_list":                                      "description.EngineVersion.TagList",
	"title":                                         "description.EngineVersion.EngineVersion",
	"valid_upgrade_target":                          "description.EngineVersion.ValidUpgradeTarget",
}

func GetRDSDBEngineVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBEngineVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBEngineVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBEngineVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBEngineVersion =============================

// ==========================  START: RDSDBRecommendation =============================

type RDSDBRecommendation struct {
	Description   aws.RDSDBRecommendationDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type RDSDBRecommendationHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RDSDBRecommendation `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RDSDBRecommendationHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RDSDBRecommendationHit `json:"hits"`
}

type RDSDBRecommendationSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RDSDBRecommendationHits `json:"hits"`
}

type RDSDBRecommendationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRDSDBRecommendationPaginator(filters []essdk.BoolFilter, limit *int64) (RDSDBRecommendationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_rds_dbrecommendation", filters, limit)
	if err != nil {
		return RDSDBRecommendationPaginator{}, err
	}

	p := RDSDBRecommendationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RDSDBRecommendationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RDSDBRecommendationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RDSDBRecommendationPaginator) NextPage(ctx context.Context) ([]RDSDBRecommendation, error) {
	var response RDSDBRecommendationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RDSDBRecommendation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRDSDBRecommendationFilters = map[string]string{
	"additional_info":     "description.DBRecommendation.AdditionalInfo",
	"category":            "description.DBRecommendation.Category",
	"created_time":        "description.DBRecommendation.CreatedTime",
	"description":         "description.DBRecommendation.Description",
	"detection":           "description.DBRecommendation.Detection",
	"impact":              "description.DBRecommendation.Impact",
	"issue_details":       "description.DBRecommendation.IssueDetails",
	"links":               "description.DBRecommendation.Links",
	"reason":              "description.DBRecommendation.Reason",
	"recommendation":      "description.DBRecommendation.Recommendation",
	"recommendation_id":   "description.DBRecommendation.RecommendationId",
	"recommended_actions": "description.DBRecommendation.RecommendedActions",
	"resource_arn":        "description.DBRecommendation.ResourceArn",
	"severity":            "description.DBRecommendation.Severity",
	"source":              "description.DBRecommendation.Source",
	"status":              "description.DBRecommendation.Status",
	"title":               "description.DBRecommendation.RecommendationId",
	"type_detection":      "description.DBRecommendation.TypeDetection",
	"type_id":             "description.DBRecommendation.TypeId",
	"type_recommendation": "description.DBRecommendation.TypeRecommendation",
}

func ListRDSDBRecommendation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRDSDBRecommendation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBRecommendation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBRecommendation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBRecommendation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBRecommendation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBRecommendation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRDSDBRecommendationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRDSDBRecommendationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRDSDBRecommendation NewRDSDBRecommendationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRDSDBRecommendation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRDSDBRecommendationFilters = map[string]string{
	"additional_info":     "description.DBRecommendation.AdditionalInfo",
	"category":            "description.DBRecommendation.Category",
	"created_time":        "description.DBRecommendation.CreatedTime",
	"description":         "description.DBRecommendation.Description",
	"detection":           "description.DBRecommendation.Detection",
	"impact":              "description.DBRecommendation.Impact",
	"issue_details":       "description.DBRecommendation.IssueDetails",
	"links":               "description.DBRecommendation.Links",
	"reason":              "description.DBRecommendation.Reason",
	"recommendation":      "description.DBRecommendation.Recommendation",
	"recommendation_id":   "description.DBRecommendation.RecommendationId",
	"recommended_actions": "description.DBRecommendation.RecommendedActions",
	"resource_arn":        "description.DBRecommendation.ResourceArn",
	"severity":            "description.DBRecommendation.Severity",
	"source":              "description.DBRecommendation.Source",
	"status":              "description.DBRecommendation.Status",
	"title":               "description.DBRecommendation.RecommendationId",
	"type_detection":      "description.DBRecommendation.TypeDetection",
	"type_id":             "description.DBRecommendation.TypeId",
	"type_recommendation": "description.DBRecommendation.TypeRecommendation",
}

func GetRDSDBRecommendation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRDSDBRecommendation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRDSDBRecommendationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRDSDBRecommendationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RDSDBRecommendation =============================

// ==========================  START: RedshiftCluster =============================

type RedshiftCluster struct {
	Description   aws.RedshiftClusterDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type RedshiftClusterHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  RedshiftCluster `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type RedshiftClusterHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []RedshiftClusterHit `json:"hits"`
}

type RedshiftClusterSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  RedshiftClusterHits `json:"hits"`
}

type RedshiftClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftClusterPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_cluster", filters, limit)
	if err != nil {
		return RedshiftClusterPaginator{}, err
	}

	p := RedshiftClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftClusterPaginator) NextPage(ctx context.Context) ([]RedshiftCluster, error) {
	var response RedshiftClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftClusterFilters = map[string]string{
	"allow_version_upgrade":                       "description.Cluster.AllowVersionUpgrade",
	"arn":                                         "arn",
	"automated_snapshot_retention_period":         "description.Cluster.AutomatedSnapshotRetentionPeriod",
	"availability_zone":                           "description.Cluster.AvailabilityZone",
	"availability_zone_relocation_status":         "description.Cluster.AvailabilityZoneRelocationStatus",
	"cluster_availability_status":                 "description.Cluster.ClusterAvailabilityStatus",
	"cluster_create_time":                         "description.Cluster.ClusterCreateTime",
	"cluster_identifier":                          "description.Cluster.ClusterIdentifier",
	"cluster_namespace_arn":                       "description.Cluster.ClusterNamespaceArn",
	"cluster_nodes":                               "description.Cluster.ClusterNodes",
	"cluster_parameter_groups":                    "description.Cluster.ClusterParameterGroups",
	"cluster_public_key":                          "description.Cluster.ClusterPublicKey",
	"cluster_revision_number":                     "description.Cluster.ClusterRevisionNumber",
	"cluster_security_groups":                     "description.Cluster.ClusterSecurityGroups",
	"cluster_snapshot_copy_status":                "description.Cluster.ClusterSnapshotCopyStatus",
	"cluster_status":                              "description.Cluster.ClusterStatus",
	"cluster_subnet_group_name":                   "description.Cluster.ClusterSubnetGroupName",
	"cluster_version":                             "description.Cluster.ClusterVersion",
	"data_transfer_progress":                      "description.Cluster.DataTransferProgress",
	"db_name":                                     "description.Cluster.DBName",
	"deferred_maintenance_windows":                "description.Cluster.DeferredMaintenanceWindows",
	"elastic_ip_status":                           "description.Cluster.ElasticIpStatus",
	"elastic_resize_number_of_node_options":       "description.Cluster.ElasticResizeNumberOfNodeOptions",
	"encrypted":                                   "description.Cluster.Encrypted",
	"endpoint":                                    "description.Cluster.Endpoint",
	"enhanced_vpc_routing":                        "description.Cluster.EnhancedVpcRouting",
	"expected_next_snapshot_schedule_time":        "description.Cluster.ExpectedNextSnapshotScheduleTime",
	"expected_next_snapshot_schedule_time_status": "description.Cluster.ExpectedNextSnapshotScheduleTimeStatus",
	"hsm_status":                                  "description.Cluster.HsmStatus",
	"iam_roles":                                   "description.Cluster.IamRoles",
	"og_account_id":                               "metadata.SourceID",
	"kms_key_id":                                  "description.Cluster.KmsKeyId",
	"logging_status":                              "description.LoggingStatus",
	"maintenance_track_name":                      "description.Cluster.MaintenanceTrackName",
	"manual_snapshot_retention_period":            "description.Cluster.ManualSnapshotRetentionPeriod",
	"master_username":                             "description.Cluster.MasterUsername",
	"modify_status":                               "description.Cluster.ModifyStatus",
	"next_maintenance_window_start_time":          "description.Cluster.NextMaintenanceWindowStartTime",
	"node_type":                                   "description.Cluster.NodeType",
	"number_of_nodes":                             "description.Cluster.NumberOfNodes",
	"pending_actions":                             "description.Cluster.PendingActions",
	"pending_modified_values":                     "description.Cluster.PendingModifiedValues",
	"preferred_maintenance_window":                "description.Cluster.PreferredMaintenanceWindow",
	"publicly_accessible":                         "description.Cluster.PubliclyAccessible",
	"resize_info":                                 "description.Cluster.ResizeInfo",
	"restore_status":                              "description.Cluster.RestoreStatus",
	"scheduled_actions":                           "description.ScheduledActions",
	"snapshot_schedule_identifier":                "description.Cluster.SnapshotScheduleIdentifier",
	"snapshot_schedule_state":                     "description.Cluster.SnapshotScheduleState",
	"tags_src":                                    "description.Cluster.Tags",
	"title":                                       "description.Cluster.ClusterIdentifier",
	"vpc_id":                                      "description.Cluster.VpcId",
	"vpc_security_groups":                         "description.Cluster.VpcSecurityGroups",
}

func ListRedshiftCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftCluster NewRedshiftClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftClusterFilters = map[string]string{
	"allow_version_upgrade":                       "description.Cluster.AllowVersionUpgrade",
	"arn":                                         "arn",
	"automated_snapshot_retention_period":         "description.Cluster.AutomatedSnapshotRetentionPeriod",
	"availability_zone":                           "description.Cluster.AvailabilityZone",
	"availability_zone_relocation_status":         "description.Cluster.AvailabilityZoneRelocationStatus",
	"cluster_availability_status":                 "description.Cluster.ClusterAvailabilityStatus",
	"cluster_create_time":                         "description.Cluster.ClusterCreateTime",
	"cluster_identifier":                          "description.Cluster",
	"cluster_namespace_arn":                       "description.Cluster.ClusterNamespaceArn",
	"cluster_nodes":                               "description.Cluster.ClusterNodes",
	"cluster_parameter_groups":                    "description.Cluster.ClusterParameterGroups",
	"cluster_public_key":                          "description.Cluster.ClusterPublicKey",
	"cluster_revision_number":                     "description.Cluster.ClusterRevisionNumber",
	"cluster_security_groups":                     "description.Cluster.ClusterSecurityGroups",
	"cluster_snapshot_copy_status":                "description.Cluster.ClusterSnapshotCopyStatus",
	"cluster_status":                              "description.Cluster.ClusterStatus",
	"cluster_subnet_group_name":                   "description.Cluster.ClusterSubnetGroupName",
	"cluster_version":                             "description.Cluster.ClusterVersion",
	"data_transfer_progress":                      "description.Cluster.DataTransferProgress",
	"db_name":                                     "description.Cluster.DBName",
	"deferred_maintenance_windows":                "description.Cluster.DeferredMaintenanceWindows",
	"elastic_ip_status":                           "description.Cluster.ElasticIpStatus",
	"elastic_resize_number_of_node_options":       "description.Cluster.ElasticResizeNumberOfNodeOptions",
	"encrypted":                                   "description.Cluster.Encrypted",
	"endpoint":                                    "description.Cluster.Endpoint",
	"enhanced_vpc_routing":                        "description.Cluster.EnhancedVpcRouting",
	"expected_next_snapshot_schedule_time":        "description.Cluster.ExpectedNextSnapshotScheduleTime",
	"expected_next_snapshot_schedule_time_status": "description.Cluster.ExpectedNextSnapshotScheduleTimeStatus",
	"hsm_status":                                  "description.Cluster.HsmStatus",
	"iam_roles":                                   "description.Cluster.IamRoles",
	"og_account_id":                               "metadata.SourceID",
	"kms_key_id":                                  "description.Cluster.KmsKeyId",
	"logging_status":                              "description.LoggingStatus",
	"maintenance_track_name":                      "description.Cluster.MaintenanceTrackName",
	"manual_snapshot_retention_period":            "description.Cluster.ManualSnapshotRetentionPeriod",
	"master_username":                             "description.Cluster.MasterUsername",
	"modify_status":                               "description.Cluster.ModifyStatus",
	"next_maintenance_window_start_time":          "description.Cluster.NextMaintenanceWindowStartTime",
	"node_type":                                   "description.Cluster.NodeType",
	"number_of_nodes":                             "description.Cluster.NumberOfNodes",
	"pending_actions":                             "description.Cluster.PendingActions",
	"pending_modified_values":                     "description.Cluster.PendingModifiedValues",
	"preferred_maintenance_window":                "description.Cluster.PreferredMaintenanceWindow",
	"publicly_accessible":                         "description.Cluster.PubliclyAccessible",
	"resize_info":                                 "description.Cluster.ResizeInfo",
	"restore_status":                              "description.Cluster.RestoreStatus",
	"scheduled_actions":                           "description.ScheduledActions",
	"snapshot_schedule_identifier":                "description.Cluster.SnapshotScheduleIdentifier",
	"snapshot_schedule_state":                     "description.Cluster.SnapshotScheduleState",
	"tags_src":                                    "description.Cluster.Tags",
	"title":                                       "description.Cluster.ClusterIdentifier",
	"vpc_id":                                      "description.Cluster.VpcId",
	"vpc_security_groups":                         "description.Cluster.VpcSecurityGroups",
}

func GetRedshiftCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftCluster =============================

// ==========================  START: RedshiftEventSubscription =============================

type RedshiftEventSubscription struct {
	Description   aws.RedshiftEventSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type RedshiftEventSubscriptionHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  RedshiftEventSubscription `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type RedshiftEventSubscriptionHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []RedshiftEventSubscriptionHit `json:"hits"`
}

type RedshiftEventSubscriptionSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  RedshiftEventSubscriptionHits `json:"hits"`
}

type RedshiftEventSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftEventSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftEventSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_eventsubscription", filters, limit)
	if err != nil {
		return RedshiftEventSubscriptionPaginator{}, err
	}

	p := RedshiftEventSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftEventSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftEventSubscriptionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftEventSubscriptionPaginator) NextPage(ctx context.Context) ([]RedshiftEventSubscription, error) {
	var response RedshiftEventSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftEventSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftEventSubscriptionFilters = map[string]string{
	"cust_subscription_id":       "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":            "description.EventSubscription.CustomerAwsId",
	"enabled":                    "description.EventSubscription.Enabled",
	"event_categories_list":      "description.EventSubscription.EventCategoriesList",
	"og_account_id":              "metadata.SourceID",
	"severity":                   "description.EventSubscription.Severity",
	"sns_topic_arn":              "description.EventSubscription.SnsTopicArn",
	"source_ids_list":            "description.EventSubscription.SourceIdsList",
	"source_type":                "description.EventSubscription.SourceType",
	"status":                     "description.EventSubscription.Status",
	"subscription_creation_time": "description.EventSubscription.SubscriptionCreationTime",
	"tags_src":                   "description.EventSubscription.Tags",
	"title":                      "description.EventSubscription.CustSubscriptionId",
}

func ListRedshiftEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftEventSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftEventSubscription NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftEventSubscription NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftEventSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftEventSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftEventSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftEventSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftEventSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftEventSubscription NewRedshiftEventSubscriptionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftEventSubscription paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftEventSubscriptionFilters = map[string]string{
	"cust_subscription_id":       "description.EventSubscription.CustSubscriptionId",
	"customer_aws_id":            "description.EventSubscription.CustomerAwsId",
	"enabled":                    "description.EventSubscription.Enabled",
	"event_categories_list":      "description.EventSubscription.EventCategoriesList",
	"og_account_id":              "metadata.SourceID",
	"severity":                   "description.EventSubscription.Severity",
	"sns_topic_arn":              "description.EventSubscription.SnsTopicArn",
	"source_ids_list":            "description.EventSubscription.SourceIdsList",
	"source_type":                "description.EventSubscription.SourceType",
	"status":                     "description.EventSubscription.Status",
	"subscription_creation_time": "description.EventSubscription.SubscriptionCreationTime",
	"tags_src":                   "description.EventSubscription.Tags",
	"title":                      "description.EventSubscription.CustSubscriptionId",
}

func GetRedshiftEventSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftEventSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftEventSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftEventSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftEventSubscription =============================

// ==========================  START: RedshiftServerlessWorkgroup =============================

type RedshiftServerlessWorkgroup struct {
	Description   aws.RedshiftServerlessWorkgroupDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type RedshiftServerlessWorkgroupHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  RedshiftServerlessWorkgroup `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type RedshiftServerlessWorkgroupHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []RedshiftServerlessWorkgroupHit `json:"hits"`
}

type RedshiftServerlessWorkgroupSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  RedshiftServerlessWorkgroupHits `json:"hits"`
}

type RedshiftServerlessWorkgroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftServerlessWorkgroupPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftServerlessWorkgroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshiftserverless_workgroup", filters, limit)
	if err != nil {
		return RedshiftServerlessWorkgroupPaginator{}, err
	}

	p := RedshiftServerlessWorkgroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftServerlessWorkgroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftServerlessWorkgroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftServerlessWorkgroupPaginator) NextPage(ctx context.Context) ([]RedshiftServerlessWorkgroup, error) {
	var response RedshiftServerlessWorkgroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftServerlessWorkgroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftServerlessWorkgroupFilters = map[string]string{
	"base_capacity":        "description.Workgroup.BaseCapacity",
	"config_parameters":    "description.Workgroup.ConfigParameters",
	"creation_date":        "description.Workgroup.CreationDate",
	"endpoint":             "description.Workgroup.Endpoint",
	"enhanced_vpc_routing": "description.Workgroup.EnhancedVpcRouting",
	"og_account_id":        "metadata.SourceID",
	"namespace_name":       "description.Workgroup.NamespaceName",
	"publicly_accessible":  "description.Workgroup.PubliclyAccessible",
	"security_group_ids":   "description.Workgroup.SecurityGroupIds",
	"status":               "description.Workgroup.Status",
	"subnet_ids":           "description.Workgroup.SubnetIds",
	"tags_src":             "description.Tags",
	"title":                "description.Workgroup.WorkgroupName",
	"workgroup_arn":        "description.Workgroup.WorkgroupArn",
	"workgroup_id":         "description.Workgroup.WorkgroupId",
	"workgroup_name":       "description.Workgroup.WorkgroupName",
}

func ListRedshiftServerlessWorkgroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftServerlessWorkgroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessWorkgroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessWorkgroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessWorkgroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessWorkgroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessWorkgroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftServerlessWorkgroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftServerlessWorkgroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessWorkgroup NewRedshiftServerlessWorkgroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftServerlessWorkgroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftServerlessWorkgroupFilters = map[string]string{
	"base_capacity":        "description.Workgroup.BaseCapacity",
	"config_parameters":    "description.Workgroup.ConfigParameters",
	"creation_date":        "description.Workgroup.CreationDate",
	"endpoint":             "description.Workgroup.Endpoint",
	"enhanced_vpc_routing": "description.Workgroup.EnhancedVpcRouting",
	"og_account_id":        "metadata.SourceID",
	"namespace_name":       "description.Workgroup.NamespaceName",
	"publicly_accessible":  "description.Workgroup.PubliclyAccessible",
	"security_group_ids":   "description.Workgroup.SecurityGroupIds",
	"status":               "description.Workgroup.Status",
	"subnet_ids":           "description.Workgroup.SubnetIds",
	"tags_src":             "description.Tags",
	"title":                "description.Workgroup.WorkgroupName",
	"workgroup_arn":        "description.Workgroup.WorkgroupArn",
	"workgroup_id":         "description.Workgroup.WorkgroupId",
	"workgroup_name":       "description.Workgroup.WorkgroupName",
}

func GetRedshiftServerlessWorkgroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftServerlessWorkgroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftServerlessWorkgroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftServerlessWorkgroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftServerlessWorkgroup =============================

// ==========================  START: RedshiftClusterParameterGroup =============================

type RedshiftClusterParameterGroup struct {
	Description   aws.RedshiftClusterParameterGroupDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type RedshiftClusterParameterGroupHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  RedshiftClusterParameterGroup `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type RedshiftClusterParameterGroupHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []RedshiftClusterParameterGroupHit `json:"hits"`
}

type RedshiftClusterParameterGroupSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  RedshiftClusterParameterGroupHits `json:"hits"`
}

type RedshiftClusterParameterGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftClusterParameterGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftClusterParameterGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_clusterparametergroup", filters, limit)
	if err != nil {
		return RedshiftClusterParameterGroupPaginator{}, err
	}

	p := RedshiftClusterParameterGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftClusterParameterGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftClusterParameterGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftClusterParameterGroupPaginator) NextPage(ctx context.Context) ([]RedshiftClusterParameterGroup, error) {
	var response RedshiftClusterParameterGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftClusterParameterGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftClusterParameterGroupFilters = map[string]string{
	"description":   "description.ClusterParameterGroup.Description",
	"family":        "description.ClusterParameterGroup.ParameterGroupFamily",
	"og_account_id": "metadata.SourceID",
	"name":          "description.ClusterParameterGroup.ParameterGroupName",
	"parameters":    "description.Parameters",
	"tags_src":      "description.ClusterParameterGroup.Tags",
	"title":         "description.ClusterParameterGroup.ParameterGroupName",
}

func ListRedshiftClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftClusterParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftClusterParameterGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftClusterParameterGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftClusterParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftClusterParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftClusterParameterGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftClusterParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftClusterParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftClusterParameterGroup NewRedshiftClusterParameterGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftClusterParameterGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftClusterParameterGroupFilters = map[string]string{
	"description":   "description.ClusterParameterGroup.Description",
	"family":        "description.ClusterParameterGroup.ParameterGroupFamily",
	"og_account_id": "metadata.SourceID",
	"name":          "description.ClusterParameterGroup.ParameterGroupName",
	"parameters":    "description.Parameters",
	"tags_src":      "description.ClusterParameterGroup.Tags",
	"title":         "description.ClusterParameterGroup.ParameterGroupName",
}

func GetRedshiftClusterParameterGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftClusterParameterGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftClusterParameterGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftClusterParameterGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftClusterParameterGroup =============================

// ==========================  START: RedshiftSnapshot =============================

type RedshiftSnapshot struct {
	Description   aws.RedshiftSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RedshiftSnapshotHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  RedshiftSnapshot `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type RedshiftSnapshotHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []RedshiftSnapshotHit `json:"hits"`
}

type RedshiftSnapshotSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  RedshiftSnapshotHits `json:"hits"`
}

type RedshiftSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_snapshot", filters, limit)
	if err != nil {
		return RedshiftSnapshotPaginator{}, err
	}

	p := RedshiftSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftSnapshotPaginator) NextPage(ctx context.Context) ([]RedshiftSnapshot, error) {
	var response RedshiftSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftSnapshotFilters = map[string]string{
	"accounts_with_restore_access":                 "description.Snapshot.AccountsWithRestoreAccess",
	"actual_incremental_backup_size_in_mega_bytes": "description.Snapshot.ActualIncrementalBackupSizeInMegaBytes",
	"availability_zone":                            "description.Snapshot.AvailabilityZone",
	"backup_progress_in_mega-bytes":                "description.Snapshot.BackupProgressInMegaBytes",
	"cluster_create_time":                          "description.Snapshot.ClusterCreateTime",
	"cluster_identifier":                           "description.Snapshot.ClusterIdentifier",
	"cluster_version":                              "description.Snapshot.ClusterVersion",
	"current_backup_rate_in_mega_bytes_per_second": "description.Snapshot.CurrentBackupRateInMegaBytesPerSecond",
	"db_name":                          "description.Snapshot.DBName",
	"elapsed_time_in_seconds":          "description.Snapshot.ElapsedTimeInSeconds",
	"encrypted":                        "description.Snapshot.Encrypted",
	"encrypted_with_hsm":               "description.Snapshot.EncryptedWithHSM",
	"engine_full_version":              "description.Snapshot.EngineFullVersion",
	"enhanced_vpc_routing":             "description.Snapshot.EnhancedVpcRouting",
	"estimated_seconds_to_completion":  "description.Snapshot.EstimatedSecondsToCompletion",
	"og_account_id":                    "metadata.SourceID",
	"kms_key_id":                       "description.Snapshot.KmsKeyId",
	"maintenance_track_name":           "description.Snapshot.MaintenanceTrackName",
	"manual_snapshot_remaining_days":   "description.Snapshot.ManualSnapshotRemainingDays",
	"manual_snapshot_retention_period": "description.Snapshot.ManualSnapshotRetentionPeriod",
	"master_username":                  "description.Snapshot.MasterUsername",
	"node_type":                        "description.Snapshot.NodeType",
	"number_of_nodes":                  "description.Snapshot.NumberOfNodes",
	"owner_account":                    "description.Snapshot.OwnerAccount",
	"port":                             "description.Snapshot.Port",
	"restorable_node_types":            "description.Snapshot.RestorableNodeTypes",
	"snapshot_create_time":             "description.Snapshot.SnapshotCreateTime",
	"snapshot_identifier":              "description.Snapshot.SnapshotIdentifier",
	"snapshot_retention_start_time":    "description.Snapshot.SnapshotRetentionStartTime",
	"snapshot_type":                    "description.Snapshot.SnapshotType",
	"source_region":                    "description.Snapshot.SourceRegion",
	"status":                           "description.Snapshot.Status",
	"tags_src":                         "description.Snapshot.Tags",
	"title":                            "description.Snapshot.SnapshotIdentifier",
	"total_backup_size_in_mega_bytes":  "description.Snapshot.TotalBackupSizeInMegaBytes",
	"vpc_id":                           "description.Snapshot.VpcId",
}

func ListRedshiftSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSnapshot NewRedshiftSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftSnapshotFilters = map[string]string{
	"accounts_with_restore_access":                 "description.Snapshot.AccountsWithRestoreAccess",
	"actual_incremental_backup_size_in_mega_bytes": "description.Snapshot.ActualIncrementalBackupSizeInMegaBytes",
	"availability_zone":                            "description.Snapshot.AvailabilityZone",
	"backup_progress_in_mega-bytes":                "description.Snapshot.BackupProgressInMegaBytes",
	"cluster_create_time":                          "description.Snapshot.ClusterCreateTime",
	"cluster_identifier":                           "description.Snapshot.ClusterIdentifier",
	"cluster_version":                              "description.Snapshot.ClusterVersion",
	"current_backup_rate_in_mega_bytes_per_second": "description.Snapshot.CurrentBackupRateInMegaBytesPerSecond",
	"db_name":                          "description.Snapshot.DBName",
	"elapsed_time_in_seconds":          "description.Snapshot.ElapsedTimeInSeconds",
	"encrypted":                        "description.Snapshot.Encrypted",
	"encrypted_with_hsm":               "description.Snapshot.EncryptedWithHSM",
	"engine_full_version":              "description.Snapshot.EngineFullVersion",
	"enhanced_vpc_routing":             "description.Snapshot.EnhancedVpcRouting",
	"estimated_seconds_to_completion":  "description.Snapshot.EstimatedSecondsToCompletion",
	"og_account_id":                    "metadata.SourceID",
	"kms_key_id":                       "description.Snapshot.KmsKeyId",
	"maintenance_track_name":           "description.Snapshot.MaintenanceTrackName",
	"manual_snapshot_remaining_days":   "description.Snapshot.ManualSnapshotRemainingDays",
	"manual_snapshot_retention_period": "description.Snapshot.ManualSnapshotRetentionPeriod",
	"master_username":                  "description.Snapshot.MasterUsername",
	"node_type":                        "description.Snapshot.NodeType",
	"number_of_nodes":                  "description.Snapshot.NumberOfNodes",
	"owner_account":                    "description.Snapshot.OwnerAccount",
	"port":                             "description.Snapshot.Port",
	"restorable_node_types":            "description.Snapshot.RestorableNodeTypes",
	"snapshot_create_time":             "description.Snapshot.SnapshotCreateTime",
	"snapshot_identifier":              "description.Snapshot.SnapshotIdentifier",
	"snapshot_retention_start_time":    "description.Snapshot.SnapshotRetentionStartTime",
	"snapshot_type":                    "description.Snapshot.SnapshotType",
	"source_region":                    "description.Snapshot.SourceRegion",
	"status":                           "description.Snapshot.Status",
	"tags_src":                         "description.Snapshot.Tags",
	"title":                            "description.Snapshot.SnapshotIdentifier",
	"total_backup_size_in_mega_bytes":  "description.Snapshot.TotalBackupSizeInMegaBytes",
	"vpc_id":                           "description.Snapshot.VpcId",
}

func GetRedshiftSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftSnapshot =============================

// ==========================  START: RedshiftServerlessNamespace =============================

type RedshiftServerlessNamespace struct {
	Description   aws.RedshiftServerlessNamespaceDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type RedshiftServerlessNamespaceHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  RedshiftServerlessNamespace `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type RedshiftServerlessNamespaceHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []RedshiftServerlessNamespaceHit `json:"hits"`
}

type RedshiftServerlessNamespaceSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  RedshiftServerlessNamespaceHits `json:"hits"`
}

type RedshiftServerlessNamespacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftServerlessNamespacePaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftServerlessNamespacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshiftserverless_namespace", filters, limit)
	if err != nil {
		return RedshiftServerlessNamespacePaginator{}, err
	}

	p := RedshiftServerlessNamespacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftServerlessNamespacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftServerlessNamespacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftServerlessNamespacePaginator) NextPage(ctx context.Context) ([]RedshiftServerlessNamespace, error) {
	var response RedshiftServerlessNamespaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftServerlessNamespace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftServerlessNamespaceFilters = map[string]string{
	"admin_username":       "description.Namespace.AdminUsername",
	"creation_date":        "description.Namespace.CreationDate",
	"db_name":              "description.Namespace.DbName",
	"default_iam_role_arn": "description.Namespace.DefaultIamRoleArn",
	"iam_roles":            "description.Namespace.IamRoles",
	"og_account_id":        "metadata.SourceID",
	"kms_key_id":           "description.Namespace.KmsKeyId",
	"log_exports":          "description.Namespace.LogExports",
	"namespace_arn":        "description.Namespace.NamespaceArn",
	"namespace_id":         "description.Namespace.NamespaceId",
	"namespace_name":       "description.Namespace.NamespaceName",
	"status":               "description.Namespace.Status",
	"tags_src":             "description.Tags",
	"title":                "description.Namespace.NamespaceName",
}

func ListRedshiftServerlessNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftServerlessNamespace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessNamespace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessNamespace NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftServerlessNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftServerlessNamespaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessNamespace NewRedshiftServerlessNamespacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftServerlessNamespace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftServerlessNamespaceFilters = map[string]string{
	"admin_username":       "description.Namespace.AdminUsername",
	"creation_date":        "description.Namespace.CreationDate",
	"db_name":              "description.Namespace.DbName",
	"default_iam_role_arn": "description.Namespace.DefaultIamRoleArn",
	"iam_roles":            "description.Namespace.IamRoles",
	"og_account_id":        "metadata.SourceID",
	"kms_key_id":           "description.Namespace.KmsKeyId",
	"log_exports":          "description.Namespace.LogExports",
	"namespace_arn":        "description.Namespace.NamespaceArn",
	"namespace_id":         "description.Namespace.NamespaceId",
	"namespace_name":       "description.Namespace.NamespaceName",
	"status":               "description.Namespace.Status",
	"tags_src":             "description.Tags",
	"title":                "description.Namespace.NamespaceName",
}

func GetRedshiftServerlessNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftServerlessNamespace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftServerlessNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftServerlessNamespaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftServerlessNamespace =============================

// ==========================  START: RedshiftServerlessSnapshot =============================

type RedshiftServerlessSnapshot struct {
	Description   aws.RedshiftServerlessSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type RedshiftServerlessSnapshotHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  RedshiftServerlessSnapshot `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type RedshiftServerlessSnapshotHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []RedshiftServerlessSnapshotHit `json:"hits"`
}

type RedshiftServerlessSnapshotSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  RedshiftServerlessSnapshotHits `json:"hits"`
}

type RedshiftServerlessSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftServerlessSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftServerlessSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshiftserverless_snapshot", filters, limit)
	if err != nil {
		return RedshiftServerlessSnapshotPaginator{}, err
	}

	p := RedshiftServerlessSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftServerlessSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftServerlessSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftServerlessSnapshotPaginator) NextPage(ctx context.Context) ([]RedshiftServerlessSnapshot, error) {
	var response RedshiftServerlessSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftServerlessSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftServerlessSnapshotFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"snapshot_arn":  "description.Snapshot.SnapshotArn",
	"snapshot_name": "description.Snapshot.SnapshotName",
	"title":         "description.Snapshot.SnapshotName",
}

func ListRedshiftServerlessSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftServerlessSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftServerlessSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftServerlessSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftServerlessSnapshot NewRedshiftServerlessSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftServerlessSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftServerlessSnapshotFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"snapshot_arn":  "description.Snapshot.SnapshotArn",
	"snapshot_name": "description.Snapshot.SnapshotName",
	"title":         "description.Snapshot.SnapshotName",
}

func GetRedshiftServerlessSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftServerlessSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftServerlessSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftServerlessSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftServerlessSnapshot =============================

// ==========================  START: RedshiftSubnetGroup =============================

type RedshiftSubnetGroup struct {
	Description   aws.RedshiftSubnetGroupDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type RedshiftSubnetGroupHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  RedshiftSubnetGroup `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type RedshiftSubnetGroupHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []RedshiftSubnetGroupHit `json:"hits"`
}

type RedshiftSubnetGroupSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  RedshiftSubnetGroupHits `json:"hits"`
}

type RedshiftSubnetGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedshiftSubnetGroupPaginator(filters []essdk.BoolFilter, limit *int64) (RedshiftSubnetGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_redshift_subnetgroup", filters, limit)
	if err != nil {
		return RedshiftSubnetGroupPaginator{}, err
	}

	p := RedshiftSubnetGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedshiftSubnetGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedshiftSubnetGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedshiftSubnetGroupPaginator) NextPage(ctx context.Context) ([]RedshiftSubnetGroup, error) {
	var response RedshiftSubnetGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedshiftSubnetGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedshiftSubnetGroupFilters = map[string]string{
	"cluster_subnet_group_name": "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"description":               "description.ClusterSubnetGroup.Description",
	"og_account_id":             "metadata.SourceID",
	"subnet_group_status":       "description.ClusterSubnetGroup.SubnetGroupStatus",
	"subnets":                   "description.ClusterSubnetGroup.Subnets",
	"tags_src":                  "description.ClusterSubnetGroup.Tags",
	"title":                     "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"vpc_id":                    "description.ClusterSubnetGroup.VpcId",
}

func ListRedshiftSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedshiftSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSubnetGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSubnetGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSubnetGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedshiftSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedshiftSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedshiftSubnetGroup NewRedshiftSubnetGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedshiftSubnetGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedshiftSubnetGroupFilters = map[string]string{
	"cluster_subnet_group_name": "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"description":               "description.ClusterSubnetGroup.Description",
	"og_account_id":             "metadata.SourceID",
	"subnet_group_status":       "description.ClusterSubnetGroup.SubnetGroupStatus",
	"subnets":                   "description.ClusterSubnetGroup.Subnets",
	"tags_src":                  "description.ClusterSubnetGroup.Tags",
	"title":                     "description.ClusterSubnetGroup.ClusterSubnetGroupName",
	"vpc_id":                    "description.ClusterSubnetGroup.VpcId",
}

func GetRedshiftSubnetGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedshiftSubnetGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedshiftSubnetGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedshiftSubnetGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedshiftSubnetGroup =============================

// ==========================  START: SNSTopic =============================

type SNSTopic struct {
	Description   aws.SNSTopicDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type SNSTopicHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SNSTopic      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SNSTopicHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SNSTopicHit     `json:"hits"`
}

type SNSTopicSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  SNSTopicHits `json:"hits"`
}

type SNSTopicPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSNSTopicPaginator(filters []essdk.BoolFilter, limit *int64) (SNSTopicPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sns_topic", filters, limit)
	if err != nil {
		return SNSTopicPaginator{}, err
	}

	p := SNSTopicPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SNSTopicPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SNSTopicPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SNSTopicPaginator) NextPage(ctx context.Context) ([]SNSTopic, error) {
	var response SNSTopicSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SNSTopic
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSNSTopicFilters = map[string]string{
	"application_failure_feedback_role_arn":    "description.Attributes.ApplicationFailureFeedbackRoleArn",
	"application_success_feedback_role_arn":    "description.Attributes.ApplicationSuccessFeedbackRoleArn",
	"application_success_feedback_sample_rate": "description.Attributes.ApplicationSuccessFeedbackSampleRate",
	"display_name":                          "description.Attributes.DisplayName",
	"firehose_failure_feedback_role_arn":    "description.Attributes.FirehoseFailureFeedbackRoleArn",
	"firehose_success_feedback_role_arn":    "description.Attributes.FirehoseSuccessFeedbackRoleArn",
	"firehose_success_feedback_sample_rate": "description.Attributes.FirehoseSuccessFeedbackSampleRate",
	"http_failure_feedback_role_arn":        "description.Attributes.HTTPFailureFeedbackRoleArn",
	"http_success_feedback_role_arn":        "description.Attributes.HTTPSuccessFeedbackRoleArn",
	"http_success_feedback_sample_rate":     "description.Attributes.HTTPSuccessFeedbackSampleRate",
	"og_account_id":                         "metadata.SourceID",
	"kms_master_key_id":                     "description.Attributes.KmsMasterKeyId",
	"lambda_failure_feedback_role_arn":      "description.Attributes.LambdaFailureFeedbackRoleArn",
	"lambda_success_feedback_role_arn":      "description.Attributes.LambdaSuccessFeedbackRoleArn",
	"lambda_success_feedback_sample_rate":   "description.Attributes.LambdaSuccessFeedbackSampleRate",
	"owner":                                 "description.Attributes.Owner",
	"sqs_failure_feedback_role_arn":         "description.Attributes.SQSFailureFeedbackRoleArn",
	"sqs_success_feedback_role_arn":         "description.Attributes.SQSSuccessFeedbackRoleArn",
	"sqs_success_feedback_sample_rate":      "description.Attributes.SQSSuccessFeedbackSampleRate",
	"subscriptions_confirmed":               "description.Attributes.SubscriptionsConfirmed",
	"subscriptions_deleted":                 "description.Attributes.SubscriptionsDeleted",
	"subscriptions_pending":                 "description.Attributes.SubscriptionsPending",
	"tags_src":                              "description.Tags",
	"topic_arn":                             "description.Attributes.TopicArn",
}

func ListSNSTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSNSTopic")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSTopic NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSTopic NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSTopic GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSTopic GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSTopic GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSNSTopicPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSNSTopicFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSTopic NewSNSTopicPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSNSTopic paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSNSTopicFilters = map[string]string{
	"application_failure_feedback_role_arn":    "description.Attributes.ApplicationFailureFeedbackRoleArn",
	"application_success_feedback_role_arn":    "description.Attributes.ApplicationSuccessFeedbackRoleArn",
	"application_success_feedback_sample_rate": "description.Attributes.ApplicationSuccessFeedbackSampleRate",
	"display_name":                          "description.Attributes.DisplayName",
	"firehose_failure_feedback_role_arn":    "description.Attributes.FirehoseFailureFeedbackRoleArn",
	"firehose_success_feedback_role_arn":    "description.Attributes.FirehoseSuccessFeedbackRoleArn",
	"firehose_success_feedback_sample_rate": "description.Attributes.FirehoseSuccessFeedbackSampleRate",
	"http_failure_feedback_role_arn":        "description.Attributes.HTTPFailureFeedbackRoleArn",
	"http_success_feedback_role_arn":        "description.Attributes.HTTPSuccessFeedbackRoleArn",
	"http_success_feedback_sample_rate":     "description.Attributes.HTTPSuccessFeedbackSampleRate",
	"og_account_id":                         "metadata.SourceID",
	"kms_master_key_id":                     "description.Attributes.KmsMasterKeyId",
	"lambda_failure_feedback_role_arn":      "description.Attributes.LambdaFailureFeedbackRoleArn",
	"lambda_success_feedback_role_arn":      "description.Attributes.LambdaSuccessFeedbackRoleArn",
	"lambda_success_feedback_sample_rate":   "description.Attributes.LambdaSuccessFeedbackSampleRate",
	"owner":                                 "description.Attributes.Owner",
	"sqs_failure_feedback_role_arn":         "description.Attributes.SQSFailureFeedbackRoleArn",
	"sqs_success_feedback_role_arn":         "description.Attributes.SQSSuccessFeedbackRoleArn",
	"sqs_success_feedback_sample_rate":      "description.Attributes.SQSSuccessFeedbackSampleRate",
	"subscriptions_confirmed":               "description.Attributes.SubscriptionsConfirmed",
	"subscriptions_deleted":                 "description.Attributes.SubscriptionsDeleted",
	"subscriptions_pending":                 "description.Attributes.SubscriptionsPending",
	"tags_src":                              "description.Tags",
	"topic_arn":                             "description.Attributes.TopicArn",
}

func GetSNSTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSNSTopic")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSNSTopicPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSNSTopicFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SNSTopic =============================

// ==========================  START: SNSSubscription =============================

type SNSSubscription struct {
	Description   aws.SNSSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type SNSSubscriptionHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  SNSSubscription `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type SNSSubscriptionHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []SNSSubscriptionHit `json:"hits"`
}

type SNSSubscriptionSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  SNSSubscriptionHits `json:"hits"`
}

type SNSSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSNSSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (SNSSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sns_subscription", filters, limit)
	if err != nil {
		return SNSSubscriptionPaginator{}, err
	}

	p := SNSSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SNSSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SNSSubscriptionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SNSSubscriptionPaginator) NextPage(ctx context.Context) ([]SNSSubscription, error) {
	var response SNSSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SNSSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSNSSubscriptionFilters = map[string]string{
	"confirmation_was_authenticated": "description.Attributes.ConfirmationWasAuthenticated",
	"endpoint":                       "description.Subscription.Endpoint",
	"og_account_id":                  "metadata.SourceID",
	"owner":                          "description.Subscription.Owner",
	"pending_confirmation":           "description.Attributes.PendingConfirmation",
	"protocol":                       "description.Subscription.Protocol",
	"raw_message_delivery":           "description.Attributes.RawMessageDelivery",
	"subscription_arn":               "description.Subscription.SubscriptionArn",
	"topic_arn":                      "description.Subscription.TopicArn",
}

func ListSNSSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSNSSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSSubscription NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSSubscription NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSNSSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSNSSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSNSSubscription NewSNSSubscriptionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSNSSubscription paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSNSSubscriptionFilters = map[string]string{
	"confirmation_was_authenticated": "description.Attributes.ConfirmationWasAuthenticated",
	"endpoint":                       "description.Subscription.Endpoint",
	"og_account_id":                  "metadata.SourceID",
	"owner":                          "description.Subscription.Owner",
	"pending_confirmation":           "description.Attributes.PendingConfirmation",
	"protocol":                       "description.Subscription.Protocol",
	"raw_message_delivery":           "description.Attributes.RawMessageDelivery",
	"subscription_arn":               "description.Subscription.SubscriptionArn",
	"topic_arn":                      "description.Subscription.TopicArn",
}

func GetSNSSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSNSSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSNSSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSNSSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SNSSubscription =============================

// ==========================  START: SQSQueue =============================

type SQSQueue struct {
	Description   aws.SQSQueueDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type SQSQueueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SQSQueue      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SQSQueueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SQSQueueHit     `json:"hits"`
}

type SQSQueueSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  SQSQueueHits `json:"hits"`
}

type SQSQueuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSQSQueuePaginator(filters []essdk.BoolFilter, limit *int64) (SQSQueuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sqs_queue", filters, limit)
	if err != nil {
		return SQSQueuePaginator{}, err
	}

	p := SQSQueuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SQSQueuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SQSQueuePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SQSQueuePaginator) NextPage(ctx context.Context) ([]SQSQueue, error) {
	var response SQSQueueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SQSQueue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSQSQueueFilters = map[string]string{
	"content_based_deduplication": "description.Attributes.ContentBasedDeduplication",
	"deduplication_scope":         "description.Attributes.DeduplicationScope",
	"delay_seconds":               "description.Attributes.DelaySeconds",
	"fifo_queue":                  "description.Attributes.FifoQueue",
	"fifo_throughput_limit":       "description.Attributes.FifoThroughputLimit",
	"og_account_id":               "metadata.SourceID",
	"kms_master_key_id":           "description.Attributes.KmsMasterKeyId",
	"max_message_size":            "description.Attributes.MaximumMessageSize",
	"message_retention_seconds":   "description.Attributes.MessageRetentionPeriod",
	"queue_arn":                   "description.Attributes.QueueArn",
	"queue_url":                   "description.Attributes.QueueUrl",
	"receive_wait_time_seconds":   "description.Attributes.ReceiveMessageWaitTimeSeconds",
	"sqs_managed_sse_enabled":     "description.Attributes.SqsManagedSseEnabled",
	"tags":                        "description.Tags",
	"visibility_timeout_seconds":  "description.Attributes.VisibilityTimeout",
}

func ListSQSQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSQSQueue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSQSQueue NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSQSQueue NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSQSQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSQSQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSQSQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSQSQueuePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSQSQueueFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSQSQueue NewSQSQueuePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSQSQueue paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSQSQueueFilters = map[string]string{
	"content_based_deduplication": "description.Attributes.ContentBasedDeduplication",
	"deduplication_scope":         "description.Attributes.DeduplicationScope",
	"delay_seconds":               "description.Attributes.DelaySeconds",
	"fifo_queue":                  "description.Attributes.FifoQueue",
	"fifo_throughput_limit":       "description.Attributes.FifoThroughputLimit",
	"og_account_id":               "metadata.SourceID",
	"kms_master_key_id":           "description.Attributes.KmsMasterKeyId",
	"max_message_size":            "description.Attributes.MaximumMessageSize",
	"message_retention_seconds":   "description.Attributes.MessageRetentionPeriod",
	"queue_arn":                   "description.Attributes.QueueArn",
	"queue_url":                   "description.Attributes.QueueUrl",
	"receive_wait_time_seconds":   "description.Attributes.ReceiveMessageWaitTimeSeconds",
	"sqs_managed_sse_enabled":     "description.Attributes.SqsManagedSseEnabled",
	"tags":                        "description.Tags",
	"visibility_timeout_seconds":  "description.Attributes.VisibilityTimeout",
}

func GetSQSQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSQSQueue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSQSQueuePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSQSQueueFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SQSQueue =============================

// ==========================  START: S3Bucket =============================

type S3Bucket struct {
	Description   aws.S3BucketDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type S3BucketHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  S3Bucket      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type S3BucketHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []S3BucketHit     `json:"hits"`
}

type S3BucketSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  S3BucketHits `json:"hits"`
}

type S3BucketPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3BucketPaginator(filters []essdk.BoolFilter, limit *int64) (S3BucketPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_bucket", filters, limit)
	if err != nil {
		return S3BucketPaginator{}, err
	}

	p := S3BucketPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3BucketPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3BucketPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p S3BucketPaginator) NextPage(ctx context.Context) ([]S3Bucket, error) {
	var response S3BucketSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3Bucket
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3BucketFilters = map[string]string{
	"acl":                                  "description.BucketAcl",
	"arn":                                  "arn",
	"block_public_acls":                    "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":                  "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_policy_is_public":              "description.PolicyStatus.IsPublic",
	"creation_date":                        "description.Bucket.CreationDate",
	"event_notification_configuration":     "description.EventNotificationConfiguration",
	"ignore_public_acls":                   "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"og_account_id":                        "metadata.SourceID",
	"logging":                              "description.LoggingEnabled",
	"name":                                 "description.Bucket.Name",
	"object_lock_configuration":            "description.ObjectLockConfiguration",
	"object_ownership_controls":            "description.BucketOwnershipControls.OwnershipControls",
	"policy":                               "description.Policy",
	"region":                               "description.Region",
	"replication":                          "description.ReplicationConfiguration",
	"restrict_public_buckets":              "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"server_side_encryption_configuration": "description.ServerSideEncryptionConfiguration",
	"tags_src":                             "description.Tags",
	"title":                                "description.Bucket.Name",
	"website_configuration":                "description.BucketWebsite",
}

func ListS3Bucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3Bucket")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Bucket NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Bucket NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Bucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Bucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Bucket GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewS3BucketPaginator(essdk.BuildFilter(ctx, d.QueryContext, listS3BucketFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Bucket NewS3BucketPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListS3Bucket paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getS3BucketFilters = map[string]string{
	"acl":                                  "description.BucketAcl",
	"arn":                                  "arn",
	"block_public_acls":                    "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":                  "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_policy_is_public":              "description.PolicyStatus.IsPublic",
	"creation_date":                        "description.Bucket.CreationDate",
	"event_notification_configuration":     "description.EventNotificationConfiguration",
	"ignore_public_acls":                   "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"og_account_id":                        "metadata.SourceID",
	"logging":                              "description.LoggingEnabled",
	"name":                                 "description.Bucket.Name",
	"object_lock_configuration":            "description.ObjectLockConfiguration",
	"object_ownership_controls":            "description.BucketOwnershipControls.OwnershipControls",
	"policy":                               "description.Policy",
	"region":                               "description.Region",
	"replication":                          "description.ReplicationConfiguration",
	"restrict_public_buckets":              "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"server_side_encryption_configuration": "description.ServerSideEncryptionConfiguration",
	"tags_src":                             "description.Tags",
	"title":                                "description.Bucket.Name",
	"website_configuration":                "description.BucketWebsite",
}

func GetS3Bucket(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3Bucket")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewS3BucketPaginator(essdk.BuildFilter(ctx, d.QueryContext, getS3BucketFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: S3Bucket =============================

// ==========================  START: S3AccountSetting =============================

type S3AccountSetting struct {
	Description   aws.S3AccountSettingDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type S3AccountSettingHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  S3AccountSetting `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type S3AccountSettingHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []S3AccountSettingHit `json:"hits"`
}

type S3AccountSettingSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  S3AccountSettingHits `json:"hits"`
}

type S3AccountSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3AccountSettingPaginator(filters []essdk.BoolFilter, limit *int64) (S3AccountSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_accountsetting", filters, limit)
	if err != nil {
		return S3AccountSettingPaginator{}, err
	}

	p := S3AccountSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3AccountSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3AccountSettingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p S3AccountSettingPaginator) NextPage(ctx context.Context) ([]S3AccountSetting, error) {
	var response S3AccountSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3AccountSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3AccountSettingFilters = map[string]string{
	"block_public_acls":       "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":     "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"ignore_public_acls":      "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"og_account_id":           "metadata.SourceID",
	"restrict_public_buckets": "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
}

func ListS3AccountSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3AccountSetting")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccountSetting NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccountSetting NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccountSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccountSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccountSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewS3AccountSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listS3AccountSettingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccountSetting NewS3AccountSettingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListS3AccountSetting paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getS3AccountSettingFilters = map[string]string{
	"block_public_acls":       "description.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":     "description.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"ignore_public_acls":      "description.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"og_account_id":           "metadata.SourceID",
	"restrict_public_buckets": "description.PublicAccessBlockConfiguration.RestrictPublicBuckets",
}

func GetS3AccountSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3AccountSetting")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewS3AccountSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getS3AccountSettingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: S3AccountSetting =============================

// ==========================  START: S3Object =============================

type S3Object struct {
	Description   aws.S3ObjectDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type S3ObjectHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  S3Object      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type S3ObjectHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []S3ObjectHit     `json:"hits"`
}

type S3ObjectSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  S3ObjectHits `json:"hits"`
}

type S3ObjectPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3ObjectPaginator(filters []essdk.BoolFilter, limit *int64) (S3ObjectPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_object", filters, limit)
	if err != nil {
		return S3ObjectPaginator{}, err
	}

	p := S3ObjectPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3ObjectPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3ObjectPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p S3ObjectPaginator) NextPage(ctx context.Context) ([]S3Object, error) {
	var response S3ObjectSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3Object
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3ObjectFilters = map[string]string{
	"accept_ranges":                 "description.Object.AcceptRanges",
	"acl":                           "description.ObjectAcl",
	"body":                          "description.Object.Body",
	"bucket_key_enabled":            "description.Object.BucketKeyEnabled",
	"bucket_name":                   "description.BucketName",
	"cache_control":                 "description.Object.CacheControl",
	"checksum":                      "description.ObjectAttributes.Checksum",
	"checksum_crc32":                "description.Object.ChecksumCRC32",
	"checksum_crc32c":               "description.Object.ChecksumCRC32C",
	"checksum_sha1":                 "description.Object.ChecksumSHA1",
	"checksum_sha256":               "description.Object.ChecksumSHA256",
	"content_disposition":           "description.Object.ContentDisposition",
	"content_encoding":              "description.Object.ContentEncoding",
	"content_language":              "description.Object.ContentLanguage",
	"content_length":                "description.Object.ContentLength",
	"content_range":                 "description.Object.ContentRange",
	"content_type":                  "description.Object.ContentType",
	"delete_marker":                 "description.Object.DeleteMarker",
	"etag":                          "description.Object.ETag",
	"expiration":                    "description.Object.Expiration",
	"expires":                       "description.Object.Expires",
	"og_account_id":                 "metadata.SourceID",
	"key":                           "description.ObjectSummary.Key",
	"last_modified":                 "description.ObjectSummary.LastModified",
	"metadata":                      "description.Object.Metadata",
	"object_lock_legal_hold_status": "description.Object.ObjectLockLegalHoldStatus",
	"object_lock_mode":              "description.Object.ObjectLockMode",
	"object_lock_retain_until_date": "description.Object.ObjectLockRetainUntilDate",
	"object_parts":                  "description.ObjectAttributes.ObjectParts",
	"owner":                         "description.ObjectSummary.Owner",
	"parts_count":                   "description.Object.PartsCount",
	"replication_status":            "escription.Object.ReplicationStatus",
	"request_charged":               "escription.Object.RequestCharged",
	"restore":                       "escription.Object.Restore",
	"server_side_encryption":        "description.Object.ServerSideEncryption",
	"size":                          "description.ObjectSummary.Size",
	"sse_customer_algorithm":        "description.Object.SSECustomerAlgorithm",
	"sse_customer_key_md5":          "description.Object.SSECustomerKeyMD5",
	"sse_kms_key_id":                "description.Object.SSEKMSKeyId",
	"storage_class":                 "description.Object.StorageClass",
	"tag_count":                     "description.Object.TagCount",
	"tags":                          "description.ObjectTags",
	"tags_src":                      "description.ObjectTags.TagSet",
	"title":                         "description.ObjectSummary.Key",
	"version_id":                    "description.Object.VersionId",
	"website_redirection_location":  "description.Object.WebsiteRedirectLocation",
}

func ListS3Object(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3Object")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Object NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Object NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Object GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Object GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Object GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewS3ObjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, listS3ObjectFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3Object NewS3ObjectPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListS3Object paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getS3ObjectFilters = map[string]string{
	"accept_ranges":                 "description.Object.AcceptRanges",
	"acl":                           "description.ObjectAcl",
	"body":                          "description.Object.Body",
	"bucket_key_enabled":            "description.Object.BucketKeyEnabled",
	"bucket_name":                   "description.BucketName",
	"cache_control":                 "description.Object.CacheControl",
	"checksum":                      "description.ObjectAttributes.Checksum",
	"checksum_crc32":                "description.Object.ChecksumCRC32",
	"checksum_crc32c":               "description.Object.ChecksumCRC32C",
	"checksum_sha1":                 "description.Object.ChecksumSHA1",
	"checksum_sha256":               "description.Object.ChecksumSHA256",
	"content_disposition":           "description.Object.ContentDisposition",
	"content_encoding":              "description.Object.ContentEncoding",
	"content_language":              "description.Object.ContentLanguage",
	"content_length":                "description.Object.ContentLength",
	"content_range":                 "description.Object.ContentRange",
	"content_type":                  "description.Object.ContentType",
	"delete_marker":                 "description.Object.DeleteMarker",
	"etag":                          "description.Object.ETag",
	"expiration":                    "description.Object.Expiration",
	"expires":                       "description.Object.Expires",
	"og_account_id":                 "metadata.SourceID",
	"key":                           "description.ObjectSummary.Key",
	"last_modified":                 "description.ObjectSummary.LastModified",
	"metadata":                      "description.Object.Metadata",
	"object_lock_legal_hold_status": "description.Object.ObjectLockLegalHoldStatus",
	"object_lock_mode":              "description.Object.ObjectLockMode",
	"object_lock_retain_until_date": "description.Object.ObjectLockRetainUntilDate",
	"object_parts":                  "description.ObjectAttributes.ObjectParts",
	"owner":                         "description.ObjectSummary.Owner",
	"parts_count":                   "description.Object.PartsCount",
	"replication_status":            "escription.Object.ReplicationStatus",
	"request_charged":               "escription.Object.RequestCharged",
	"restore":                       "escription.Object.Restore",
	"server_side_encryption":        "description.Object.ServerSideEncryption",
	"size":                          "description.ObjectSummary.Size",
	"sse_customer_algorithm":        "description.Object.SSECustomerAlgorithm",
	"sse_customer_key_md5":          "description.Object.SSECustomerKeyMD5",
	"sse_kms_key_id":                "description.Object.SSEKMSKeyId",
	"storage_class":                 "description.Object.StorageClass",
	"tag_count":                     "description.Object.TagCount",
	"tags":                          "description.ObjectTags",
	"tags_src":                      "description.ObjectTags.TagSet",
	"title":                         "description.ObjectSummary.Key",
	"version_id":                    "description.Object.VersionId",
	"website_redirection_location":  "description.Object.WebsiteRedirectLocation",
}

func GetS3Object(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3Object")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewS3ObjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, getS3ObjectFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: S3Object =============================

// ==========================  START: S3BucketIntelligentTieringConfiguration =============================

type S3BucketIntelligentTieringConfiguration struct {
	Description   aws.S3BucketIntelligentTieringConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                           `json:"metadata"`
	ResourceJobID int                                                    `json:"resource_job_id"`
	SourceJobID   int                                                    `json:"source_job_id"`
	ResourceType  string                                                 `json:"resource_type"`
	SourceType    string                                                 `json:"source_type"`
	ID            string                                                 `json:"id"`
	ARN           string                                                 `json:"arn"`
	SourceID      string                                                 `json:"source_id"`
}

type S3BucketIntelligentTieringConfigurationHit struct {
	ID      string                                  `json:"_id"`
	Score   float64                                 `json:"_score"`
	Index   string                                  `json:"_index"`
	Type    string                                  `json:"_type"`
	Version int64                                   `json:"_version,omitempty"`
	Source  S3BucketIntelligentTieringConfiguration `json:"_source"`
	Sort    []interface{}                           `json:"sort"`
}

type S3BucketIntelligentTieringConfigurationHits struct {
	Total essdk.SearchTotal                            `json:"total"`
	Hits  []S3BucketIntelligentTieringConfigurationHit `json:"hits"`
}

type S3BucketIntelligentTieringConfigurationSearchResponse struct {
	PitID string                                      `json:"pit_id"`
	Hits  S3BucketIntelligentTieringConfigurationHits `json:"hits"`
}

type S3BucketIntelligentTieringConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3BucketIntelligentTieringConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (S3BucketIntelligentTieringConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_bucketintelligenttieringconfiguration", filters, limit)
	if err != nil {
		return S3BucketIntelligentTieringConfigurationPaginator{}, err
	}

	p := S3BucketIntelligentTieringConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3BucketIntelligentTieringConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3BucketIntelligentTieringConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p S3BucketIntelligentTieringConfigurationPaginator) NextPage(ctx context.Context) ([]S3BucketIntelligentTieringConfiguration, error) {
	var response S3BucketIntelligentTieringConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3BucketIntelligentTieringConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3BucketIntelligentTieringConfigurationFilters = map[string]string{
	"bucket_name":   "description.BucketName",
	"filter":        "description.IntelligentTieringConfiguration.Filter",
	"id":            "description.IntelligentTieringConfiguration.Id",
	"og_account_id": "metadata.SourceID",
	"status":        "description.IntelligentTieringConfiguration.Status",
	"tierings":      "description.IntelligentTieringConfiguration.Tierings",
	"title":         "description.IntelligentTieringConfiguration.Id",
}

func ListS3BucketIntelligentTieringConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3BucketIntelligentTieringConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3BucketIntelligentTieringConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3BucketIntelligentTieringConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3BucketIntelligentTieringConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3BucketIntelligentTieringConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3BucketIntelligentTieringConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewS3BucketIntelligentTieringConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listS3BucketIntelligentTieringConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3BucketIntelligentTieringConfiguration NewS3BucketIntelligentTieringConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListS3BucketIntelligentTieringConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getS3BucketIntelligentTieringConfigurationFilters = map[string]string{
	"bucket_name":   "description.BucketName",
	"filter":        "description.IntelligentTieringConfiguration.Filter",
	"id":            "description.IntelligentTieringConfiguration.Id",
	"og_account_id": "metadata.SourceID",
	"status":        "description.IntelligentTieringConfiguration.Status",
	"tierings":      "description.IntelligentTieringConfiguration.Tierings",
	"title":         "description.IntelligentTieringConfiguration.Id",
}

func GetS3BucketIntelligentTieringConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3BucketIntelligentTieringConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewS3BucketIntelligentTieringConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getS3BucketIntelligentTieringConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: S3BucketIntelligentTieringConfiguration =============================

// ==========================  START: S3MultiRegionAccessPoint =============================

type S3MultiRegionAccessPoint struct {
	Description   aws.S3MultiRegionAccessPointDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type S3MultiRegionAccessPointHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  S3MultiRegionAccessPoint `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type S3MultiRegionAccessPointHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []S3MultiRegionAccessPointHit `json:"hits"`
}

type S3MultiRegionAccessPointSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  S3MultiRegionAccessPointHits `json:"hits"`
}

type S3MultiRegionAccessPointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3MultiRegionAccessPointPaginator(filters []essdk.BoolFilter, limit *int64) (S3MultiRegionAccessPointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_multiregionaccesspoint", filters, limit)
	if err != nil {
		return S3MultiRegionAccessPointPaginator{}, err
	}

	p := S3MultiRegionAccessPointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3MultiRegionAccessPointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3MultiRegionAccessPointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p S3MultiRegionAccessPointPaginator) NextPage(ctx context.Context) ([]S3MultiRegionAccessPoint, error) {
	var response S3MultiRegionAccessPointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3MultiRegionAccessPoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3MultiRegionAccessPointFilters = map[string]string{
	"alias":               "description.Report.Alias",
	"created_at":          "description.Report.CreatedAt",
	"og_account_id":       "metadata.SourceID",
	"name":                "description.Report.Name",
	"public_access_block": "description.Report.PublicAccessBlock",
	"regions":             "description.Report.Regions",
	"status":              "description.Report.Status",
	"title":               "description.Report.Name",
}

func ListS3MultiRegionAccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3MultiRegionAccessPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3MultiRegionAccessPoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3MultiRegionAccessPoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3MultiRegionAccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3MultiRegionAccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3MultiRegionAccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewS3MultiRegionAccessPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listS3MultiRegionAccessPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3MultiRegionAccessPoint NewS3MultiRegionAccessPointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListS3MultiRegionAccessPoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getS3MultiRegionAccessPointFilters = map[string]string{
	"alias":               "description.Report.Alias",
	"created_at":          "description.Report.CreatedAt",
	"og_account_id":       "metadata.SourceID",
	"name":                "description.Report.Name",
	"public_access_block": "description.Report.PublicAccessBlock",
	"regions":             "description.Report.Regions",
	"status":              "description.Report.Status",
	"title":               "description.Report.Name",
}

func GetS3MultiRegionAccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3MultiRegionAccessPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewS3MultiRegionAccessPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getS3MultiRegionAccessPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: S3MultiRegionAccessPoint =============================

// ==========================  START: SageMakerEndpointConfiguration =============================

type SageMakerEndpointConfiguration struct {
	Description   aws.SageMakerEndpointConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type SageMakerEndpointConfigurationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  SageMakerEndpointConfiguration `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type SageMakerEndpointConfigurationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []SageMakerEndpointConfigurationHit `json:"hits"`
}

type SageMakerEndpointConfigurationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  SageMakerEndpointConfigurationHits `json:"hits"`
}

type SageMakerEndpointConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerEndpointConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerEndpointConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_endpointconfiguration", filters, limit)
	if err != nil {
		return SageMakerEndpointConfigurationPaginator{}, err
	}

	p := SageMakerEndpointConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerEndpointConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerEndpointConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SageMakerEndpointConfigurationPaginator) NextPage(ctx context.Context) ([]SageMakerEndpointConfiguration, error) {
	var response SageMakerEndpointConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerEndpointConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerEndpointConfigurationFilters = map[string]string{
	"arn":                 "description.EndpointConfig.EndpointConfigArn",
	"creation_time":       "description.EndpointConfig.CreationTime",
	"data_capture_config": "description.EndpointConfig.DataCaptureConfig",
	"og_account_id":       "metadata.SourceID",
	"kms_key_id":          "description.EndpointConfig.KmsKeyId",
	"name":                "description.EndpointConfig.EndpointConfigName",
	"production_variants": "description.EndpointConfig.ProductionVariants",
	"tags_src":            "description.Tags",
	"title":               "description.EndpointConfig.EndpointConfigName",
}

func ListSageMakerEndpointConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerEndpointConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerEndpointConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerEndpointConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerEndpointConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerEndpointConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerEndpointConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSageMakerEndpointConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSageMakerEndpointConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerEndpointConfiguration NewSageMakerEndpointConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSageMakerEndpointConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSageMakerEndpointConfigurationFilters = map[string]string{
	"arn":                 "description.EndpointConfig.EndpointConfigArn",
	"creation_time":       "description.EndpointConfig.CreationTime",
	"data_capture_config": "description.EndpointConfig.DataCaptureConfig",
	"og_account_id":       "metadata.SourceID",
	"kms_key_id":          "description.EndpointConfig.KmsKeyId",
	"name":                "description.EndpointConfig.EndpointConfigName",
	"production_variants": "description.EndpointConfig.ProductionVariants",
	"tags_src":            "description.Tags",
	"title":               "description.EndpointConfig.EndpointConfigName",
}

func GetSageMakerEndpointConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerEndpointConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSageMakerEndpointConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSageMakerEndpointConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SageMakerEndpointConfiguration =============================

// ==========================  START: SageMakerApp =============================

type SageMakerApp struct {
	Description   aws.SageMakerAppDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type SageMakerAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SageMakerApp  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SageMakerAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SageMakerAppHit `json:"hits"`
}

type SageMakerAppSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SageMakerAppHits `json:"hits"`
}

type SageMakerAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerAppPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_app", filters, limit)
	if err != nil {
		return SageMakerAppPaginator{}, err
	}

	p := SageMakerAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerAppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SageMakerAppPaginator) NextPage(ctx context.Context) ([]SageMakerApp, error) {
	var response SageMakerAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerAppFilters = map[string]string{
	"app_type":                     "description.AppDetails.AppType",
	"arn":                          "description.DescribeAppOutput.AppArn",
	"creation_time":                "description.AppDetails.CreationTime",
	"domain_id":                    "description.DescribeAppOutput.DomainId",
	"failure_reason":               "description.DescribeAppOutput.FailureReason",
	"og_account_id":                "metadata.SourceID",
	"last_health_check_timestamp":  "description.DescribeAppOutput.LastHealthCheckTimestamp",
	"last_user_activity_timestamp": "description.DescribeAppOutput.LastUserActivityTimestamp",
	"name":                         "description.AppDetails.AppName",
	"resource_spec":                "description.DescribeAppOutput.ResourceSpec",
	"status":                       "description.AppDetails.Status",
	"title":                        "description.AppDetails.AppName",
	"user_profile_name":            "description.DescribeAppOutput.UserProfileName",
}

func ListSageMakerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerApp NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSageMakerAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSageMakerAppFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerApp NewSageMakerAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSageMakerApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSageMakerAppFilters = map[string]string{
	"app_type":                     "description.DescribeAppOutput.AppType",
	"arn":                          "description.DescribeAppOutput.AppArn",
	"creation_time":                "description.AppDetails.CreationTime",
	"domain_id":                    "description.DescribeAppOutput.DomainId",
	"failure_reason":               "description.DescribeAppOutput.FailureReason",
	"og_account_id":                "metadata.SourceID",
	"last_health_check_timestamp":  "description.DescribeAppOutput.LastHealthCheckTimestamp",
	"last_user_activity_timestamp": "description.DescribeAppOutput.LastUserActivityTimestamp",
	"name":                         "description.DescribeAppOutput.AppName",
	"resource_spec":                "description.DescribeAppOutput.ResourceSpec",
	"status":                       "description.AppDetails.Status",
	"title":                        "description.AppDetails.AppName",
	"user_profile_name":            "description.DescribeAppOutput.UserProfileName",
}

func GetSageMakerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSageMakerAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSageMakerAppFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SageMakerApp =============================

// ==========================  START: SageMakerDomain =============================

type SageMakerDomain struct {
	Description   aws.SageMakerDomainDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type SageMakerDomainHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  SageMakerDomain `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type SageMakerDomainHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []SageMakerDomainHit `json:"hits"`
}

type SageMakerDomainSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  SageMakerDomainHits `json:"hits"`
}

type SageMakerDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerDomainPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_domain", filters, limit)
	if err != nil {
		return SageMakerDomainPaginator{}, err
	}

	p := SageMakerDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerDomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SageMakerDomainPaginator) NextPage(ctx context.Context) ([]SageMakerDomain, error) {
	var response SageMakerDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerDomainFilters = map[string]string{
	"app_network_access_type":               "description.Domain.AppNetworkAccessType",
	"app_security_group_management":         "description.Domain.AppSecurityGroupManagement",
	"arn":                                   "description.Domain.DomainArn",
	"auth_mode":                             "description.Domain.AuthMode",
	"creation_time":                         "description.Domain.CreationTime",
	"default_user_settings":                 "description.Domain.DefaultUserSettings",
	"domain_settings":                       "description.Domain.DomainSettings",
	"failure_reason":                        "description.Domain.FailureReason",
	"home_efs_file_system_id":               "description.Domain.HomeEfsFileSystemId",
	"id":                                    "description.Domain.DomainId",
	"og_account_id":                         "metadata.SourceID",
	"kms_key_id":                            "description.Domain.KmsKeyId",
	"last_modified_time":                    "description.Domain.LastModifiedTime",
	"name":                                  "description.Domain.DomainName",
	"security_group_id_for_domain_boundary": "description.Domain.SecurityGroupIdForDomainBoundary",
	"single_sign_on_managed_application_instance_id": "description.Domain.SingleSignOnManagedApplicationInstanceId",
	"status":     "description.Domain.Status",
	"subnet_ids": "description.Domain.SubnetIds",
	"tags_src":   "description.Tags",
	"title":      "description.Domain.DomainName",
	"url":        "description.DomainItem.Url",
}

func ListSageMakerDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSageMakerDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSageMakerDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerDomain NewSageMakerDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSageMakerDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSageMakerDomainFilters = map[string]string{
	"app_network_access_type":               "description.Domain.AppNetworkAccessType",
	"app_security_group_management":         "description.Domain.AppSecurityGroupManagement",
	"arn":                                   "description.Domain.DomainArn",
	"auth_mode":                             "description.Domain.AuthMode",
	"creation_time":                         "description.Domain.CreationTime",
	"default_user_settings":                 "description.Domain.DefaultUserSettings",
	"domain_settings":                       "description.Domain.DomainSettings",
	"failure_reason":                        "description.Domain.FailureReason",
	"home_efs_file_system_id":               "description.Domain.HomeEfsFileSystemId",
	"id":                                    "description.Domain.DomainId",
	"og_account_id":                         "metadata.SourceID",
	"kms_key_id":                            "description.Domain.KmsKeyId",
	"last_modified_time":                    "description.Domain.LastModifiedTime",
	"name":                                  "description.Domain.DomainName",
	"security_group_id_for_domain_boundary": "description.Domain.SecurityGroupIdForDomainBoundary",
	"single_sign_on_managed_application_instance_id": "description.Domain.SingleSignOnManagedApplicationInstanceId",
	"status":     "description.Domain.Status",
	"subnet_ids": "description.Domain.SubnetIds",
	"tags_src":   "description.Tags",
	"title":      "description.Domain.DomainName",
	"url":        "description.DomainItem.Url",
}

func GetSageMakerDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSageMakerDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSageMakerDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SageMakerDomain =============================

// ==========================  START: SageMakerNotebookInstance =============================

type SageMakerNotebookInstance struct {
	Description   aws.SageMakerNotebookInstanceDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type SageMakerNotebookInstanceHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  SageMakerNotebookInstance `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type SageMakerNotebookInstanceHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []SageMakerNotebookInstanceHit `json:"hits"`
}

type SageMakerNotebookInstanceSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  SageMakerNotebookInstanceHits `json:"hits"`
}

type SageMakerNotebookInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerNotebookInstancePaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerNotebookInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_notebookinstance", filters, limit)
	if err != nil {
		return SageMakerNotebookInstancePaginator{}, err
	}

	p := SageMakerNotebookInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerNotebookInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerNotebookInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SageMakerNotebookInstancePaginator) NextPage(ctx context.Context) ([]SageMakerNotebookInstance, error) {
	var response SageMakerNotebookInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerNotebookInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerNotebookInstanceFilters = map[string]string{
	"accelerator_types":            "description.NotebookInstance.AcceleratorTypes",
	"additional_code_repositories": "description.NotebookInstance.AdditionalCodeRepositories",
	"arn":                          "description.NotebookInstance.NotebookInstanceArn",
	"creation_time":                "description.NotebookInstance.CreationTime",
	"default_code_repository":      "description.NotebookInstance.DefaultCodeRepository",
	"direct_internet_access":       "description.NotebookInstance.DirectInternetAccess",
	"failure_reason":               "description.NotebookInstance.FailureReason",
	"instance_type":                "description.NotebookInstance.InstanceType",
	"og_account_id":                "metadata.SourceID",
	"kms_key_id":                   "description.NotebookInstance.KmsKeyId",
	"last_modified_time":           "description.NotebookInstance.LastModifiedTime",
	"name":                         "description.NotebookInstance.NotebookInstanceName",
	"network_interface_id":         "description.NotebookInstance.NetworkInterfaceId",
	"notebook_instance_lifecycle_config_name": "description.NotebookInstance.NotebookInstanceLifecycleConfigName",
	"notebook_instance_status":                "description.NotebookInstance.NotebookInstanceStatus",
	"role_arn":                                "description.NotebookInstance.RoleArn",
	"root_access":                             "description.NotebookInstance.RootAccess",
	"security_groups":                         "description.NotebookInstance.SecurityGroups",
	"subnet_id":                               "description.NotebookInstance.SubnetId",
	"tags_src":                                "description.Tags",
	"title":                                   "description.NotebookInstance.NotebookInstanceName",
	"url":                                     "description.NotebookInstance.Url",
	"volume_size_in_gb":                       "description.NotebookInstance.VolumeSizeInGB",
}

func ListSageMakerNotebookInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerNotebookInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerNotebookInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerNotebookInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerNotebookInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerNotebookInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerNotebookInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSageMakerNotebookInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSageMakerNotebookInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerNotebookInstance NewSageMakerNotebookInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSageMakerNotebookInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSageMakerNotebookInstanceFilters = map[string]string{
	"accelerator_types":            "description.NotebookInstance.AcceleratorTypes",
	"additional_code_repositories": "description.NotebookInstance.AdditionalCodeRepositories",
	"arn":                          "description.NotebookInstance.NotebookInstanceArn",
	"creation_time":                "description.NotebookInstance.CreationTime",
	"default_code_repository":      "description.NotebookInstance.DefaultCodeRepository",
	"direct_internet_access":       "description.NotebookInstance.DirectInternetAccess",
	"failure_reason":               "description.NotebookInstance.FailureReason",
	"instance_type":                "description.NotebookInstance.InstanceType",
	"og_account_id":                "metadata.SourceID",
	"kms_key_id":                   "description.NotebookInstance.KmsKeyId",
	"last_modified_time":           "description.NotebookInstance.LastModifiedTime",
	"name":                         "description.NotebookInstance.NotebookInstanceName",
	"network_interface_id":         "description.NotebookInstance.NetworkInterfaceId",
	"notebook_instance_lifecycle_config_name": "description.NotebookInstance.NotebookInstanceLifecycleConfigName",
	"notebook_instance_status":                "description.NotebookInstance.NotebookInstanceStatus",
	"role_arn":                                "description.NotebookInstance.RoleArn",
	"root_access":                             "description.NotebookInstance.RootAccess",
	"security_groups":                         "description.NotebookInstance.SecurityGroups",
	"subnet_id":                               "description.NotebookInstance.SubnetId",
	"tags_src":                                "description.Tags",
	"title":                                   "description.NotebookInstance.NotebookInstanceName",
	"url":                                     "description.NotebookInstance.Url",
	"volume_size_in_gb":                       "description.NotebookInstance.VolumeSizeInGB",
}

func GetSageMakerNotebookInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerNotebookInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSageMakerNotebookInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSageMakerNotebookInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SageMakerNotebookInstance =============================

// ==========================  START: SageMakerModel =============================

type SageMakerModel struct {
	Description   aws.SageMakerModelDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type SageMakerModelHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SageMakerModel `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SageMakerModelHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SageMakerModelHit `json:"hits"`
}

type SageMakerModelSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SageMakerModelHits `json:"hits"`
}

type SageMakerModelPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerModelPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerModelPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_model", filters, limit)
	if err != nil {
		return SageMakerModelPaginator{}, err
	}

	p := SageMakerModelPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerModelPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerModelPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SageMakerModelPaginator) NextPage(ctx context.Context) ([]SageMakerModel, error) {
	var response SageMakerModelSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerModel
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerModelFilters = map[string]string{
	"arn":                        "description.Model.ModelArn",
	"containers":                 "description.Model.Containers",
	"creation_time":              "description.Model.CreationTime",
	"enable_network_isolation":   "description.Model.EnableNetworkIsolation",
	"execution_role_arn":         "description.Model.ExecutionRoleArn",
	"inference_execution_config": "description.Model.InferenceExecutionConfig",
	"og_account_id":              "metadata.SourceID",
	"name":                       "description.Model.ModelName",
	"primary_container":          "description.Model.PrimaryContainer",
	"tags_src":                   "description.Tags",
	"title":                      "description.Model.ModelName",
	"vpc_config":                 "description.Model.VpcConfig",
}

func ListSageMakerModel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerModel")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerModel NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerModel NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerModel GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerModel GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerModel GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSageMakerModelPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSageMakerModelFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerModel NewSageMakerModelPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSageMakerModel paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSageMakerModelFilters = map[string]string{
	"arn":                        "description.Model.ModelArn",
	"containers":                 "description.Model.Containers",
	"creation_time":              "description.Model.CreationTime",
	"enable_network_isolation":   "description.Model.EnableNetworkIsolation",
	"execution_role_arn":         "description.Model.ExecutionRoleArn",
	"inference_execution_config": "description.Model.InferenceExecutionConfig",
	"og_account_id":              "metadata.SourceID",
	"name":                       "description.Model.ModelName",
	"primary_container":          "description.Model.PrimaryContainer",
	"tags_src":                   "description.Tags",
	"title":                      "description.Model.ModelName",
	"vpc_config":                 "description.Model.VpcConfig",
}

func GetSageMakerModel(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerModel")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSageMakerModelPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSageMakerModelFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SageMakerModel =============================

// ==========================  START: SageMakerTrainingJob =============================

type SageMakerTrainingJob struct {
	Description   aws.SageMakerTrainingJobDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SageMakerTrainingJobHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SageMakerTrainingJob `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SageMakerTrainingJobHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SageMakerTrainingJobHit `json:"hits"`
}

type SageMakerTrainingJobSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SageMakerTrainingJobHits `json:"hits"`
}

type SageMakerTrainingJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSageMakerTrainingJobPaginator(filters []essdk.BoolFilter, limit *int64) (SageMakerTrainingJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sagemaker_trainingjob", filters, limit)
	if err != nil {
		return SageMakerTrainingJobPaginator{}, err
	}

	p := SageMakerTrainingJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SageMakerTrainingJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SageMakerTrainingJobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SageMakerTrainingJobPaginator) NextPage(ctx context.Context) ([]SageMakerTrainingJob, error) {
	var response SageMakerTrainingJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SageMakerTrainingJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSageMakerTrainingJobFilters = map[string]string{
	"algorithm_specification":                   "description.TrainingJob.AlgorithmSpecification",
	"arn":                                       "description.TrainingJob.TrainingJobArn",
	"auto_ml_job_arn":                           "description.TrainingJob.AutoMLJobArn",
	"billable_time_in_seconds":                  "description.TrainingJob.BillableTimeInSeconds",
	"checkpoint_config":                         "description.TrainingJob.CheckpointConfig",
	"creation_time":                             "description.TrainingJob.CreationTime",
	"debug_hook_config":                         "description.TrainingJob.DebugHookConfig",
	"debug_rule_configurations":                 "description.TrainingJob.DebugRuleConfigurations",
	"debug_rule_evaluation_statuses":            "description.TrainingJob.DebugRuleEvaluationStatuses",
	"enable_inter_container_traffic_encryption": "description.TrainingJob.EnableInterContainerTrafficEncryption",
	"enable_managed_spot_training":              "description.TrainingJob.EnableManagedSpotTraining",
	"enable_network_isolation":                  "description.TrainingJob.EnableNetworkIsolation",
	"environment":                               "description.TrainingJob.Environment",
	"experiment_config":                         "description.TrainingJob.ExperimentConfig",
	"failure_reason":                            "description.TrainingJob.FailureReason",
	"final_metric_data_list":                    "description.TrainingJob.FinalMetricDataList",
	"hyper_parameters":                          "description.TrainingJob.HyperParameters",
	"input_data_config":                         "description.TrainingJob.InputDataConfig",
	"og_account_id":                             "metadata.SourceID",
	"labeling_job_arn":                          "description.TrainingJob.LabelingJobArn",
	"last_modified_time":                        "description.TrainingJob.LastModifiedTime",
	"model_artifacts":                           "description.TrainingJob.ModelArtifacts",
	"name":                                      "description.TrainingJob.TrainingJobName",
	"output_data_config":                        "description.TrainingJob.OutputDataConfig",
	"profiler_config":                           "description.TrainingJob.ProfilerConfig",
	"profiler_rule_configurations":              "description.TrainingJob.ProfilerRuleConfigurations",
	"profiler_rule_evaluation_statuses":         "description.TrainingJob.ProfilerRuleEvaluationStatuses",
	"profiling_status":                          "description.TrainingJob.ProfilingStatus",
	"resource_config":                           "description.TrainingJob.ResourceConfig",
	"role_arn":                                  "description.TrainingJob.RoleArn",
	"secondary_status":                          "description.TrainingJob.SecondaryStatus",
	"secondary_status_transitions":              "description.TrainingJob.SecondaryStatusTransitions",
	"stopping_condition":                        "description.TrainingJob.StoppingCondition",
	"tags_src":                                  "description.Tags",
	"tensor_board_output_config":                "description.TrainingJob.TensorBoardOutputConfig",
	"title":                                     "description.TrainingJob.TrainingJobName",
	"training_end_time":                         "description.TrainingJob.TrainingEndTime",
	"training_job_status":                       "description.TrainingJob.TrainingJobStatus",
	"training_start_time":                       "description.TrainingJob.TrainingStartTime",
	"training_time_in_seconds":                  "description.TrainingJob.TrainingTimeInSeconds",
	"tuning_job_arn":                            "description.TrainingJob.TuningJobArn",
	"vpc_config":                                "description.TrainingJob.VpcConfig",
}

func ListSageMakerTrainingJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSageMakerTrainingJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerTrainingJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerTrainingJob NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerTrainingJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerTrainingJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerTrainingJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSageMakerTrainingJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSageMakerTrainingJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSageMakerTrainingJob NewSageMakerTrainingJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSageMakerTrainingJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSageMakerTrainingJobFilters = map[string]string{
	"algorithm_specification":                   "description.TrainingJob.AlgorithmSpecification",
	"arn":                                       "description.TrainingJob.TrainingJobArn",
	"auto_ml_job_arn":                           "description.TrainingJob.AutoMLJobArn",
	"billable_time_in_seconds":                  "description.TrainingJob.BillableTimeInSeconds",
	"checkpoint_config":                         "description.TrainingJob.CheckpointConfig",
	"creation_time":                             "description.TrainingJob.CreationTime",
	"debug_hook_config":                         "description.TrainingJob.DebugHookConfig",
	"debug_rule_configurations":                 "description.TrainingJob.DebugRuleConfigurations",
	"debug_rule_evaluation_statuses":            "description.TrainingJob.DebugRuleEvaluationStatuses",
	"enable_inter_container_traffic_encryption": "description.TrainingJob.EnableInterContainerTrafficEncryption",
	"enable_managed_spot_training":              "description.TrainingJob.EnableManagedSpotTraining",
	"enable_network_isolation":                  "description.TrainingJob.EnableNetworkIsolation",
	"environment":                               "description.TrainingJob.Environment",
	"experiment_config":                         "description.TrainingJob.ExperimentConfig",
	"failure_reason":                            "description.TrainingJob.FailureReason",
	"final_metric_data_list":                    "description.TrainingJob.FinalMetricDataList",
	"hyper_parameters":                          "description.TrainingJob.HyperParameters",
	"input_data_config":                         "description.TrainingJob.InputDataConfig",
	"og_account_id":                             "metadata.SourceID",
	"labeling_job_arn":                          "description.TrainingJob.LabelingJobArn",
	"last_modified_time":                        "description.TrainingJob.LastModifiedTime",
	"model_artifacts":                           "description.TrainingJob.ModelArtifacts",
	"name":                                      "description.TrainingJob.Name",
	"output_data_config":                        "description.TrainingJob.OutputDataConfig",
	"profiler_config":                           "description.TrainingJob.ProfilerConfig",
	"profiler_rule_configurations":              "description.TrainingJob.ProfilerRuleConfigurations",
	"profiler_rule_evaluation_statuses":         "description.TrainingJob.ProfilerRuleEvaluationStatuses",
	"profiling_status":                          "description.TrainingJob.ProfilingStatus",
	"resource_config":                           "description.TrainingJob.ResourceConfig",
	"role_arn":                                  "description.TrainingJob.RoleArn",
	"secondary_status":                          "description.TrainingJob.SecondaryStatus",
	"secondary_status_transitions":              "description.TrainingJob.SecondaryStatusTransitions",
	"stopping_condition":                        "description.TrainingJob.StoppingCondition",
	"tags_src":                                  "description.Tags",
	"tensor_board_output_config":                "description.TrainingJob.TensorBoardOutputConfig",
	"title":                                     "description.TrainingJob.TrainingJobName",
	"training_end_time":                         "description.TrainingJob.TrainingEndTime",
	"training_job_status":                       "description.TrainingJob.TrainingJobStatus",
	"training_start_time":                       "description.TrainingJob.TrainingStartTime",
	"training_time_in_seconds":                  "description.TrainingJob.TrainingTimeInSeconds",
	"tuning_job_arn":                            "description.TrainingJob.TuningJobArn",
	"vpc_config":                                "description.TrainingJob.VpcConfig",
}

func GetSageMakerTrainingJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSageMakerTrainingJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSageMakerTrainingJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSageMakerTrainingJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SageMakerTrainingJob =============================

// ==========================  START: SecretsManagerSecret =============================

type SecretsManagerSecret struct {
	Description   aws.SecretsManagerSecretDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SecretsManagerSecretHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SecretsManagerSecret `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SecretsManagerSecretHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SecretsManagerSecretHit `json:"hits"`
}

type SecretsManagerSecretSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SecretsManagerSecretHits `json:"hits"`
}

type SecretsManagerSecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecretsManagerSecretPaginator(filters []essdk.BoolFilter, limit *int64) (SecretsManagerSecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_secretsmanager_secret", filters, limit)
	if err != nil {
		return SecretsManagerSecretPaginator{}, err
	}

	p := SecretsManagerSecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecretsManagerSecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecretsManagerSecretPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecretsManagerSecretPaginator) NextPage(ctx context.Context) ([]SecretsManagerSecret, error) {
	var response SecretsManagerSecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecretsManagerSecret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecretsManagerSecretFilters = map[string]string{
	"arn":                       "description.Secret.ARN",
	"created_date":              "description.Secret.CreatedDate",
	"deleted_date":              "description.Secret.DeletedDate",
	"description":               "description.Secret.Description",
	"og_account_id":             "metadata.SourceID",
	"kms_key_id":                "description.Secret.KmsKeyId",
	"last_accessed_date":        "description.Secret.LastAccessedDate",
	"last_changed_date":         "description.Secret.LastChangedDate",
	"last_rotated_date":         "description.Secret.LastRotatedDate",
	"name":                      "description.Secret.Name",
	"owning_service":            "description.Secret.OwningService",
	"policy":                    "description.ResourcePolicy",
	"primary_region":            "description.Secret.PrimaryRegion",
	"replication_status":        "description.Secret.ReplicationStatus",
	"rotation_enabled":          "description.Secret.RotationEnabled",
	"rotation_lambda_arn":       "description.Secret.RotationLambdaARN",
	"rotation_rules":            "description.Secret.RotationRules",
	"secret_versions_to_stages": "description.Secret.VersionIdsToStages",
	"tags_src":                  "description.Secret.Tags",
	"title":                     "description.Secret.Name",
}

func ListSecretsManagerSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecretsManagerSecret")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecretsManagerSecret NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecretsManagerSecret NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecretsManagerSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecretsManagerSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecretsManagerSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecretsManagerSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecretsManagerSecretFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecretsManagerSecret NewSecretsManagerSecretPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecretsManagerSecret paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecretsManagerSecretFilters = map[string]string{
	"arn":                       "description.Secret.ARN",
	"created_date":              "description.Secret.CreatedDate",
	"deleted_date":              "description.Secret.DeletedDate",
	"description":               "description.Secret.Description",
	"og_account_id":             "metadata.SourceID",
	"kms_key_id":                "description.Secret.KmsKeyId",
	"last_accessed_date":        "description.Secret.LastAccessedDate",
	"last_changed_date":         "description.Secret.LastChangedDate",
	"last_rotated_date":         "description.Secret.LastRotatedDate",
	"name":                      "description.Secret.Name",
	"owning_service":            "description.Secret.OwningService",
	"policy":                    "description.ResourcePolicy",
	"primary_region":            "description.Secret.PrimaryRegion",
	"replication_status":        "description.Secret.ReplicationStatus",
	"rotation_enabled":          "description.Secret.RotationEnabled",
	"rotation_lambda_arn":       "description.Secret.RotationLambdaARN",
	"rotation_rules":            "description.Secret.RotationRules",
	"secret_versions_to_stages": "description.Secret.VersionIdsToStages",
	"tags_src":                  "description.Secret.Tags",
	"title":                     "description.Secret.Name",
}

func GetSecretsManagerSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecretsManagerSecret")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecretsManagerSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecretsManagerSecretFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecretsManagerSecret =============================

// ==========================  START: SecurityHubHub =============================

type SecurityHubHub struct {
	Description   aws.SecurityHubHubDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type SecurityHubHubHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SecurityHubHub `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SecurityHubHubHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SecurityHubHubHit `json:"hits"`
}

type SecurityHubHubSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SecurityHubHubHits `json:"hits"`
}

type SecurityHubHubPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubHubPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubHubPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_hub", filters, limit)
	if err != nil {
		return SecurityHubHubPaginator{}, err
	}

	p := SecurityHubHubPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubHubPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubHubPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubHubPaginator) NextPage(ctx context.Context) ([]SecurityHubHub, error) {
	var response SecurityHubHubSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubHub
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubHubFilters = map[string]string{
	"administrator_account": "description.AdministratorAccount",
	"auto_enable_controls":  "description.Hub.AutoEnableControls",
	"hub_arn":               "description.Hub.HubArn",
	"og_account_id":         "metadata.SourceID",
	"subscribed_at":         "description.Hub.SubscribedAt",
	"tags":                  "description.Tags",
}

func ListSecurityHubHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubHub")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubHub NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubHub NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubHub GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubHub GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubHub GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubHubPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubHubFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubHub NewSecurityHubHubPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubHub paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubHubFilters = map[string]string{
	"administrator_account": "description.AdministratorAccount",
	"auto_enable_controls":  "description.Hub.AutoEnableControls",
	"hub_arn":               "description.Hub.HubArn",
	"og_account_id":         "metadata.SourceID",
	"subscribed_at":         "description.Hub.SubscribedAt",
	"tags":                  "description.Tags",
}

func GetSecurityHubHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubHub")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubHubPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubHubFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubHub =============================

// ==========================  START: SecurityHubActionTarget =============================

type SecurityHubActionTarget struct {
	Description   aws.SecurityHubActionTargetDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type SecurityHubActionTargetHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  SecurityHubActionTarget `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type SecurityHubActionTargetHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []SecurityHubActionTargetHit `json:"hits"`
}

type SecurityHubActionTargetSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  SecurityHubActionTargetHits `json:"hits"`
}

type SecurityHubActionTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubActionTargetPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubActionTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_actiontarget", filters, limit)
	if err != nil {
		return SecurityHubActionTargetPaginator{}, err
	}

	p := SecurityHubActionTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubActionTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubActionTargetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubActionTargetPaginator) NextPage(ctx context.Context) ([]SecurityHubActionTarget, error) {
	var response SecurityHubActionTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubActionTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubActionTargetFilters = map[string]string{
	"arn":           "description.ActionTarget.ActionTargetArn",
	"description":   "description.ActionTarget.Description",
	"og_account_id": "metadata.SourceID",
	"name":          "description.ActionTarget.Name",
	"title":         "description.ActionTarget.Name",
}

func ListSecurityHubActionTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubActionTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubActionTarget NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubActionTarget NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubActionTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubActionTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubActionTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubActionTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubActionTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubActionTarget NewSecurityHubActionTargetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubActionTarget paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubActionTargetFilters = map[string]string{
	"arn":           "description.ActionTarget.ActionTargetArn",
	"description":   "description.ActionTarget.Description",
	"og_account_id": "metadata.SourceID",
	"name":          "description.ActionTarget.Name",
	"title":         "description.ActionTarget.Name",
}

func GetSecurityHubActionTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubActionTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubActionTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubActionTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubActionTarget =============================

// ==========================  START: SecurityHubFinding =============================

type SecurityHubFinding struct {
	Description   aws.SecurityHubFindingDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SecurityHubFindingHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SecurityHubFinding `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SecurityHubFindingHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SecurityHubFindingHit `json:"hits"`
}

type SecurityHubFindingSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SecurityHubFindingHits `json:"hits"`
}

type SecurityHubFindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubFindingPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubFindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_finding", filters, limit)
	if err != nil {
		return SecurityHubFindingPaginator{}, err
	}

	p := SecurityHubFindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubFindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubFindingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubFindingPaginator) NextPage(ctx context.Context) ([]SecurityHubFinding, error) {
	var response SecurityHubFindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubFinding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubFindingFilters = map[string]string{
	"action":                  "description.Finding.Action",
	"arn":                     "description.Finding.Id",
	"company_name":            "description.Finding.CompanyName",
	"compliance":              "description.Finding.Compliance",
	"compliance_status":       "description.Finding.Compliance.Status",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"criticality":             "description.Finding.Criticality",
	"description":             "description.Finding.Description",
	"finding_provider_fields": "description.Finding.FindingProviderFields",
	"first_observed_at":       "description.Finding.FirstObservedAt",
	"generator_id":            "description.Finding.GeneratorId",
	"id":                      "description.Finding.Id",
	"og_account_id":           "metadata.SourceID",
	"last_observed_at":        "description.Finding.LastObservedAt",
	"malware":                 "description.Finding.Malware",
	"network":                 "description.Finding.Network",
	"network_path":            "description.Finding.NetworkPath",
	"note":                    "description.Finding.Note",
	"patch_summary":           "description.Finding.PatchSummary",
	"process":                 "description.Finding.Process",
	"product_arn":             "description.Finding.ProductArn",
	"product_fields":          "description.Finding.ProductFields",
	"product_name":            "description.Finding.ProductName",
	"record_state":            "description.Finding.RecordState",
	"related_findings":        "description.Finding.RelatedFindings",
	"remediation":             "description.Finding.Remediation",
	"resources":               "description.Finding.Resources",
	"schema_version":          "description.Finding.SchemaVersion",
	"severity":                "description.Finding.Severity",
	"source_url":              "description.Finding.SourceUrl",
	"threat_intel_indicators": "description.Finding.ThreatIntelIndicators",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_defined_fields":     "description.Finding.UserDefinedFields",
	"verification_state":      "description.Finding.VerificationState",
	"vulnerabilities":         "description.Finding.Vulnerabilities",
	"workflow_state":          "description.Finding.WorkflowState",
	"workflow_status":         "description.Finding.Workflow.Status",
}

func ListSecurityHubFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFinding NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFinding NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFinding NewSecurityHubFindingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubFinding paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubFindingFilters = map[string]string{
	"action":                  "description.Finding.Action",
	"arn":                     "description.Finding.Id",
	"company_name":            "description.Finding.CompanyName",
	"compliance":              "description.Finding.Compliance",
	"compliance_status":       "description.Finding.Compliance.Status",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"criticality":             "description.Finding.Criticality",
	"description":             "description.Finding.Description",
	"finding_provider_fields": "description.Finding.FindingProviderFields",
	"first_observed_at":       "description.Finding.FirstObservedAt",
	"generator_id":            "description.Finding.GeneratorId",
	"id":                      "description.Finding.Id",
	"og_account_id":           "metadata.SourceID",
	"last_observed_at":        "description.Finding.LastObservedAt",
	"malware":                 "description.Finding.Malware",
	"network":                 "description.Finding.Network",
	"network_path":            "description.Finding.NetworkPath",
	"note":                    "description.Finding.Note",
	"patch_summary":           "description.Finding.PatchSummary",
	"process":                 "description.Finding.Process",
	"product_arn":             "description.Finding.ProductArn",
	"product_fields":          "description.Finding.ProductFields",
	"product_name":            "description.Finding.ProductName",
	"record_state":            "description.Finding.RecordState",
	"related_findings":        "description.Finding.RelatedFindings",
	"remediation":             "description.Finding.Remediation",
	"resources":               "description.Finding.Resources",
	"schema_version":          "description.Finding.SchemaVersion",
	"severity":                "description.Finding.Severity",
	"source_url":              "description.Finding.SourceUrl",
	"threat_intel_indicators": "description.Finding.ThreatIntelIndicators",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_defined_fields":     "description.Finding.UserDefinedFields",
	"verification_state":      "description.Finding.VerificationState",
	"vulnerabilities":         "description.Finding.Vulnerabilities",
	"workflow_state":          "description.Finding.WorkflowState",
	"workflow_status":         "description.Finding.Workflow.Status",
}

func GetSecurityHubFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubFinding =============================

// ==========================  START: SecurityHubFindingAggregator =============================

type SecurityHubFindingAggregator struct {
	Description   aws.SecurityHubFindingAggregatorDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type SecurityHubFindingAggregatorHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SecurityHubFindingAggregator `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SecurityHubFindingAggregatorHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SecurityHubFindingAggregatorHit `json:"hits"`
}

type SecurityHubFindingAggregatorSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SecurityHubFindingAggregatorHits `json:"hits"`
}

type SecurityHubFindingAggregatorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubFindingAggregatorPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubFindingAggregatorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_findingaggregator", filters, limit)
	if err != nil {
		return SecurityHubFindingAggregatorPaginator{}, err
	}

	p := SecurityHubFindingAggregatorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubFindingAggregatorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubFindingAggregatorPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubFindingAggregatorPaginator) NextPage(ctx context.Context) ([]SecurityHubFindingAggregator, error) {
	var response SecurityHubFindingAggregatorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubFindingAggregator
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubFindingAggregatorFilters = map[string]string{
	"arn":                        "description.FindingAggregator.FindingAggregatorArn",
	"finding_aggregation_region": "description.FindingAggregator.FindingAggregationRegion",
	"og_account_id":              "metadata.SourceID",
	"region_linking_mode":        "description.FindingAggregator.RegionLinkingMode",
	"regions":                    "description.FindingAggregator.Regions",
}

func ListSecurityHubFindingAggregator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubFindingAggregator")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFindingAggregator NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFindingAggregator NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFindingAggregator GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFindingAggregator GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFindingAggregator GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubFindingAggregatorPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubFindingAggregatorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubFindingAggregator NewSecurityHubFindingAggregatorPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubFindingAggregator paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubFindingAggregatorFilters = map[string]string{
	"arn":                        "description.FindingAggregator.FindingAggregatorArn",
	"finding_aggregation_region": "description.FindingAggregator.FindingAggregationRegion",
	"og_account_id":              "metadata.SourceID",
	"region_linking_mode":        "description.FindingAggregator.RegionLinkingMode",
	"regions":                    "description.FindingAggregator.Regions",
}

func GetSecurityHubFindingAggregator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubFindingAggregator")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubFindingAggregatorPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubFindingAggregatorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubFindingAggregator =============================

// ==========================  START: SecurityHubInsight =============================

type SecurityHubInsight struct {
	Description   aws.SecurityHubInsightDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SecurityHubInsightHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SecurityHubInsight `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SecurityHubInsightHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SecurityHubInsightHit `json:"hits"`
}

type SecurityHubInsightSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SecurityHubInsightHits `json:"hits"`
}

type SecurityHubInsightPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubInsightPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubInsightPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_insight", filters, limit)
	if err != nil {
		return SecurityHubInsightPaginator{}, err
	}

	p := SecurityHubInsightPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubInsightPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubInsightPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubInsightPaginator) NextPage(ctx context.Context) ([]SecurityHubInsight, error) {
	var response SecurityHubInsightSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubInsight
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubInsightFilters = map[string]string{
	"arn":                "description.Insight.InsightArn",
	"filters":            "description.Insight.Filters",
	"group_by_attribute": "description.Insight.GroupByAttribute",
	"og_account_id":      "metadata.SourceID",
	"name":               "description.Insight.Name",
	"title":              "description.Insight.Name",
}

func ListSecurityHubInsight(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubInsight")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubInsight NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubInsight NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubInsight GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubInsight GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubInsight GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubInsightPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubInsightFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubInsight NewSecurityHubInsightPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubInsight paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubInsightFilters = map[string]string{
	"arn":                "description.Insight.InsightArn",
	"filters":            "description.Insight.Filters",
	"group_by_attribute": "description.Insight.GroupByAttribute",
	"og_account_id":      "metadata.SourceID",
	"name":               "description.Insight.Name",
	"title":              "description.Insight.Name",
}

func GetSecurityHubInsight(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubInsight")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubInsightPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubInsightFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubInsight =============================

// ==========================  START: SecurityHubMember =============================

type SecurityHubMember struct {
	Description   aws.SecurityHubMemberDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type SecurityHubMemberHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  SecurityHubMember `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type SecurityHubMemberHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []SecurityHubMemberHit `json:"hits"`
}

type SecurityHubMemberSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  SecurityHubMemberHits `json:"hits"`
}

type SecurityHubMemberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubMemberPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubMemberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_member", filters, limit)
	if err != nil {
		return SecurityHubMemberPaginator{}, err
	}

	p := SecurityHubMemberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubMemberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubMemberPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubMemberPaginator) NextPage(ctx context.Context) ([]SecurityHubMember, error) {
	var response SecurityHubMemberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubMember
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubMemberFilters = map[string]string{
	"administrator_id":  "description.Member.AdministratorId",
	"email":             "description.Member.Email",
	"invited_at":        "description.Member.InvitedAt",
	"og_account_id":     "metadata.SourceID",
	"master_id":         "description.Member.MasterId",
	"member_account_id": "description.Member.AccountId",
	"member_status":     "description.Member.MemberStatus",
	"title":             "description.Member.AccountId",
	"updated_at":        "description.Member.UpdatedAt",
}

func ListSecurityHubMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubMember")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubMember NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubMember NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubMemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubMemberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubMember NewSecurityHubMemberPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubMember paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubMemberFilters = map[string]string{
	"administrator_id":  "description.Member.AdministratorId",
	"email":             "description.Member.Email",
	"invited_at":        "description.Member.InvitedAt",
	"og_account_id":     "metadata.SourceID",
	"master_id":         "description.Member.MasterId",
	"member_account_id": "description.Member.AccountId",
	"member_status":     "description.Member.MemberStatus",
	"title":             "description.Member.AccountId",
	"updated_at":        "description.Member.UpdatedAt",
}

func GetSecurityHubMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubMember")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubMemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubMemberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubMember =============================

// ==========================  START: SecurityHubProduct =============================

type SecurityHubProduct struct {
	Description   aws.SecurityHubProductDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SecurityHubProductHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SecurityHubProduct `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SecurityHubProductHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SecurityHubProductHit `json:"hits"`
}

type SecurityHubProductSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SecurityHubProductHits `json:"hits"`
}

type SecurityHubProductPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubProductPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubProductPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_product", filters, limit)
	if err != nil {
		return SecurityHubProductPaginator{}, err
	}

	p := SecurityHubProductPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubProductPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubProductPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubProductPaginator) NextPage(ctx context.Context) ([]SecurityHubProduct, error) {
	var response SecurityHubProductSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubProduct
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubProductFilters = map[string]string{
	"activation_url":                       "description.Product.ActivationUrl",
	"categories":                           "description.Product.Categories",
	"company_name":                         "description.Product.CompanyName",
	"description":                          "description.Product.Description",
	"integration_types":                    "description.Product.IntegrationTypes",
	"og_account_id":                        "metadata.SourceID",
	"marketplace_url":                      "description.Product.MarketplaceUrl",
	"name":                                 "description.Product.ProductName",
	"product_arn":                          "description.Product.ProductArn",
	"product_subscription_resource_policy": "description.Product.ProductSubscriptionResourcePolicy",
	"title":                                "description.Product.ProductName",
}

func ListSecurityHubProduct(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubProduct")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubProduct NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubProduct NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubProduct GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubProduct GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubProduct GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubProductPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubProductFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubProduct NewSecurityHubProductPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubProduct paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubProductFilters = map[string]string{
	"activation_url":                       "description.Product.ActivationUrl",
	"categories":                           "description.Product.Categories",
	"company_name":                         "description.Product.CompanyName",
	"description":                          "description.Product.Description",
	"integration_types":                    "description.Product.IntegrationTypes",
	"og_account_id":                        "metadata.SourceID",
	"marketplace_url":                      "description.Product.MarketplaceUrl",
	"name":                                 "description.Product.ProductName",
	"product_arn":                          "description.Product.ProductArn",
	"product_subscription_resource_policy": "description.Product.ProductSubscriptionResourcePolicy",
	"title":                                "description.Product.ProductName",
}

func GetSecurityHubProduct(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubProduct")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubProductPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubProductFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubProduct =============================

// ==========================  START: SecurityHubStandardsControl =============================

type SecurityHubStandardsControl struct {
	Description   aws.SecurityHubStandardsControlDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type SecurityHubStandardsControlHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  SecurityHubStandardsControl `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type SecurityHubStandardsControlHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []SecurityHubStandardsControlHit `json:"hits"`
}

type SecurityHubStandardsControlSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  SecurityHubStandardsControlHits `json:"hits"`
}

type SecurityHubStandardsControlPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubStandardsControlPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubStandardsControlPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_standardscontrol", filters, limit)
	if err != nil {
		return SecurityHubStandardsControlPaginator{}, err
	}

	p := SecurityHubStandardsControlPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubStandardsControlPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubStandardsControlPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubStandardsControlPaginator) NextPage(ctx context.Context) ([]SecurityHubStandardsControl, error) {
	var response SecurityHubStandardsControlSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubStandardsControl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubStandardsControlFilters = map[string]string{
	"arn":                       "description.StandardsControl.StandardsControlArn",
	"control_id":                "description.StandardsControl.ControlId",
	"control_status":            "description.StandardsControl.ControlStatus",
	"control_status_updated_at": "description.StandardsControl.ControlStatusUpdatedAt",
	"description":               "description.StandardsControl.Description",
	"disabled_reason":           "description.StandardsControl.DisabledReason",
	"og_account_id":             "metadata.SourceID",
	"related_requirements":      "description.StandardsControl.RelatedRequirements",
	"remediation_url":           "description.StandardsControl.RemediationUrl",
	"severity_rating":           "description.StandardsControl.SeverityRating",
	"title":                     "description.StandardsControl.Title",
}

func ListSecurityHubStandardsControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubStandardsControl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsControl NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsControl NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubStandardsControlPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubStandardsControlFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsControl NewSecurityHubStandardsControlPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubStandardsControl paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubStandardsControlFilters = map[string]string{
	"arn":                       "description.StandardsControl.StandardsControlArn",
	"control_id":                "description.StandardsControl.ControlId",
	"control_status":            "description.StandardsControl.ControlStatus",
	"control_status_updated_at": "description.StandardsControl.ControlStatusUpdatedAt",
	"description":               "description.StandardsControl.Description",
	"disabled_reason":           "description.StandardsControl.DisabledReason",
	"og_account_id":             "metadata.SourceID",
	"related_requirements":      "description.StandardsControl.RelatedRequirements",
	"remediation_url":           "description.StandardsControl.RemediationUrl",
	"severity_rating":           "description.StandardsControl.SeverityRating",
	"title":                     "description.StandardsControl.Title",
}

func GetSecurityHubStandardsControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubStandardsControl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubStandardsControlPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubStandardsControlFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubStandardsControl =============================

// ==========================  START: SecurityHubStandardsSubscription =============================

type SecurityHubStandardsSubscription struct {
	Description   aws.SecurityHubStandardsSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                                    `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type SecurityHubStandardsSubscriptionHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  SecurityHubStandardsSubscription `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type SecurityHubStandardsSubscriptionHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []SecurityHubStandardsSubscriptionHit `json:"hits"`
}

type SecurityHubStandardsSubscriptionSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  SecurityHubStandardsSubscriptionHits `json:"hits"`
}

type SecurityHubStandardsSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityHubStandardsSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityHubStandardsSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securityhub_standardssubscription", filters, limit)
	if err != nil {
		return SecurityHubStandardsSubscriptionPaginator{}, err
	}

	p := SecurityHubStandardsSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityHubStandardsSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityHubStandardsSubscriptionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityHubStandardsSubscriptionPaginator) NextPage(ctx context.Context) ([]SecurityHubStandardsSubscription, error) {
	var response SecurityHubStandardsSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityHubStandardsSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityHubStandardsSubscriptionFilters = map[string]string{
	"description":                  "description.Standard.Description",
	"enabled_by_default":           "description.Standard.EnabledByDefault",
	"og_account_id":                "metadata.SourceID",
	"name":                         "description.Standard.Name",
	"standards_arn":                "description.Standard.StandardsArn",
	"standards_input":              "description.StandardsSubscription.StandardsInput",
	"standards_managed_by":         "description.Standard.StandardsManagedBy",
	"standards_status":             "description.StandardsSubscription.StandardsStatus",
	"standards_status_reason_code": "description.StandardsSubscription.StandardsStatusReason.StatusReasonCode",
	"standards_subscription_arn":   "description.StandardsSubscription.StandardsSubscriptionArn",
	"title":                        "description.Standard.Name",
}

func ListSecurityHubStandardsSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityHubStandardsSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsSubscription NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsSubscription NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityHubStandardsSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityHubStandardsSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityHubStandardsSubscription NewSecurityHubStandardsSubscriptionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityHubStandardsSubscription paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityHubStandardsSubscriptionFilters = map[string]string{
	"description":                  "description.Standard.Description",
	"enabled_by_default":           "description.Standard.EnabledByDefault",
	"og_account_id":                "metadata.SourceID",
	"name":                         "description.Standard.Name",
	"standards_arn":                "description.Standard.StandardsArn",
	"standards_input":              "description.StandardsSubscription.StandardsInput",
	"standards_managed_by":         "description.Standard.StandardsManagedBy",
	"standards_status":             "description.StandardsSubscription.StandardsStatus",
	"standards_status_reason_code": "description.StandardsSubscription.StandardsStatusReason.StatusReasonCode",
	"standards_subscription_arn":   "description.StandardsSubscription.StandardsSubscriptionArn",
	"title":                        "description.Standard.Name",
}

func GetSecurityHubStandardsSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityHubStandardsSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityHubStandardsSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityHubStandardsSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityHubStandardsSubscription =============================

// ==========================  START: SSMManagedInstance =============================

type SSMManagedInstance struct {
	Description   aws.SSMManagedInstanceDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SSMManagedInstanceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SSMManagedInstance `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SSMManagedInstanceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SSMManagedInstanceHit `json:"hits"`
}

type SSMManagedInstanceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SSMManagedInstanceHits `json:"hits"`
}

type SSMManagedInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMManagedInstancePaginator(filters []essdk.BoolFilter, limit *int64) (SSMManagedInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_managedinstance", filters, limit)
	if err != nil {
		return SSMManagedInstancePaginator{}, err
	}

	p := SSMManagedInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMManagedInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMManagedInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMManagedInstancePaginator) NextPage(ctx context.Context) ([]SSMManagedInstance, error) {
	var response SSMManagedInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMManagedInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMManagedInstanceFilters = map[string]string{
	"activation_id":                   "description.InstanceInformation.ActivationId",
	"agent_version":                   "description.InstanceInformation.AgentVersion",
	"arn":                             "arn",
	"association_overview":            "description.InstanceInformation.AssociationOverview",
	"association_status":              "description.InstanceInformation.AssociationStatus",
	"computer_name":                   "description.InstanceInformation.ComputerName",
	"instance_id":                     "description.InstanceInformation.InstanceId",
	"ip_address":                      "description.InstanceInformation.IPAddress",
	"is_latest_version":               "description.InstanceInformation.IsLatestVersion",
	"og_account_id":                   "metadata.SourceID",
	"last_association_execution_date": "description.InstanceInformation.LastAssociationExecutionDate",
	"last_ping_date_time":             "description.InstanceInformation.LastPingDateTime",
	"last_successful_association_execution_date": "description.InstanceInformation.LastSuccessfulAssociationExecutionDate",
	"name":              "description.InstanceInformation.Name",
	"ping_status":       "description.InstanceInformation.PingStatus",
	"platform_name":     "description.InstanceInformation.PlatformName",
	"platform_type":     "description.InstanceInformation.PlatformType",
	"platform_version":  "description.InstanceInformation.PlatformVersion",
	"registration_date": "description.InstanceInformation.RegistrationDate",
	"resource_type":     "description.InstanceInformation.ResourceType",
	"title":             "description.InstanceInformation.InstanceId",
}

func ListSSMManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMManagedInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMManagedInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMManagedInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstance NewSSMManagedInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMManagedInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMManagedInstanceFilters = map[string]string{
	"activation_id":                   "description.InstanceInformation.ActivationId",
	"agent_version":                   "description.InstanceInformation.AgentVersion",
	"arn":                             "arn",
	"association_overview":            "description.InstanceInformation.AssociationOverview",
	"association_status":              "description.InstanceInformation.AssociationStatus",
	"computer_name":                   "description.InstanceInformation.ComputerName",
	"instance_id":                     "description.InstanceInformation.InstanceId",
	"ip_address":                      "description.InstanceInformation.IPAddress",
	"is_latest_version":               "description.InstanceInformation.IsLatestVersion",
	"og_account_id":                   "metadata.SourceID",
	"last_association_execution_date": "description.InstanceInformation.LastAssociationExecutionDate",
	"last_ping_date_time":             "description.InstanceInformation.LastPingDateTime",
	"last_successful_association_execution_date": "description.InstanceInformation.LastSuccessfulAssociationExecutionDate",
	"name":              "description.InstanceInformation.Name",
	"ping_status":       "description.InstanceInformation.PingStatus",
	"platform_name":     "description.InstanceInformation.PlatformName",
	"platform_type":     "description.InstanceInformation.PlatformType",
	"platform_version":  "description.InstanceInformation.PlatformVersion",
	"registration_date": "description.InstanceInformation.RegistrationDate",
	"resource_type":     "description.InstanceInformation.ResourceType",
	"title":             "description.InstanceInformation.InstanceId",
}

func GetSSMManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMManagedInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMManagedInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMManagedInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMManagedInstance =============================

// ==========================  START: SSMAssociation =============================

type SSMAssociation struct {
	Description   aws.SSMAssociationDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type SSMAssociationHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SSMAssociation `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SSMAssociationHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SSMAssociationHit `json:"hits"`
}

type SSMAssociationSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SSMAssociationHits `json:"hits"`
}

type SSMAssociationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMAssociationPaginator(filters []essdk.BoolFilter, limit *int64) (SSMAssociationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_association", filters, limit)
	if err != nil {
		return SSMAssociationPaginator{}, err
	}

	p := SSMAssociationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMAssociationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMAssociationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMAssociationPaginator) NextPage(ctx context.Context) ([]SSMAssociation, error) {
	var response SSMAssociationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMAssociation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMAssociationFilters = map[string]string{
	"apply_only_at_cron_interval":      "description.Association.AssociationDescription.ApplyOnlyAtCronInterval",
	"arn":                              "arn",
	"association_id":                   "description.AssociationItem.AssociationId",
	"association_name":                 "description.AssociationItem.AssociationName",
	"association_version":              "description.AssociationItem.AssociationVersion",
	"automation_target_parameter_name": "description.Association.AssociationDescription.AutomationTargetParameterName",
	"compliance_severity":              "description.Association.AssociationDescription.ComplianceSeverity",
	"date":                             "description.AssociationItem.LastExecutionDate",
	"document_name":                    "description.AssociationItem.Name",
	"document_version":                 "description.AssociationItem.DocumentVersion",
	"instance_id":                      "description.AssociationItem.InstanceId",
	"og_account_id":                    "metadata.SourceID",
	"last_execution_date":              "description.Association.AssociationDescription.LastExecutionDate",
	"last_successful_execution_date":   "description.Association.AssociationDescription.LastSuccessfulExecutionDate",
	"last_update_association_date":     "description.Association.AssociationDescription.LastUpdateAssociationDate",
	"max_concurrency":                  "description.Association.AssociationDescription.MaxConcurrency",
	"max_errors":                       "description.Association.AssociationDescription.MaxErrors",
	"output_location":                  "description.Association.AssociationDescription.OutputLocation",
	"overview":                         "description.AssociationItem.Overview",
	"parameters":                       "description.Association.AssociationDescription.Parameters",
	"schedule_expression":              "description.AssociationItem.ScheduleExpression",
	"status":                           "description.Association.AssociationDescription.Status",
	"sync_compliance":                  "description.Association.AssociationDescription.SyncCompliance",
	"target_locations":                 "description.Association.AssociationDescription.TargetLocations",
	"targets":                          "description.AssociationItem.Targets",
	"title":                            "description.AssociationItem.Name",
}

func ListSSMAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMAssociation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMAssociation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMAssociation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMAssociationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMAssociationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMAssociation NewSSMAssociationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMAssociation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMAssociationFilters = map[string]string{
	"apply_only_at_cron_interval":      "description.Association.AssociationDescription.ApplyOnlyAtCronInterval",
	"arn":                              "arn",
	"association_id":                   "description.AssociationItem.AssociationId",
	"association_name":                 "description.AssociationItem.AssociationName",
	"association_version":              "description.AssociationItem.AssociationVersion",
	"automation_target_parameter_name": "description.Association.AssociationDescription.AutomationTargetParameterName",
	"compliance_severity":              "description.Association.AssociationDescription.ComplianceSeverity",
	"date":                             "description.AssociationItem.LastExecutionDate",
	"document_name":                    "description.AssociationItem.Name",
	"document_version":                 "description.AssociationItem.DocumentVersion",
	"instance_id":                      "description.AssociationItem.InstanceId",
	"og_account_id":                    "metadata.SourceID",
	"last_execution_date":              "description.AssociationItem.LastExecutionDate",
	"last_successful_execution_date":   "description.Association.AssociationDescription.LastSuccessfulExecutionDate",
	"last_update_association_date":     "description.Association.AssociationDescription.LastUpdateAssociationDate",
	"max_concurrency":                  "description.Association.AssociationDescription.MaxConcurrency",
	"max_errors":                       "description.Association.AssociationDescription.MaxErrors",
	"output_location":                  "description.Association.AssociationDescription.OutputLocation",
	"overview":                         "description.AssociationItem.Overview",
	"parameters":                       "description.Association.AssociationDescription.Parameters",
	"schedule_expression":              "description.AssociationItem.ScheduleExpression",
	"status":                           "description.AssociationItem.Overview.Status",
	"sync_compliance":                  "description.Association.AssociationDescription.SyncCompliance",
	"target_locations":                 "description.Association.AssociationDescription.TargetLocations",
	"targets":                          "description.AssociationItem.Targets",
	"title":                            "description.AssociationItem.Name",
}

func GetSSMAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMAssociation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMAssociationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMAssociationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMAssociation =============================

// ==========================  START: SSMDocument =============================

type SSMDocument struct {
	Description   aws.SSMDocumentDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type SSMDocumentHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SSMDocument   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SSMDocumentHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SSMDocumentHit  `json:"hits"`
}

type SSMDocumentSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SSMDocumentHits `json:"hits"`
}

type SSMDocumentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMDocumentPaginator(filters []essdk.BoolFilter, limit *int64) (SSMDocumentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_document", filters, limit)
	if err != nil {
		return SSMDocumentPaginator{}, err
	}

	p := SSMDocumentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMDocumentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMDocumentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMDocumentPaginator) NextPage(ctx context.Context) ([]SSMDocument, error) {
	var response SSMDocumentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMDocument
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMDocumentFilters = map[string]string{
	"account_ids":               "description.Permissions.AccountIds",
	"account_sharing_info_list": "description.Permissions.AccountSharingInfoList",
	"approved_version":          "description.Document.Document.ApprovedVersion",
	"arn":                       "arn",
	"attachments_information":   "description.Document.Document.AttachmentsInformation",
	"author":                    "description.Document.Document.Author",
	"created_date":              "description.Document.Document.CreatedDate",
	"default_version":           "description.Document.Document.DefaultVersion",
	"description":               "description.Document.Document.Description",
	"document_format":           "description.DocumentIdentifier.DocumentFormat",
	"document_type":             "description.DocumentIdentifier.DocumentType",
	"document_version":          "description.DocumentIdentifier.DocumentVersion",
	"hash":                      "description.Document.Document.Hash",
	"hash_type":                 "description.Document.Document.HashType",
	"og_account_id":             "metadata.SourceID",
	"latest_version":            "description.Document.Document.LatestVersion",
	"name":                      "description.Document.Document.Name",
	"owner":                     "description.Document.Document.Owner",
	"owner_type":                "description.DocumentIdentifier.Owner",
	"parameters":                "description.Document.Document.Parameters",
	"pending_review_version":    "description.Document.Document.PendingReviewVersion",
	"platform_types":            "description.Document.Document.PlatformTypes",
	"requires":                  "description.DocumentIdentifier.Requires",
	"review_information":        "description.Document.Document.ReviewInformation",
	"review_status":             "description.DocumentIdentifier.ReviewStatus",
	"schema_version":            "description.Document.Document.SchemaVersion",
	"sha1":                      "description.Document.Document.Sha1",
	"status":                    "description.Document.Document.Status",
	"status_information":        "description.Document.Document.StatusInformation",
	"tags_src":                  "description.Document.Document.Tags",
	"target_type":               "description.Document.Document.TargetType",
	"title":                     "description.Document.Document.Name",
	"version_name":              "description.Document.Document.VersionName",
}

func ListSSMDocument(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMDocument")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocument NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocument NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocument GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocument GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocument GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMDocumentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMDocumentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocument NewSSMDocumentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMDocument paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMDocumentFilters = map[string]string{
	"account_ids":               "description.Permissions.AccountIds",
	"account_sharing_info_list": "description.Permissions.AccountSharingInfoList",
	"approved_version":          "description.Document.Document.ApprovedVersion",
	"arn":                       "arn",
	"attachments_information":   "description.Document.Document.AttachmentsInformation",
	"author":                    "description.Document.Document.Author",
	"created_date":              "description.Document.Document.CreatedDate",
	"default_version":           "description.Document.Document.DefaultVersion",
	"description":               "description.Document.Document.Description",
	"document_format":           "description.DocumentIdentifier.DocumentFormat",
	"document_type":             "description.Document.Document.DocumentType",
	"document_version":          "description.DocumentIdentifier.DocumentVersion",
	"hash":                      "description.Document.Document.Hash",
	"hash_type":                 "description.Document.Document.HashType",
	"og_account_id":             "metadata.SourceID",
	"latest_version":            "description.Document.Document.LatestVersion",
	"name":                      "description.DocumentIdentifier.Name",
	"owner":                     "description.Document.Document.Owner",
	"parameters":                "description.Document.Document.Parameters",
	"pending_review_version":    "description.Document.Document.PendingReviewVersion",
	"platform_types":            "description.Document.Document.PlatformTypes",
	"requires":                  "description.DocumentIdentifier.Requires",
	"review_information":        "description.Document.Document.ReviewInformation",
	"review_status":             "description.DocumentIdentifier.ReviewStatus",
	"schema_version":            "description.Document.Document.SchemaVersion",
	"sha1":                      "description.Document.Document.Sha1",
	"status":                    "description.Document.Document.Status",
	"status_information":        "description.Document.Document.StatusInformation",
	"tags_src":                  "description.Document.Document.Tags",
	"target_type":               "description.Document.Document.TargetType",
	"title":                     "description.Document.Document.Name",
	"version_name":              "description.Document.Document.VersionName",
}

func GetSSMDocument(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMDocument")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMDocumentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMDocumentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMDocument =============================

// ==========================  START: SSMDocumentPermission =============================

type SSMDocumentPermission struct {
	Description   aws.SSMDocumentPermissionDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type SSMDocumentPermissionHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  SSMDocumentPermission `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type SSMDocumentPermissionHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []SSMDocumentPermissionHit `json:"hits"`
}

type SSMDocumentPermissionSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  SSMDocumentPermissionHits `json:"hits"`
}

type SSMDocumentPermissionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMDocumentPermissionPaginator(filters []essdk.BoolFilter, limit *int64) (SSMDocumentPermissionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_documentpermission", filters, limit)
	if err != nil {
		return SSMDocumentPermissionPaginator{}, err
	}

	p := SSMDocumentPermissionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMDocumentPermissionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMDocumentPermissionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMDocumentPermissionPaginator) NextPage(ctx context.Context) ([]SSMDocumentPermission, error) {
	var response SSMDocumentPermissionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMDocumentPermission
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMDocumentPermissionFilters = map[string]string{
	"account_ids":             "description.Permissions.AccountIds",
	"document_name":           "description.Document.Document.Name",
	"og_account_id":           "metadata.SourceID",
	"shared_account_id":       "description.Permissions.AccountSharingInfoList.AccountId",
	"shared_document_version": "description.Permissions.AccountSharingInfoList.SharedDocumentVersion",
	"title":                   "description.Permissions.AccountSharingInfoList.SharedDocumentVersion",
}

func ListSSMDocumentPermission(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMDocumentPermission")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocumentPermission NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocumentPermission NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocumentPermission GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocumentPermission GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocumentPermission GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMDocumentPermissionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMDocumentPermissionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMDocumentPermission NewSSMDocumentPermissionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMDocumentPermission paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMDocumentPermissionFilters = map[string]string{
	"account_ids":             "description.Permissions.AccountIds",
	"document_name":           "description.Document.Document.Name",
	"og_account_id":           "metadata.SourceID",
	"shared_account_id":       "description.Permissions.AccountSharingInfoList.AccountId",
	"shared_document_version": "description.Permissions.AccountSharingInfoList.SharedDocumentVersion",
	"title":                   "description.Permissions.AccountSharingInfoList.SharedDocumentVersion",
}

func GetSSMDocumentPermission(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMDocumentPermission")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMDocumentPermissionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMDocumentPermissionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMDocumentPermission =============================

// ==========================  START: SSMInventory =============================

type SSMInventory struct {
	Description   aws.SSMInventoryDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type SSMInventoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SSMInventory  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SSMInventoryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SSMInventoryHit `json:"hits"`
}

type SSMInventorySearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SSMInventoryHits `json:"hits"`
}

type SSMInventoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMInventoryPaginator(filters []essdk.BoolFilter, limit *int64) (SSMInventoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_inventory", filters, limit)
	if err != nil {
		return SSMInventoryPaginator{}, err
	}

	p := SSMInventoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMInventoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMInventoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMInventoryPaginator) NextPage(ctx context.Context) ([]SSMInventory, error) {
	var response SSMInventorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMInventory
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMInventoryFilters = map[string]string{
	"capture_time":   "description.CaptureTime",
	"content":        "description.Content",
	"id":             "description.Id",
	"og_account_id":  "metadata.SourceID",
	"schema":         "description.Schemas",
	"schema_version": "description.SchemaVersion",
	"title":          "description.Id",
	"type_name":      "description.TypeName",
}

func ListSSMInventory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMInventory")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventory NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventory NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventory GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventory GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventory GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMInventoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMInventoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventory NewSSMInventoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMInventory paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMInventoryFilters = map[string]string{
	"capture_time":   "description.CaptureTime",
	"content":        "description.Content",
	"id":             "description.Id",
	"og_account_id":  "metadata.SourceID",
	"schema":         "description.Schemas",
	"schema_version": "description.SchemaVersion",
	"title":          "description.Id",
	"type_name":      "description.TypeName",
}

func GetSSMInventory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMInventory")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMInventoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMInventoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMInventory =============================

// ==========================  START: SSMInventoryEntry =============================

type SSMInventoryEntry struct {
	Description   aws.SSMInventoryEntryDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type SSMInventoryEntryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  SSMInventoryEntry `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type SSMInventoryEntryHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []SSMInventoryEntryHit `json:"hits"`
}

type SSMInventoryEntrySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  SSMInventoryEntryHits `json:"hits"`
}

type SSMInventoryEntryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMInventoryEntryPaginator(filters []essdk.BoolFilter, limit *int64) (SSMInventoryEntryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_inventoryentry", filters, limit)
	if err != nil {
		return SSMInventoryEntryPaginator{}, err
	}

	p := SSMInventoryEntryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMInventoryEntryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMInventoryEntryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMInventoryEntryPaginator) NextPage(ctx context.Context) ([]SSMInventoryEntry, error) {
	var response SSMInventoryEntrySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMInventoryEntry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMInventoryEntryFilters = map[string]string{
	"capture_time":   "description.CaptureTime",
	"entries":        "description.Entries",
	"instance_id":    "description.InstanceId",
	"og_account_id":  "metadata.SourceID",
	"schema_version": "description.SchemaVersion",
	"title":          "description.InstanceId",
	"type_name":      "description.TypeName",
}

func ListSSMInventoryEntry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMInventoryEntry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventoryEntry NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventoryEntry NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventoryEntry GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventoryEntry GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventoryEntry GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMInventoryEntryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMInventoryEntryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMInventoryEntry NewSSMInventoryEntryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMInventoryEntry paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMInventoryEntryFilters = map[string]string{
	"capture_time":   "description.CaptureTime",
	"entries":        "description.Entries",
	"instance_id":    "description.InstanceId",
	"og_account_id":  "metadata.SourceID",
	"schema_version": "description.SchemaVersion",
	"title":          "description.InstanceId",
	"type_name":      "description.TypeName",
}

func GetSSMInventoryEntry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMInventoryEntry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMInventoryEntryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMInventoryEntryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMInventoryEntry =============================

// ==========================  START: SSMMaintenanceWindow =============================

type SSMMaintenanceWindow struct {
	Description   aws.SSMMaintenanceWindowDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SSMMaintenanceWindowHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SSMMaintenanceWindow `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SSMMaintenanceWindowHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SSMMaintenanceWindowHit `json:"hits"`
}

type SSMMaintenanceWindowSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SSMMaintenanceWindowHits `json:"hits"`
}

type SSMMaintenanceWindowPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMMaintenanceWindowPaginator(filters []essdk.BoolFilter, limit *int64) (SSMMaintenanceWindowPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_maintenancewindow", filters, limit)
	if err != nil {
		return SSMMaintenanceWindowPaginator{}, err
	}

	p := SSMMaintenanceWindowPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMMaintenanceWindowPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMMaintenanceWindowPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMMaintenanceWindowPaginator) NextPage(ctx context.Context) ([]SSMMaintenanceWindow, error) {
	var response SSMMaintenanceWindowSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMMaintenanceWindow
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMMaintenanceWindowFilters = map[string]string{
	"akas":                       "description.ARN",
	"allow_unassociated_targets": "description.MaintenanceWindow.AllowUnassociatedTargets",
	"created_date":               "description.MaintenanceWindow.CreatedDate",
	"cutoff":                     "description.MaintenanceWindow.Cutoff",
	"description":                "description.MaintenanceWindow.Description",
	"duration":                   "description.MaintenanceWindow.Duration",
	"enabled":                    "description.MaintenanceWindowIdentity.Enabled",
	"end_date":                   "description.MaintenanceWindow.EndDate",
	"og_account_id":              "metadata.SourceID",
	"modified_date":              "description.MaintenanceWindow.ModifiedDate",
	"name":                       "description.MaintenanceWindowIdentity.Name",
	"next_execution_time":        "description.MaintenanceWindow.NextExecutionTime",
	"schedule":                   "description.MaintenanceWindow.Schedule",
	"schedule_offset":            "description.MaintenanceWindow.ScheduleOffset",
	"schedule_timezone":          "description.MaintenanceWindow.ScheduleTimezone",
	"start_date":                 "description.MaintenanceWindow.StartDate",
	"tags_src":                   "description.Tags",
	"targets":                    "description.Targets",
	"tasks":                      "description.Tasks",
	"title":                      "description.MaintenanceWindow.Name",
	"window_id":                  "description.MaintenanceWindowIdentity.WindowId",
}

func ListSSMMaintenanceWindow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMMaintenanceWindow")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMMaintenanceWindow NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMMaintenanceWindow NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMMaintenanceWindow GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMMaintenanceWindow GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMMaintenanceWindow GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMMaintenanceWindowPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMMaintenanceWindowFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMMaintenanceWindow NewSSMMaintenanceWindowPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMMaintenanceWindow paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMMaintenanceWindowFilters = map[string]string{
	"akas":                       "description.ARN",
	"allow_unassociated_targets": "description.MaintenanceWindow.AllowUnassociatedTargets",
	"created_date":               "description.MaintenanceWindow.CreatedDate",
	"cutoff":                     "description.MaintenanceWindow.Cutoff",
	"description":                "description.MaintenanceWindow.Description",
	"duration":                   "description.MaintenanceWindow.Duration",
	"enabled":                    "description.MaintenanceWindow.Enabled",
	"end_date":                   "description.MaintenanceWindow.EndDate",
	"og_account_id":              "metadata.SourceID",
	"modified_date":              "description.MaintenanceWindow.ModifiedDate",
	"name":                       "description.MaintenanceWindow.Name",
	"next_execution_time":        "description.MaintenanceWindow.NextExecutionTime",
	"schedule":                   "description.MaintenanceWindow.Schedule",
	"schedule_offset":            "description.MaintenanceWindow.ScheduleOffset",
	"schedule_timezone":          "description.MaintenanceWindow.ScheduleTimezone",
	"start_date":                 "description.MaintenanceWindow.StartDate",
	"tags_src":                   "description.Tags",
	"targets":                    "description.Targets",
	"tasks":                      "description.Tasks",
	"title":                      "description.MaintenanceWindow.Name",
	"window_id":                  "description.MaintenanceWindowIdentity.WindowId",
}

func GetSSMMaintenanceWindow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMMaintenanceWindow")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMMaintenanceWindowPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMMaintenanceWindowFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMMaintenanceWindow =============================

// ==========================  START: SSMParameter =============================

type SSMParameter struct {
	Description   aws.SSMParameterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type SSMParameterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SSMParameter  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SSMParameterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SSMParameterHit `json:"hits"`
}

type SSMParameterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SSMParameterHits `json:"hits"`
}

type SSMParameterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMParameterPaginator(filters []essdk.BoolFilter, limit *int64) (SSMParameterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_parameter", filters, limit)
	if err != nil {
		return SSMParameterPaginator{}, err
	}

	p := SSMParameterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMParameterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMParameterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMParameterPaginator) NextPage(ctx context.Context) ([]SSMParameter, error) {
	var response SSMParameterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMParameter
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMParameterFilters = map[string]string{
	"arn":                "description.Parameter.ARN",
	"data_type":          "description.ParameterMetadata.DataType",
	"og_account_id":      "metadata.SourceID",
	"key_id":             "description.ParameterMetadata.KeyId",
	"last_modified_date": "description.Parameter.LastModifiedDate",
	"last_modified_user": "description.ParameterMetadata.LastModifiedUser",
	"name":               "description.Parameter.Name",
	"policies":           "description.ParameterMetadata.Policies",
	"selector":           "description.Parameter.Selector",
	"source_result":      "description.Parameter.SourceResult",
	"tags_src":           "description.Tags",
	"tier":               "description.ParameterMetadata.Tier",
	"title":              "description.Parameter.Name",
	"type":               "description.ParameterMetadata.Type",
	"value":              "description.Parameter.Value",
	"version":            "description.Parameter.Version",
}

func ListSSMParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMParameter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMParameter NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMParameter NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMParameter GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMParameter GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMParameter GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMParameterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMParameterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMParameter NewSSMParameterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMParameter paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMParameterFilters = map[string]string{
	"arn":                "description.Parameter.ARN",
	"data_type":          "description.Parameter.DataType",
	"og_account_id":      "metadata.SourceID",
	"key_id":             "description.ParameterMetadata.KeyId",
	"last_modified_date": "description.Parameter.LastModifiedDate",
	"last_modified_user": "description.ParameterMetadata.LastModifiedUser",
	"name":               "description.ParameterMetadata.Name",
	"policies":           "description.ParameterMetadata.Policies",
	"selector":           "description.Parameter.Selector",
	"source_result":      "description.Parameter.SourceResult",
	"tags_src":           "description.Tags",
	"tier":               "description.ParameterMetadata.Tier",
	"title":              "description.Parameter.Name",
	"type":               "description.Parameter.Type",
	"value":              "description.Parameter.Value",
	"version":            "description.Parameter.Version",
}

func GetSSMParameter(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMParameter")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMParameterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMParameterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMParameter =============================

// ==========================  START: SSMPatchBaseline =============================

type SSMPatchBaseline struct {
	Description   aws.SSMPatchBaselineDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type SSMPatchBaselineHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  SSMPatchBaseline `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type SSMPatchBaselineHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []SSMPatchBaselineHit `json:"hits"`
}

type SSMPatchBaselineSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  SSMPatchBaselineHits `json:"hits"`
}

type SSMPatchBaselinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMPatchBaselinePaginator(filters []essdk.BoolFilter, limit *int64) (SSMPatchBaselinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_patchbaseline", filters, limit)
	if err != nil {
		return SSMPatchBaselinePaginator{}, err
	}

	p := SSMPatchBaselinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMPatchBaselinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMPatchBaselinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMPatchBaselinePaginator) NextPage(ctx context.Context) ([]SSMPatchBaseline, error) {
	var response SSMPatchBaselineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMPatchBaseline
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMPatchBaselineFilters = map[string]string{
	"akas":                                 "description.ARN",
	"approval_rules":                       "description.PatchBaseline.ApprovalRules",
	"approved_patches":                     "description.PatchBaseline.ApprovedPatches",
	"approved_patches_compliance_level":    "description.PatchBaseline.ApprovedPatchesComplianceLevel",
	"approved_patches_enable_non_security": "description.PatchBaseline.ApprovedPatchesEnableNonSecurity",
	"created_date":                         "description.PatchBaseline.CreatedDate",
	"description":                          "description.PatchBaseline.Description",
	"global_filters":                       "description.PatchBaseline.GlobalFilters",
	"og_account_id":                        "metadata.SourceID",
	"modified_date":                        "description.PatchBaseline.ModifiedDate",
	"name":                                 "description.ParameterMetadata.Type",
	"operating_system":                     "description.ParameterMetadata.KeyId",
	"patch_groups":                         "description.PatchBaseline.PatchGroups",
	"rejected_patches":                     "description.PatchBaseline.RejectedPatches",
	"rejected_patches_action":              "description.PatchBaseline.RejectedPatchesAction",
	"sources":                              "description.PatchBaseline.Sources",
	"tags_src":                             "description.Tags",
	"title":                                "description.PatchBaselineIdentity.BaselineName",
}

func ListSSMPatchBaseline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMPatchBaseline")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMPatchBaseline NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMPatchBaseline NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMPatchBaseline GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMPatchBaseline GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMPatchBaseline GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMPatchBaselinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMPatchBaselineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMPatchBaseline NewSSMPatchBaselinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMPatchBaseline paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMPatchBaselineFilters = map[string]string{
	"akas":                                 "description.ARN",
	"approval_rules":                       "description.PatchBaseline.ApprovalRules",
	"approved_patches":                     "description.PatchBaseline.ApprovedPatches",
	"approved_patches_compliance_level":    "description.PatchBaseline.ApprovedPatchesComplianceLevel",
	"approved_patches_enable_non_security": "description.PatchBaseline.ApprovedPatchesEnableNonSecurity",
	"baseline_id":                          "description.ParameterMetadata.Name",
	"created_date":                         "description.PatchBaseline.CreatedDate",
	"description":                          "description.PatchBaseline.Description",
	"global_filters":                       "description.PatchBaseline.GlobalFilters",
	"og_account_id":                        "metadata.SourceID",
	"modified_date":                        "description.PatchBaseline.ModifiedDate",
	"name":                                 "description.PatchBaselineIdentity.BaselineName",
	"operating_system":                     "description.PatchBaseline.OperatingSystem",
	"patch_groups":                         "description.PatchBaseline.PatchGroups",
	"rejected_patches":                     "description.PatchBaseline.RejectedPatches",
	"rejected_patches_action":              "description.PatchBaseline.RejectedPatchesAction",
	"sources":                              "description.PatchBaseline.Sources",
	"tags_src":                             "description.Tags",
	"title":                                "description.PatchBaselineIdentity.BaselineName",
}

func GetSSMPatchBaseline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMPatchBaseline")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMPatchBaselinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMPatchBaselineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMPatchBaseline =============================

// ==========================  START: SSMManagedInstanceCompliance =============================

type SSMManagedInstanceCompliance struct {
	Description   aws.SSMManagedInstanceComplianceDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type SSMManagedInstanceComplianceHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SSMManagedInstanceCompliance `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SSMManagedInstanceComplianceHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SSMManagedInstanceComplianceHit `json:"hits"`
}

type SSMManagedInstanceComplianceSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SSMManagedInstanceComplianceHits `json:"hits"`
}

type SSMManagedInstanceCompliancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMManagedInstanceCompliancePaginator(filters []essdk.BoolFilter, limit *int64) (SSMManagedInstanceCompliancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_managedinstancecompliance", filters, limit)
	if err != nil {
		return SSMManagedInstanceCompliancePaginator{}, err
	}

	p := SSMManagedInstanceCompliancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMManagedInstanceCompliancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMManagedInstanceCompliancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMManagedInstanceCompliancePaginator) NextPage(ctx context.Context) ([]SSMManagedInstanceCompliance, error) {
	var response SSMManagedInstanceComplianceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMManagedInstanceCompliance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMManagedInstanceComplianceFilters = map[string]string{
	"compliance_type":   "description.ComplianceItem.ComplianceType",
	"details":           "description.ComplianceItem.Details",
	"execution_summary": "description.ComplianceItem.ExecutionSummary",
	"id":                "description.ComplianceItem.Id",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.ComplianceItem.Title",
	"resource_id":       "description.ComplianceItem.ResourceId",
	"resource_type":     "description.ComplianceItem.ResourceType",
	"severity":          "description.ComplianceItem.Severity",
	"status":            "description.ComplianceItem.Status",
}

func ListSSMManagedInstanceCompliance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMManagedInstanceCompliance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstanceCompliance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstanceCompliance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstanceCompliance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstanceCompliance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstanceCompliance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMManagedInstanceCompliancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMManagedInstanceComplianceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstanceCompliance NewSSMManagedInstanceCompliancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMManagedInstanceCompliance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMManagedInstanceComplianceFilters = map[string]string{
	"compliance_type":   "description.ComplianceItem.ComplianceType",
	"details":           "description.ComplianceItem.Details",
	"execution_summary": "description.ComplianceItem.ExecutionSummary",
	"id":                "description.ComplianceItem.Id",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.ComplianceItem.Title",
	"resource_id":       "description.ComplianceItem.ResourceId",
	"resource_type":     "description.ComplianceItem.ResourceType",
	"severity":          "description.ComplianceItem.Severity",
	"status":            "description.ComplianceItem.Status",
}

func GetSSMManagedInstanceCompliance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMManagedInstanceCompliance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMManagedInstanceCompliancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMManagedInstanceComplianceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMManagedInstanceCompliance =============================

// ==========================  START: SSMManagedInstancePatchState =============================

type SSMManagedInstancePatchState struct {
	Description   aws.SSMManagedInstancePatchStateDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type SSMManagedInstancePatchStateHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SSMManagedInstancePatchState `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SSMManagedInstancePatchStateHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SSMManagedInstancePatchStateHit `json:"hits"`
}

type SSMManagedInstancePatchStateSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SSMManagedInstancePatchStateHits `json:"hits"`
}

type SSMManagedInstancePatchStatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSMManagedInstancePatchStatePaginator(filters []essdk.BoolFilter, limit *int64) (SSMManagedInstancePatchStatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssm_managedinstancepatchstate", filters, limit)
	if err != nil {
		return SSMManagedInstancePatchStatePaginator{}, err
	}

	p := SSMManagedInstancePatchStatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSMManagedInstancePatchStatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSMManagedInstancePatchStatePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSMManagedInstancePatchStatePaginator) NextPage(ctx context.Context) ([]SSMManagedInstancePatchState, error) {
	var response SSMManagedInstancePatchStateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSMManagedInstancePatchState
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSMManagedInstancePatchStateFilters = map[string]string{
	"baseline_id":                           "description.PatchState.BaselineId",
	"critical_non_compliant_count":          "description.PatchState.CriticalNonCompliantCount",
	"failed_count":                          "description.PatchState.FailedCount",
	"installed_count":                       "description.PatchState.InstalledCount",
	"installed_other_count":                 "description.PatchState.InstalledOtherCount",
	"installed_pending_reboot_count":        "description.PatchState.InstalledPendingRebootCount",
	"installed_rejected_count":              "description.PatchState.InstalledRejectedCount",
	"instance_id":                           "Description.PatchState.InstanceId",
	"og_account_id":                         "metadata.SourceID",
	"last_no_reboot_install_operation_time": "description.PatchState.LastNoRebootInstallOperationTime",
	"missing_count":                         "description.PatchState.MissingCount",
	"not_applicable_count":                  "description.PatchState.NotApplicableCount",
	"operation":                             "description.PatchState.Operation",
	"operation_end_time":                    "description.PatchState.OperationEndTime",
	"operation_start_time":                  "description.PatchState.OperationStartTime",
	"other_non_compliant_count":             "description.PatchState.OtherNonCompliantCount",
	"owner_information":                     "description.PatchState.OwnerInformation",
	"patch_group":                           "description.PatchState.PatchGroup",
	"reboot_option":                         "description.PatchState.RebootOption",
	"security_non_compliant_count":          "description.PatchState.SecurityNonCompliantCount",
	"snapshot_id":                           "description.PatchState.SnapshotId",
	"title":                                 "description.PatchState.BaselineId",
	"unreported_not_applicable_count":       "description.PatchState.UnreportedNotApplicableCount",
}

func ListSSMManagedInstancePatchState(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSMManagedInstancePatchState")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstancePatchState NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstancePatchState NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstancePatchState GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstancePatchState GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstancePatchState GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSMManagedInstancePatchStatePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSMManagedInstancePatchStateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSMManagedInstancePatchState NewSSMManagedInstancePatchStatePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSMManagedInstancePatchState paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSMManagedInstancePatchStateFilters = map[string]string{
	"baseline_id":                           "description.PatchState.BaselineId",
	"critical_non_compliant_count":          "description.PatchState.CriticalNonCompliantCount",
	"failed_count":                          "description.PatchState.FailedCount",
	"installed_count":                       "description.PatchState.InstalledCount",
	"installed_other_count":                 "description.PatchState.InstalledOtherCount",
	"installed_pending_reboot_count":        "description.PatchState.InstalledPendingRebootCount",
	"installed_rejected_count":              "description.PatchState.InstalledRejectedCount",
	"instance_id":                           "description.PatchState.InstanceId",
	"og_account_id":                         "metadata.SourceID",
	"last_no_reboot_install_operation_time": "description.PatchState.LastNoRebootInstallOperationTime",
	"missing_count":                         "description.PatchState.MissingCount",
	"not_applicable_count":                  "description.PatchState.NotApplicableCount",
	"operation":                             "description.PatchState.Operation",
	"operation_end_time":                    "description.PatchState.OperationEndTime",
	"operation_start_time":                  "description.PatchState.OperationStartTime",
	"other_non_compliant_count":             "description.PatchState.OtherNonCompliantCount",
	"owner_information":                     "description.PatchState.OwnerInformation",
	"patch_group":                           "description.PatchState.PatchGroup",
	"reboot_option":                         "description.PatchState.RebootOption",
	"security_non_compliant_count":          "description.PatchState.SecurityNonCompliantCount",
	"snapshot_id":                           "description.PatchState.SnapshotId",
	"title":                                 "description.PatchState.BaselineId",
	"unreported_not_applicable_count":       "description.PatchState.UnreportedNotApplicableCount",
}

func GetSSMManagedInstancePatchState(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSMManagedInstancePatchState")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSMManagedInstancePatchStatePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSMManagedInstancePatchStateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSMManagedInstancePatchState =============================

// ==========================  START: ECSTaskDefinition =============================

type ECSTaskDefinition struct {
	Description   aws.ECSTaskDefinitionDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ECSTaskDefinitionHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ECSTaskDefinition `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ECSTaskDefinitionHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ECSTaskDefinitionHit `json:"hits"`
}

type ECSTaskDefinitionSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ECSTaskDefinitionHits `json:"hits"`
}

type ECSTaskDefinitionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSTaskDefinitionPaginator(filters []essdk.BoolFilter, limit *int64) (ECSTaskDefinitionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_taskdefinition", filters, limit)
	if err != nil {
		return ECSTaskDefinitionPaginator{}, err
	}

	p := ECSTaskDefinitionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSTaskDefinitionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSTaskDefinitionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECSTaskDefinitionPaginator) NextPage(ctx context.Context) ([]ECSTaskDefinition, error) {
	var response ECSTaskDefinitionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSTaskDefinition
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSTaskDefinitionFilters = map[string]string{
	"compatibilities":          "description.TaskDefinition.Compatibilities",
	"container_definitions":    "description.TaskDefinition.ContainerDefinitions",
	"cpu":                      "description.TaskDefinition.Cpu",
	"execution_role_arn":       "description.TaskDefinition.ExecutionRoleArn",
	"family":                   "description.TaskDefinition.Family",
	"inference_accelerators":   "description.TaskDefinition.InferenceAccelerators",
	"ipc_mode":                 "description.TaskDefinition.IpcMode",
	"og_account_id":            "metadata.SourceID",
	"memory":                   "description.TaskDefinition.Memory",
	"network_mode":             "description.TaskDefinition.NetworkMode",
	"pid_mode":                 "description.TaskDefinition.PidMode",
	"placement_constraints":    "description.TaskDefinition.PlacementConstraints",
	"proxy_configuration":      "description.TaskDefinition.ProxyConfiguration",
	"registered_at":            "description.TaskDefinition.RegisteredAt",
	"registered_by":            "description.TaskDefinition.RegisteredBy",
	"requires_attributes":      "description.TaskDefinition.RequiresAttributes",
	"requires_compatibilities": "description.TaskDefinition.RequiresCompatibilities",
	"revision":                 "description.TaskDefinition.Revision",
	"status":                   "description.TaskDefinition.Status",
	"tags_src":                 "description.Tags",
	"task_definition_arn":      "description.TaskDefinition.TaskDefinitionArn",
	"task_role_arn":            "description.TaskDefinition.TaskRoleArn",
	"volumes":                  "description.TaskDefinition.Volumes",
}

func ListECSTaskDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSTaskDefinition")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskDefinition NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskDefinition NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECSTaskDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECSTaskDefinitionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskDefinition NewECSTaskDefinitionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECSTaskDefinition paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECSTaskDefinitionFilters = map[string]string{
	"compatibilities":          "description.TaskDefinition.Compatibilities",
	"container_definitions":    "description.TaskDefinition.ContainerDefinitions",
	"cpu":                      "description.TaskDefinition.Cpu",
	"execution_role_arn":       "description.TaskDefinition.ExecutionRoleArn",
	"family":                   "description.TaskDefinition.Family",
	"inference_accelerators":   "description.TaskDefinition.InferenceAccelerators",
	"ipc_mode":                 "description.TaskDefinition.IpcMode",
	"og_account_id":            "metadata.SourceID",
	"memory":                   "description.TaskDefinition.Memory",
	"network_mode":             "description.TaskDefinition.NetworkMode",
	"pid_mode":                 "description.TaskDefinition.PidMode",
	"placement_constraints":    "description.TaskDefinition.PlacementConstraints",
	"proxy_configuration":      "description.TaskDefinition.ProxyConfiguration",
	"registered_at":            "description.TaskDefinition.RegisteredAt",
	"registered_by":            "description.TaskDefinition.RegisteredBy",
	"requires_attributes":      "description.TaskDefinition.RequiresAttributes",
	"requires_compatibilities": "description.TaskDefinition.RequiresCompatibilities",
	"revision":                 "description.TaskDefinition.Revision",
	"status":                   "description.TaskDefinition.Status",
	"tags_src":                 "description.Tags",
	"task_definition_arn":      "description.TaskDefinition.TaskDefinitionArn",
	"task_role_arn":            "description.TaskDefinition.TaskRoleArn",
	"volumes":                  "description.TaskDefinition.Volumes",
}

func GetECSTaskDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSTaskDefinition")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECSTaskDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECSTaskDefinitionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECSTaskDefinition =============================

// ==========================  START: ECSCluster =============================

type ECSCluster struct {
	Description   aws.ECSClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ECSClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSClusterHit   `json:"hits"`
}

type ECSClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ECSClusterHits `json:"hits"`
}

type ECSClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSClusterPaginator(filters []essdk.BoolFilter, limit *int64) (ECSClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_cluster", filters, limit)
	if err != nil {
		return ECSClusterPaginator{}, err
	}

	p := ECSClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECSClusterPaginator) NextPage(ctx context.Context) ([]ECSCluster, error) {
	var response ECSClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSClusterFilters = map[string]string{
	"active_services_count":                "description.Cluster.ActiveServicesCount",
	"attachments":                          "description.Cluster.Attachments",
	"attachments_status":                   "description.Cluster.AttachmentsStatus",
	"capacity_providers":                   "description.Cluster.CapacityProviders",
	"cluster_arn":                          "description.Cluster.ClusterArn",
	"cluster_name":                         "description.Cluster.ClusterName",
	"default_capacity_provider_strategy":   "description.Cluster.DefaultCapacityProviderStrategy",
	"og_account_id":                        "metadata.SourceID",
	"pending_tasks_count":                  "description.Cluster.PendingTasksCount",
	"registered_container_instances_count": "description.Cluster.RegisteredContainerInstancesCount",
	"running_tasks_count":                  "description.Cluster.RunningTasksCount",
	"settings":                             "description.Cluster.Settings",
	"statistics":                           "description.Cluster.Statistics",
	"status":                               "description.Cluster.Status",
	"tags_src":                             "description.Cluster.Tags",
	"title":                                "description.Cluster.ClusterName",
}

func ListECSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECSClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECSClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSCluster NewECSClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECSCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECSClusterFilters = map[string]string{
	"active_services_count":                "description.Cluster.ActiveServicesCount",
	"attachments":                          "description.Cluster.Attachments",
	"attachments_status":                   "description.Cluster.AttachmentsStatus",
	"capacity_providers":                   "description.Cluster.CapacityProviders",
	"cluster_arn":                          "description.Cluster.ClusterArn",
	"cluster_name":                         "description.Cluster.ClusterName",
	"default_capacity_provider_strategy":   "description.Cluster.DefaultCapacityProviderStrategy",
	"og_account_id":                        "metadata.SourceID",
	"pending_tasks_count":                  "description.Cluster.PendingTasksCount",
	"registered_container_instances_count": "description.Cluster.RegisteredContainerInstancesCount",
	"running_tasks_count":                  "description.Cluster.RunningTasksCount",
	"settings":                             "description.Cluster.Settings",
	"statistics":                           "description.Cluster.Statistics",
	"status":                               "description.Cluster.Status",
	"tags_src":                             "description.Cluster.Tags",
	"title":                                "description.Cluster.ClusterName",
}

func GetECSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECSClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECSClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECSCluster =============================

// ==========================  START: ECSService =============================

type ECSService struct {
	Description   aws.ECSServiceDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ECSServiceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSService    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSServiceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSServiceHit   `json:"hits"`
}

type ECSServiceSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ECSServiceHits `json:"hits"`
}

type ECSServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSServicePaginator(filters []essdk.BoolFilter, limit *int64) (ECSServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_service", filters, limit)
	if err != nil {
		return ECSServicePaginator{}, err
	}

	p := ECSServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECSServicePaginator) NextPage(ctx context.Context) ([]ECSService, error) {
	var response ECSServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSServiceFilters = map[string]string{
	"arn":                               "description.Service.ServiceArn",
	"capacity_provider_strategy":        "description.Service.CapacityProviderStrategy",
	"cluster_arn":                       "description.Service.ClusterArn",
	"created_at":                        "description.Service.CreatedAt",
	"created_by":                        "description.Service.CreatedBy",
	"deployment_configuration":          "description.Service.DeploymentConfiguration",
	"deployment_controller_type":        "description.Service.DeploymentController.Type",
	"deployments":                       "description.Service.Deployments",
	"desired_count":                     "description.Service.DesiredCount",
	"enable_ecs_managed_tags":           "description.Service.EnableECSManagedTags",
	"enable_execute_command":            "description.Service.EnableExecuteCommand",
	"events":                            "description.Service.Events",
	"health_check_grace_period_seconds": "description.Service.HealthCheckGracePeriodSeconds",
	"og_account_id":                     "metadata.SourceID",
	"launch_type":                       "description.Service.LaunchType",
	"load_balancers":                    "description.Service.LoadBalancers",
	"network_configuration":             "description.Service.NetworkConfiguration",
	"pending_count":                     "description.Service.PendingCount",
	"placement_constraints":             "description.Service.PlacementConstraints",
	"placement_strategy":                "description.Service.PlacementStrategy",
	"platform_family":                   "description.Service.PlatformFamily",
	"platform_version":                  "description.Service.PlatformVersion",
	"propagate_tags":                    "description.Service.PropagateTags",
	"role_arn":                          "description.Service.RoleArn",
	"running_count":                     "description.Service.RunningCount",
	"scheduling_strategy":               "description.Service.SchedulingStrategy",
	"service_name":                      "description.Service.ServiceName",
	"service_registries":                "description.Service.ServiceRegistries",
	"status":                            "description.Service.Status",
	"tags_src":                          "description.Tags",
	"task_definition":                   "description.Service.TaskDefinition",
	"task_sets":                         "description.Service.TaskSets",
	"title":                             "description.Service.ServiceName",
}

func ListECSService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSService NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSService GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECSServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listECSServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSService NewECSServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECSService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECSServiceFilters = map[string]string{
	"arn":                               "description.Service.ServiceArn",
	"capacity_provider_strategy":        "description.Service.CapacityProviderStrategy",
	"cluster_arn":                       "description.Service.ClusterArn",
	"created_at":                        "description.Service.CreatedAt",
	"created_by":                        "description.Service.CreatedBy",
	"deployment_configuration":          "description.Service.DeploymentConfiguration",
	"deployment_controller_type":        "description.Service.DeploymentController.Type",
	"deployments":                       "description.Service.Deployments",
	"desired_count":                     "description.Service.DesiredCount",
	"enable_ecs_managed_tags":           "description.Service.EnableECSManagedTags",
	"enable_execute_command":            "description.Service.EnableExecuteCommand",
	"events":                            "description.Service.Events",
	"health_check_grace_period_seconds": "description.Service.HealthCheckGracePeriodSeconds",
	"og_account_id":                     "metadata.SourceID",
	"launch_type":                       "description.Service.LaunchType",
	"load_balancers":                    "description.Service.LoadBalancers",
	"network_configuration":             "description.Service.NetworkConfiguration",
	"pending_count":                     "description.Service.PendingCount",
	"placement_constraints":             "description.Service.PlacementConstraints",
	"placement_strategy":                "description.Service.PlacementStrategy",
	"platform_family":                   "description.Service.PlatformFamily",
	"platform_version":                  "description.Service.PlatformVersion",
	"propagate_tags":                    "description.Service.PropagateTags",
	"role_arn":                          "description.Service.RoleArn",
	"running_count":                     "description.Service.RunningCount",
	"scheduling_strategy":               "description.Service.SchedulingStrategy",
	"service_name":                      "description.Service.ServiceName",
	"service_registries":                "description.Service.ServiceRegistries",
	"status":                            "description.Service.Status",
	"tags_src":                          "description.Tags",
	"task_definition":                   "description.Service.TaskDefinition",
	"task_sets":                         "description.Service.TaskSets",
	"title":                             "description.Service.ServiceName",
}

func GetECSService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECSServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getECSServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECSService =============================

// ==========================  START: ECSContainerInstance =============================

type ECSContainerInstance struct {
	Description   aws.ECSContainerInstanceDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ECSContainerInstanceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ECSContainerInstance `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ECSContainerInstanceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ECSContainerInstanceHit `json:"hits"`
}

type ECSContainerInstanceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ECSContainerInstanceHits `json:"hits"`
}

type ECSContainerInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSContainerInstancePaginator(filters []essdk.BoolFilter, limit *int64) (ECSContainerInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_containerinstance", filters, limit)
	if err != nil {
		return ECSContainerInstancePaginator{}, err
	}

	p := ECSContainerInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSContainerInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSContainerInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECSContainerInstancePaginator) NextPage(ctx context.Context) ([]ECSContainerInstance, error) {
	var response ECSContainerInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSContainerInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSContainerInstanceFilters = map[string]string{
	"agent_connected":        "description.ContainerInstance.AgentConnected",
	"agent_update_status":    "description.ContainerInstance.AgentUpdateStatus",
	"arn":                    "description.ContainerInstance.ContainerInstanceArn",
	"attachments":            "description.ContainerInstance.Attachments",
	"attributes":             "description.ContainerInstance.Attributes",
	"capacity_provider_name": "description.ContainerInstance.CapacityProviderName",
	"cluster_arn":            "description.Cluster.ClusterArn",
	"ec2_instance_id":        "description.ContainerInstance.Ec2InstanceId",
	"og_account_id":          "metadata.SourceID",
	"pending_tasks_count":    "description.ContainerInstance.PendingTasksCount",
	"registered_at":          "description.ContainerInstance.RegisteredAt",
	"registered_resources":   "description.ContainerInstance.RegisteredResources",
	"remaining_resources":    "description.ContainerInstance.RemainingResources",
	"running_tasks_count":    "description.ContainerInstance.RunningTasksCount",
	"status":                 "description.ContainerInstance.Status",
	"status_reason":          "description.ContainerInstance.StatusReason",
	"title":                  "description.ContainerInstance.ContainerInstanceArn",
	"version":                "description.ContainerInstance.Version",
	"version_info":           "description.ContainerInstance.VersionInfo",
}

func ListECSContainerInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSContainerInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSContainerInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSContainerInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSContainerInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSContainerInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSContainerInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECSContainerInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listECSContainerInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSContainerInstance NewECSContainerInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECSContainerInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECSContainerInstanceFilters = map[string]string{
	"agent_connected":        "description.ContainerInstance.AgentConnected",
	"agent_update_status":    "description.ContainerInstance.AgentUpdateStatus",
	"arn":                    "description.ContainerInstance.ContainerInstanceArn",
	"attachments":            "description.ContainerInstance.Attachments",
	"attributes":             "description.ContainerInstance.Attributes",
	"capacity_provider_name": "description.ContainerInstance.CapacityProviderName",
	"cluster_arn":            "description.Cluster.ClusterArn",
	"ec2_instance_id":        "description.ContainerInstance.Ec2InstanceId",
	"og_account_id":          "metadata.SourceID",
	"pending_tasks_count":    "description.ContainerInstance.PendingTasksCount",
	"registered_at":          "description.ContainerInstance.RegisteredAt",
	"registered_resources":   "description.ContainerInstance.RegisteredResources",
	"remaining_resources":    "description.ContainerInstance.RemainingResources",
	"running_tasks_count":    "description.ContainerInstance.RunningTasksCount",
	"status":                 "description.ContainerInstance.Status",
	"status_reason":          "description.ContainerInstance.StatusReason",
	"title":                  "description.ContainerInstance.ContainerInstanceArn",
	"version":                "description.ContainerInstance.Version",
	"version_info":           "description.ContainerInstance.VersionInfo",
}

func GetECSContainerInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSContainerInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECSContainerInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getECSContainerInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECSContainerInstance =============================

// ==========================  START: ECSTaskSet =============================

type ECSTaskSet struct {
	Description   aws.ECSTaskSetDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type ECSTaskSetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSTaskSet    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSTaskSetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSTaskSetHit   `json:"hits"`
}

type ECSTaskSetSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ECSTaskSetHits `json:"hits"`
}

type ECSTaskSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSTaskSetPaginator(filters []essdk.BoolFilter, limit *int64) (ECSTaskSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_taskset", filters, limit)
	if err != nil {
		return ECSTaskSetPaginator{}, err
	}

	p := ECSTaskSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSTaskSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSTaskSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECSTaskSetPaginator) NextPage(ctx context.Context) ([]ECSTaskSet, error) {
	var response ECSTaskSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSTaskSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSTaskSetFilters = map[string]string{
	"id":            "description.TaskSet.Id",
	"og_account_id": "metadata.SourceID",
	"task_set_arn":  "description.TaskSet.TaskSetArn",
	"title":         "description.TaskSet.Id",
}

func ListECSTaskSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSTaskSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECSTaskSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECSTaskSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTaskSet NewECSTaskSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECSTaskSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECSTaskSetFilters = map[string]string{
	"id":            "description.TaskSet.Id",
	"og_account_id": "metadata.SourceID",
	"task_set_arn":  "description.TaskSet.TaskSetArn",
	"title":         "description.TaskSet.Id",
}

func GetECSTaskSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSTaskSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECSTaskSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECSTaskSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECSTaskSet =============================

// ==========================  START: ECSTask =============================

type ECSTask struct {
	Description   aws.ECSTaskDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type ECSTaskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECSTask       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECSTaskHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECSTaskHit      `json:"hits"`
}

type ECSTaskSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  ECSTaskHits `json:"hits"`
}

type ECSTaskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECSTaskPaginator(filters []essdk.BoolFilter, limit *int64) (ECSTaskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecs_task", filters, limit)
	if err != nil {
		return ECSTaskPaginator{}, err
	}

	p := ECSTaskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECSTaskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECSTaskPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECSTaskPaginator) NextPage(ctx context.Context) ([]ECSTask, error) {
	var response ECSTaskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECSTask
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECSTaskFilters = map[string]string{
	"attachments":            "description.Task.Attachments",
	"attributes":             "description.Task.Attributes",
	"availability_zone":      "description.Task.AvailabilityZone",
	"capacity_provider_name": "description.Task.CapacityProviderName",
	"cluster_arn":            "description.Task.ClusterArn",
	"connectivity":           "description.Task.Connectivity",
	"connectivity_at":        "description.Task.ConnectivityAt",
	"container_instance_arn": "description.Task.ContainerInstanceArn",
	"containers":             "description.Task.Containers",
	"cpu":                    "description.NO_MATCH_WAS_FOUND",
	"created_at":             "description.Task.CreatedAt",
	"desired_status":         "description.Task.DesiredStatus",
	"enable_execute_command": "description.Task.EnableExecuteCommand",
	"ephemeral_storage":      "description.Task.EphemeralStorage",
	"execution_stopped_at":   "description.Task.ExecutionStoppedAt",
	"group":                  "description.Task.Group",
	"health_status":          "description.Task.HealthStatus",
	"inference_accelerators": "description.Task.InferenceAccelerators",
	"og_account_id":          "metadata.SourceID",
	"last_status":            "description.Task.LastStatus",
	"launch_type":            "description.Task.LaunchType",
	"memory":                 "description.Task.Memory",
	"overrides":              "description.Task.Overrides",
	"platform_version":       "description.Task.PlatformVersion",
	"protection":             "description.TaskProtection",
	"pull_started_at":        "description.Task.PullStartedAt",
	"pull_stopped_at":        "description.Task.PullStoppedAt",
	"service_name":           "description.ServiceName",
	"started_at":             "description.Task.StartedAt",
	"started_by":             "description.Task.StartedBy",
	"stop_code":              "description.Task.StopCode",
	"stopped_at":             "description.Task.StoppedAt",
	"stopped_reason":         "description.Task.StoppedReason",
	"stopping_at":            "description.Task.StoppingAt",
	"tags_src":               "description.Task.Tags",
	"task_arn":               "description.Task.TaskArn",
	"task_definition_arn":    "description.Task.TaskDefinitionArn",
	"version":                "description.Task.Version",
}

func ListECSTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECSTask")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTask NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTask NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTask GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECSTaskPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECSTaskFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECSTask NewECSTaskPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECSTask paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECSTaskFilters = map[string]string{
	"attachments":            "description.Task.Attachments",
	"attributes":             "description.Task.Attributes",
	"availability_zone":      "description.Task.AvailabilityZone",
	"capacity_provider_name": "description.Task.CapacityProviderName",
	"cluster_arn":            "description.Task.ClusterArn",
	"connectivity":           "description.Task.Connectivity",
	"connectivity_at":        "description.Task.ConnectivityAt",
	"container_instance_arn": "description.Task.ContainerInstanceArn",
	"containers":             "description.Task.Containers",
	"cpu":                    "description.NO_MATCH_WAS_FOUND",
	"created_at":             "description.Task.CreatedAt",
	"desired_status":         "description.Task.DesiredStatus",
	"enable_execute_command": "description.Task.EnableExecuteCommand",
	"ephemeral_storage":      "description.Task.EphemeralStorage",
	"execution_stopped_at":   "description.Task.ExecutionStoppedAt",
	"group":                  "description.Task.Group",
	"health_status":          "description.Task.HealthStatus",
	"inference_accelerators": "description.Task.InferenceAccelerators",
	"og_account_id":          "metadata.SourceID",
	"last_status":            "description.Task.LastStatus",
	"launch_type":            "description.Task.LaunchType",
	"memory":                 "description.Task.Memory",
	"overrides":              "description.Task.Overrides",
	"platform_version":       "description.Task.PlatformVersion",
	"protection":             "description.TaskProtection",
	"pull_started_at":        "description.Task.PullStartedAt",
	"pull_stopped_at":        "description.Task.PullStoppedAt",
	"started_at":             "description.Task.StartedAt",
	"started_by":             "description.Task.StartedBy",
	"stop_code":              "description.Task.StopCode",
	"stopped_at":             "description.Task.StoppedAt",
	"stopped_reason":         "description.Task.StoppedReason",
	"stopping_at":            "description.Task.StoppingAt",
	"tags_src":               "description.Task.Tags",
	"task_arn":               "description.Task.TaskArn",
	"task_definition_arn":    "description.Task.TaskDefinitionArn",
	"version":                "description.Task.Version",
}

func GetECSTask(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECSTask")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECSTaskPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECSTaskFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECSTask =============================

// ==========================  START: EFSFileSystem =============================

type EFSFileSystem struct {
	Description   aws.EFSFileSystemDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type EFSFileSystemHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EFSFileSystem `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EFSFileSystemHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []EFSFileSystemHit `json:"hits"`
}

type EFSFileSystemSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  EFSFileSystemHits `json:"hits"`
}

type EFSFileSystemPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEFSFileSystemPaginator(filters []essdk.BoolFilter, limit *int64) (EFSFileSystemPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_efs_filesystem", filters, limit)
	if err != nil {
		return EFSFileSystemPaginator{}, err
	}

	p := EFSFileSystemPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EFSFileSystemPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EFSFileSystemPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EFSFileSystemPaginator) NextPage(ctx context.Context) ([]EFSFileSystem, error) {
	var response EFSFileSystemSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EFSFileSystem
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEFSFileSystemFilters = map[string]string{
	"arn":                             "description.FileSystem.FileSystemArn",
	"creation_time":                   "description.FileSystem.CreationTime",
	"creation_token":                  "description.FileSystem.CreationToken",
	"encrypted":                       "description.FileSystem.Encrypted",
	"file_system_id":                  "description.FileSystem.FileSystemId",
	"og_account_id":                   "metadata.SourceID",
	"kms_key_id":                      "description.FileSystem.KmsKeyId",
	"life_cycle_state":                "description.FileSystem.LifeCycleState",
	"name":                            "description.FileSystem.Name",
	"number_of_mount_targets":         "description.FileSystem.NumberOfMountTargets",
	"owner_id":                        "description.FileSystem.OwnerId",
	"performance_mode":                "description.FileSystem.PerformanceMode",
	"policy":                          "description.Policy",
	"provisioned_throughput_in_mibps": "description.FileSystem.ProvisionedThroughputInMibps",
	"size_in_bytes":                   "description.FileSystem.SizeInBytes",
	"tags_src":                        "description.FileSystem.Tags",
	"throughput_mode":                 "description.FileSystem.ThroughputMode",
}

func ListEFSFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEFSFileSystem")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSFileSystem NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSFileSystem NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSFileSystem GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSFileSystem GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSFileSystem GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEFSFileSystemPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEFSFileSystemFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSFileSystem NewEFSFileSystemPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEFSFileSystem paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEFSFileSystemFilters = map[string]string{
	"arn":                             "description.FileSystem.FileSystemArn",
	"aws_efs_file_system":             "description.FileSystem.FileSystemId",
	"creation_time":                   "description.FileSystem.CreationTime",
	"creation_token":                  "description.FileSystem.CreationToken",
	"encrypted":                       "description.FileSystem.Encrypted",
	"file_system_id":                  "description.FileSystem.FileSystemId",
	"og_account_id":                   "metadata.SourceID",
	"kms_key_id":                      "description.FileSystem.KmsKeyId",
	"life_cycle_state":                "description.FileSystem.LifeCycleState",
	"name":                            "description.FileSystem.Name",
	"number_of_mount_targets":         "description.FileSystem.NumberOfMountTargets",
	"owner_id":                        "description.FileSystem.OwnerId",
	"performance_mode":                "description.FileSystem.PerformanceMode",
	"policy":                          "description.Policy",
	"provisioned_throughput_in_mibps": "description.FileSystem.ProvisionedThroughputInMibps",
	"size_in_bytes":                   "description.FileSystem.SizeInBytes",
	"tags_src":                        "description.FileSystem.Tags",
	"throughput_mode":                 "description.FileSystem.ThroughputMode",
}

func GetEFSFileSystem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEFSFileSystem")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEFSFileSystemPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEFSFileSystemFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EFSFileSystem =============================

// ==========================  START: EFSAccessPoint =============================

type EFSAccessPoint struct {
	Description   aws.EFSAccessPointDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EFSAccessPointHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EFSAccessPoint `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EFSAccessPointHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EFSAccessPointHit `json:"hits"`
}

type EFSAccessPointSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EFSAccessPointHits `json:"hits"`
}

type EFSAccessPointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEFSAccessPointPaginator(filters []essdk.BoolFilter, limit *int64) (EFSAccessPointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_efs_accesspoint", filters, limit)
	if err != nil {
		return EFSAccessPointPaginator{}, err
	}

	p := EFSAccessPointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EFSAccessPointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EFSAccessPointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EFSAccessPointPaginator) NextPage(ctx context.Context) ([]EFSAccessPoint, error) {
	var response EFSAccessPointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EFSAccessPoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEFSAccessPointFilters = map[string]string{
	"access_point_arn": "description.AccessPoint.AccessPointArn",
	"access_point_id":  "description.AccessPoint.AccessPointId",
	"client_token":     "description.AccessPoint.ClientToken",
	"file_system_id":   "description.AccessPoint.FileSystemId",
	"og_account_id":    "metadata.SourceID",
	"life_cycle_state": "description.AccessPoint.LifeCycleState",
	"name":             "description.AccessPoint.Name",
	"owner_id":         "description.AccessPoint.OwnerId",
	"posix_user":       "description.AccessPoint.PosixUser",
	"root_directory":   "description.AccessPoint.RootDirectory",
	"tags_src":         "description.AccessPoint.Tags",
}

func ListEFSAccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEFSAccessPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSAccessPoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSAccessPoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSAccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSAccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSAccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEFSAccessPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEFSAccessPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSAccessPoint NewEFSAccessPointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEFSAccessPoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEFSAccessPointFilters = map[string]string{
	"access_point_arn": "description.AccessPoint.AccessPointArn",
	"access_point_id":  "description.AccessPoint.AccessPointId",
	"client_token":     "description.AccessPoint.ClientToken",
	"file_system_id":   "description.AccessPoint.FileSystemId",
	"og_account_id":    "metadata.SourceID",
	"life_cycle_state": "description.AccessPoint.LifeCycleState",
	"name":             "description.AccessPoint.Name",
	"owner_id":         "description.AccessPoint.OwnerId",
	"posix_user":       "description.AccessPoint.PosixUser",
	"root_directory":   "description.AccessPoint.RootDirectory",
	"tags_src":         "description.AccessPoint.Tags",
}

func GetEFSAccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEFSAccessPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEFSAccessPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEFSAccessPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EFSAccessPoint =============================

// ==========================  START: EFSMountTarget =============================

type EFSMountTarget struct {
	Description   aws.EFSMountTargetDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EFSMountTargetHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EFSMountTarget `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EFSMountTargetHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EFSMountTargetHit `json:"hits"`
}

type EFSMountTargetSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EFSMountTargetHits `json:"hits"`
}

type EFSMountTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEFSMountTargetPaginator(filters []essdk.BoolFilter, limit *int64) (EFSMountTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_efs_mounttarget", filters, limit)
	if err != nil {
		return EFSMountTargetPaginator{}, err
	}

	p := EFSMountTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EFSMountTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EFSMountTargetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EFSMountTargetPaginator) NextPage(ctx context.Context) ([]EFSMountTarget, error) {
	var response EFSMountTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EFSMountTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEFSMountTargetFilters = map[string]string{
	"availability_zone_id":   "description.MountTarget.AvailabilityZoneId",
	"availability_zone_name": "description.MountTarget.AvailabilityZoneName",
	"file_system_id":         "description.MountTarget.FileSystemId",
	"ip_address":             "description.MountTarget.IpAddress",
	"og_account_id":          "metadata.SourceID",
	"life_cycle_state":       "description.MountTarget.LifeCycleState",
	"mount_target_id":        "description.MountTarget.MountTargetId",
	"network_interface_id":   "description.MountTarget.NetworkInterfaceId",
	"owner_id":               "description.MountTarget.OwnerId",
	"security_groups":        "description.SecurityGroups",
	"subnet_id":              "description.MountTarget.SubnetId",
	"title":                  "description.MountTarget.MountTargetId",
	"vpc_id":                 "description.MountTarget.VpcId",
}

func ListEFSMountTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEFSMountTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSMountTarget NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSMountTarget NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSMountTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSMountTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSMountTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEFSMountTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEFSMountTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEFSMountTarget NewEFSMountTargetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEFSMountTarget paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEFSMountTargetFilters = map[string]string{
	"availability_zone_id":   "description.MountTarget.AvailabilityZoneId",
	"availability_zone_name": "description.MountTarget.AvailabilityZoneName",
	"file_system_id":         "description.MountTarget.FileSystemId",
	"ip_address":             "description.MountTarget.IpAddress",
	"og_account_id":          "metadata.SourceID",
	"life_cycle_state":       "description.MountTarget.LifeCycleState",
	"mount_target_id":        "description.MountTarget.MountTargetId",
	"network_interface_id":   "description.MountTarget.NetworkInterfaceId",
	"owner_id":               "description.MountTarget.OwnerId",
	"security_groups":        "description.SecurityGroups",
	"subnet_id":              "description.MountTarget.SubnetId",
	"title":                  "description.MountTarget.MountTargetId",
	"vpc_id":                 "description.MountTarget.VpcId",
}

func GetEFSMountTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEFSMountTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEFSMountTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEFSMountTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EFSMountTarget =============================

// ==========================  START: EKSCluster =============================

type EKSCluster struct {
	Description   aws.EKSClusterDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type EKSClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EKSCluster    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EKSClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EKSClusterHit   `json:"hits"`
}

type EKSClusterSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  EKSClusterHits `json:"hits"`
}

type EKSClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSClusterPaginator(filters []essdk.BoolFilter, limit *int64) (EKSClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_cluster", filters, limit)
	if err != nil {
		return EKSClusterPaginator{}, err
	}

	p := EKSClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EKSClusterPaginator) NextPage(ctx context.Context) ([]EKSCluster, error) {
	var response EKSClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSClusterFilters = map[string]string{
	"arn":                       "description.Cluster.Arn",
	"certificate_authority":     "description.Cluster.CertificateAuthority",
	"created_at":                "description.Cluster.CreatedAt",
	"encryption_config":         "description.Cluster.EncryptionConfig",
	"endpoint":                  "description.Cluster.Endpoint",
	"identity":                  "description.Cluster.Identity",
	"og_account_id":             "metadata.SourceID",
	"kubernetes_network_config": "description.Cluster.KubernetesNetworkConfig",
	"logging":                   "description.Cluster.Logging",
	"name":                      "description.Cluster.Name",
	"platform_version":          "description.Cluster.PlatformVersion",
	"resources_vpc_config":      "description.Cluster.ResourcesVpcConfig",
	"role_arn":                  "description.Cluster.RoleArn",
	"status":                    "description.Cluster.Status",
	"tags":                      "description.Cluster.Tags",
	"title":                     "description.Cluster.Name",
	"version":                   "description.Cluster.Version",
}

func ListEKSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEKSClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEKSClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSCluster NewEKSClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEKSCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEKSClusterFilters = map[string]string{
	"arn":                       "description.Cluster.Arn",
	"certificate_authority":     "description.Cluster.CertificateAuthority",
	"created_at":                "description.Cluster.CreatedAt",
	"encryption_config":         "description.Cluster.EncryptionConfig",
	"endpoint":                  "description.Cluster.Endpoint",
	"identity":                  "description.Cluster.Identity",
	"og_account_id":             "metadata.SourceID",
	"kubernetes_network_config": "description.Cluster.KubernetesNetworkConfig",
	"logging":                   "description.Cluster.Logging",
	"name":                      "description.Cluster.Name",
	"platform_version":          "description.Cluster.PlatformVersion",
	"resources_vpc_config":      "description.Cluster.ResourcesVpcConfig",
	"role_arn":                  "description.Cluster.RoleArn",
	"status":                    "description.Cluster.Status",
	"tags":                      "description.Cluster.Tags",
	"title":                     "description.Cluster.Name",
	"version":                   "description.Cluster.Version",
}

func GetEKSCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEKSClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEKSClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EKSCluster =============================

// ==========================  START: EKSAddon =============================

type EKSAddon struct {
	Description   aws.EKSAddonDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type EKSAddonHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EKSAddon      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EKSAddonHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EKSAddonHit     `json:"hits"`
}

type EKSAddonSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  EKSAddonHits `json:"hits"`
}

type EKSAddonPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSAddonPaginator(filters []essdk.BoolFilter, limit *int64) (EKSAddonPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_addon", filters, limit)
	if err != nil {
		return EKSAddonPaginator{}, err
	}

	p := EKSAddonPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSAddonPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSAddonPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EKSAddonPaginator) NextPage(ctx context.Context) ([]EKSAddon, error) {
	var response EKSAddonSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSAddon
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSAddonFilters = map[string]string{
	"addon_name":               "description.Addon.AddonName",
	"addon_version":            "description.Addon.AddonVersion",
	"arn":                      "description.Addon.AddonArn",
	"cluster_name":             "description.Addon.ClusterName",
	"created_at":               "description.Addon.CreatedAt",
	"health_issues":            "description.Addon.Health.Issues",
	"og_account_id":            "metadata.SourceID",
	"modified_at":              "description.Addon.ModifiedAt",
	"service_account_role_arn": "description.Addon.ServiceAccountRoleArn",
	"status":                   "description.Addon.Status",
	"tags":                     "description.Addon.Tags",
	"title":                    "description.Addon.AddonName",
}

func ListEKSAddon(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSAddon")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddon NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddon NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddon GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddon GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddon GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEKSAddonPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEKSAddonFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddon NewEKSAddonPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEKSAddon paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEKSAddonFilters = map[string]string{
	"addon_name":               "description.Addon.AddonName",
	"addon_version":            "description.Addon.AddonVersion",
	"arn":                      "description.Addon.AddonArn",
	"cluster_name":             "description.Addon.ClusterName",
	"created_at":               "description.Addon.CreatedAt",
	"health_issues":            "description.Addon.Health.Issues",
	"og_account_id":            "metadata.SourceID",
	"modified_at":              "description.Addon.ModifiedAt",
	"service_account_role_arn": "description.Addon.ServiceAccountRoleArn",
	"status":                   "description.Addon.Status",
	"tags":                     "description.Addon.Tags",
	"title":                    "description.Addon.AddonName",
}

func GetEKSAddon(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSAddon")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEKSAddonPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEKSAddonFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EKSAddon =============================

// ==========================  START: EKSNodegroup =============================

type EKSNodegroup struct {
	Description   aws.EKSNodegroupDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type EKSNodegroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EKSNodegroup  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EKSNodegroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EKSNodegroupHit `json:"hits"`
}

type EKSNodegroupSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  EKSNodegroupHits `json:"hits"`
}

type EKSNodegroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSNodegroupPaginator(filters []essdk.BoolFilter, limit *int64) (EKSNodegroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_nodegroup", filters, limit)
	if err != nil {
		return EKSNodegroupPaginator{}, err
	}

	p := EKSNodegroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSNodegroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSNodegroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EKSNodegroupPaginator) NextPage(ctx context.Context) ([]EKSNodegroup, error) {
	var response EKSNodegroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSNodegroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSNodegroupFilters = map[string]string{
	"ami_type":        "description.Nodegroup.AmiType",
	"arn":             "description.Nodegroup.NodegroupArn",
	"capacity_type":   "description.Nodegroup.CapacityType",
	"cluster_name":    "description.Nodegroup.ClusterName",
	"created_at":      "description.Nodegroup.CreatedAt",
	"disk_size":       "description.Nodegroup.DiskSize",
	"health":          "description.Nodegroup.Health",
	"instance_types":  "description.Nodegroup.InstanceTypes",
	"og_account_id":   "metadata.SourceID",
	"labels":          "description.Nodegroup.Labels",
	"launch_template": "description.Nodegroup.LaunchTemplate",
	"modified_at":     "description.Nodegroup.ModifiedAt",
	"node_role":       "description.Nodegroup.NodeRole",
	"nodegroup_name":  "description.Nodegroup.NodegroupName",
	"release_version": "description.Nodegroup.ReleaseVersion",
	"remote_access":   "description.Nodegroup.RemoteAccess",
	"resources":       "description.Nodegroup.Resources",
	"scaling_config":  "description.Nodegroup.ScalingConfig",
	"status":          "description.Nodegroup.Status",
	"subnets":         "description.Nodegroup.Subnets",
	"tags":            "description.Nodegroup.Tags",
	"taints":          "description.Nodegroup.Taints",
	"title":           "description.Nodegroup.NodegroupName",
	"update_config":   "description.Nodegroup.UpdateConfig",
	"version":         "description.Nodegroup.Version",
}

func ListEKSNodegroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSNodegroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSNodegroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSNodegroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSNodegroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSNodegroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSNodegroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEKSNodegroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEKSNodegroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSNodegroup NewEKSNodegroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEKSNodegroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEKSNodegroupFilters = map[string]string{
	"ami_type":        "description.Nodegroup.AmiType",
	"arn":             "description.Nodegroup.NodegroupArn",
	"capacity_type":   "description.Nodegroup.CapacityType",
	"cluster_name":    "description.Nodegroup.ClusterName",
	"created_at":      "description.Nodegroup.CreatedAt",
	"disk_size":       "description.Nodegroup.DiskSize",
	"health":          "description.Nodegroup.Health",
	"instance_types":  "description.Nodegroup.InstanceTypes",
	"og_account_id":   "metadata.SourceID",
	"labels":          "description.Nodegroup.Labels",
	"launch_template": "description.Nodegroup.LaunchTemplate",
	"modified_at":     "description.Nodegroup.ModifiedAt",
	"node_role":       "description.Nodegroup.NodeRole",
	"nodegroup_name":  "description.Nodegroup.NodegroupName",
	"release_version": "description.Nodegroup.ReleaseVersion",
	"remote_access":   "description.Nodegroup.RemoteAccess",
	"resources":       "description.Nodegroup.Resources",
	"scaling_config":  "description.Nodegroup.ScalingConfig",
	"status":          "description.Nodegroup.Status",
	"subnets":         "description.Nodegroup.Subnets",
	"tags":            "description.Nodegroup.Tags",
	"taints":          "description.Nodegroup.Taints",
	"title":           "description.Nodegroup.NodegroupName",
	"update_config":   "description.Nodegroup.UpdateConfig",
	"version":         "description.Nodegroup.Version",
}

func GetEKSNodegroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSNodegroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEKSNodegroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEKSNodegroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EKSNodegroup =============================

// ==========================  START: EKSAddonVersion =============================

type EKSAddonVersion struct {
	Description   aws.EKSAddonVersionDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type EKSAddonVersionHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EKSAddonVersion `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EKSAddonVersionHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EKSAddonVersionHit `json:"hits"`
}

type EKSAddonVersionSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EKSAddonVersionHits `json:"hits"`
}

type EKSAddonVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSAddonVersionPaginator(filters []essdk.BoolFilter, limit *int64) (EKSAddonVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_addonversion", filters, limit)
	if err != nil {
		return EKSAddonVersionPaginator{}, err
	}

	p := EKSAddonVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSAddonVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSAddonVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EKSAddonVersionPaginator) NextPage(ctx context.Context) ([]EKSAddonVersion, error) {
	var response EKSAddonVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSAddonVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSAddonVersionFilters = map[string]string{
	"addon_configuration": "description.AddonConfiguration",
	"addon_name":          "description.AddonName",
	"addon_version":       "description.AddonVersion.AddonVersion",
	"architecture":        "description.AddonVersion.Architecture",
	"compatibilities":     "description.AddonVersion.Compatibilities",
	"og_account_id":       "metadata.SourceID",
	"title":               "description.AddonVersion.AddonVersion",
	"type":                "description.AddonType",
}

func ListEKSAddonVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSAddonVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddonVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddonVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddonVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddonVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddonVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEKSAddonVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEKSAddonVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSAddonVersion NewEKSAddonVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEKSAddonVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEKSAddonVersionFilters = map[string]string{
	"addon_configuration": "description.AddonConfiguration",
	"addon_name":          "description.AddonName",
	"addon_version":       "description.AddonVersion.AddonVersion",
	"architecture":        "description.AddonVersion.Architecture",
	"compatibilities":     "description.AddonVersion.Compatibilities",
	"og_account_id":       "metadata.SourceID",
	"title":               "description.AddonVersion.AddonVersion",
	"type":                "description.AddonType",
}

func GetEKSAddonVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSAddonVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEKSAddonVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEKSAddonVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EKSAddonVersion =============================

// ==========================  START: EKSFargateProfile =============================

type EKSFargateProfile struct {
	Description   aws.EKSFargateProfileDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EKSFargateProfileHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EKSFargateProfile `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EKSFargateProfileHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EKSFargateProfileHit `json:"hits"`
}

type EKSFargateProfileSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EKSFargateProfileHits `json:"hits"`
}

type EKSFargateProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEKSFargateProfilePaginator(filters []essdk.BoolFilter, limit *int64) (EKSFargateProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eks_fargateprofile", filters, limit)
	if err != nil {
		return EKSFargateProfilePaginator{}, err
	}

	p := EKSFargateProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EKSFargateProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EKSFargateProfilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EKSFargateProfilePaginator) NextPage(ctx context.Context) ([]EKSFargateProfile, error) {
	var response EKSFargateProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EKSFargateProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEKSFargateProfileFilters = map[string]string{
	"cluster_name":           "description.Fargate.ClusterName",
	"created_at":             "description.FargateProfile.CreatedAt",
	"fargate_profile_arn":    "description.FargateProfile.FargateProfileArn",
	"fargate_profile_name":   "description.FargateProfile.FargateProfileName",
	"og_account_id":          "metadata.SourceID",
	"pod_execution_role_arn": "description.FargateProfile.PodExecutionRoleArn",
	"selectors":              "description.FargateProfile.Selectors",
	"status":                 "description.FargateProfile.Status",
	"subnets":                "description.FargateProfile.Subnets",
	"tags":                   "description.FargateProfile.Tags",
	"title":                  "description.FargateProfile.FargateProfileName",
}

func ListEKSFargateProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEKSFargateProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSFargateProfile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSFargateProfile NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSFargateProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSFargateProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSFargateProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEKSFargateProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEKSFargateProfileFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEKSFargateProfile NewEKSFargateProfilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEKSFargateProfile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEKSFargateProfileFilters = map[string]string{
	"cluster_name":           "description.Fargate.ClusterName",
	"created_at":             "description.FargateProfile.CreatedAt",
	"fargate_profile_arn":    "description.FargateProfile.FargateProfileArn",
	"fargate_profile_name":   "description.Fargate.FargateProfileName",
	"og_account_id":          "metadata.SourceID",
	"pod_execution_role_arn": "description.FargateProfile.PodExecutionRoleArn",
	"selectors":              "description.FargateProfile.Selectors",
	"status":                 "description.FargateProfile.Status",
	"subnets":                "description.FargateProfile.Subnets",
	"tags":                   "description.FargateProfile.Tags",
	"title":                  "description.FargateProfile.FargateProfileName",
}

func GetEKSFargateProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEKSFargateProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEKSFargateProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEKSFargateProfileFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EKSFargateProfile =============================

// ==========================  START: WAFv2WebACL =============================

type WAFv2WebACL struct {
	Description   aws.WAFv2WebACLDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type WAFv2WebACLHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFv2WebACL   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFv2WebACLHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFv2WebACLHit  `json:"hits"`
}

type WAFv2WebACLSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  WAFv2WebACLHits `json:"hits"`
}

type WAFv2WebACLPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2WebACLPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2WebACLPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_webacl", filters, limit)
	if err != nil {
		return WAFv2WebACLPaginator{}, err
	}

	p := WAFv2WebACLPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2WebACLPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2WebACLPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFv2WebACLPaginator) NextPage(ctx context.Context) ([]WAFv2WebACL, error) {
	var response WAFv2WebACLSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2WebACL
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2WebACLFilters = map[string]string{
	"arn":                         "description.WebACL.ARN",
	"associated_resources":        "description.AssociatedResources",
	"capacity":                    "description.WebACL.Capacity",
	"default_action":              "description.WebACL.DefaultAction",
	"description":                 "description.WebACL.Description",
	"id":                          "description.WebACL.Id",
	"og_account_id":               "metadata.SourceID",
	"lock_token":                  "description.LockToken",
	"logging_configuration":       "description.LoggingConfiguration",
	"managed_by_firewall_manager": "description.WebACL.ManagedByFirewallManager",
	"name":                        "description.WebACL.Name",
	"post_process_firewall_manager_rule_groups": "description.WebACL.PostProcessFirewallManagerRuleGroups",
	"pre_process_firewall_manager_rule_groups":  "description.WebACL.PreProcessFirewallManagerRuleGroups",
	"rules":             "description.WebACL.Rules",
	"tags_src":          "description.TagInfoForResource.TagList",
	"title":             "description.WebACL.Name",
	"visibility_config": "description.WebACL.VisibilityConfig",
}

func ListWAFv2WebACL(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2WebACL")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2WebACL NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2WebACL NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2WebACL GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2WebACL GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2WebACL GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFv2WebACLPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFv2WebACLFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2WebACL NewWAFv2WebACLPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFv2WebACL paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFv2WebACLFilters = map[string]string{
	"arn":                         "description.WebACL.ARN",
	"associated_resources":        "description.AssociatedResources",
	"capacity":                    "description.WebACL.Capacity",
	"default_action":              "description.WebACL.DefaultAction",
	"description":                 "description.WebACL.Description",
	"id":                          "description.WebACL.Id",
	"og_account_id":               "metadata.SourceID",
	"lock_token":                  "description.LockToken",
	"logging_configuration":       "description.LoggingConfiguration",
	"managed_by_firewall_manager": "description.WebACL.ManagedByFirewallManager",
	"name":                        "description.WebACL.Name",
	"post_process_firewall_manager_rule_groups": "description.WebACL.PostProcessFirewallManagerRuleGroups",
	"pre_process_firewall_manager_rule_groups":  "description.WebACL.PreProcessFirewallManagerRuleGroups",
	"rules":             "description.WebACL.Rules",
	"scope":             "description.Scope",
	"tags_src":          "description.TagInfoForResource.TagList",
	"title":             "description.WebACL.Name",
	"visibility_config": "description.WebACL.VisibilityConfig",
}

func GetWAFv2WebACL(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2WebACL")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFv2WebACLPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFv2WebACLFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFv2WebACL =============================

// ==========================  START: WAFv2IPSet =============================

type WAFv2IPSet struct {
	Description   aws.WAFv2IPSetDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type WAFv2IPSetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFv2IPSet    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFv2IPSetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFv2IPSetHit   `json:"hits"`
}

type WAFv2IPSetSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  WAFv2IPSetHits `json:"hits"`
}

type WAFv2IPSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2IPSetPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2IPSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_ipset", filters, limit)
	if err != nil {
		return WAFv2IPSetPaginator{}, err
	}

	p := WAFv2IPSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2IPSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2IPSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFv2IPSetPaginator) NextPage(ctx context.Context) ([]WAFv2IPSet, error) {
	var response WAFv2IPSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2IPSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2IPSetFilters = map[string]string{
	"account_id":         "metadata.AccountID",
	"addresses":          "description.IPSet.Addresses",
	"arn":                "description.IPSet.ARN",
	"description":        "description.IPSet.Description",
	"id":                 "description.IPSet.Id",
	"ip_address_version": "description.IPSet.IPAddressVersion",
	"og_account_id":      "metadata.SourceID",
	"lock_token":         "description.IPSetSummary.LockToken",
	"name":               "description.IPSet.Name",
	"partition":          "metadata.Partition",
	"tags_src":           "description.Tags",
	"title":              "description.IPSet.Name",
}

func ListWAFv2IPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2IPSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2IPSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2IPSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2IPSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2IPSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2IPSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFv2IPSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFv2IPSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2IPSet NewWAFv2IPSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFv2IPSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFv2IPSetFilters = map[string]string{
	"account_id":         "metadata.AccountID",
	"addresses":          "description.IPSet.Addresses",
	"arn":                "description.IPSet.ARN",
	"description":        "description.IPSet.Description",
	"id":                 "description.IPSetSummary.Id",
	"ip_address_version": "description.IPSet.IPAddressVersion",
	"og_account_id":      "metadata.SourceID",
	"lock_token":         "description.IPSetSummary.LockToken",
	"name":               "description.IPSetSummary.Name",
	"partition":          "metadata.Partition",
	"scope":              "description.IPSetSummary.Scope",
	"tags_src":           "description.Tags",
	"title":              "description.IPSet.Name",
}

func GetWAFv2IPSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2IPSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFv2IPSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFv2IPSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFv2IPSet =============================

// ==========================  START: WAFv2RegexPatternSet =============================

type WAFv2RegexPatternSet struct {
	Description   aws.WAFv2RegexPatternSetDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type WAFv2RegexPatternSetHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  WAFv2RegexPatternSet `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type WAFv2RegexPatternSetHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []WAFv2RegexPatternSetHit `json:"hits"`
}

type WAFv2RegexPatternSetSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  WAFv2RegexPatternSetHits `json:"hits"`
}

type WAFv2RegexPatternSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2RegexPatternSetPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2RegexPatternSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_regexpatternset", filters, limit)
	if err != nil {
		return WAFv2RegexPatternSetPaginator{}, err
	}

	p := WAFv2RegexPatternSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2RegexPatternSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2RegexPatternSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFv2RegexPatternSetPaginator) NextPage(ctx context.Context) ([]WAFv2RegexPatternSet, error) {
	var response WAFv2RegexPatternSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2RegexPatternSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2RegexPatternSetFilters = map[string]string{
	"account_id":    "metadata.AccountID",
	"arn":           "description.RegexPatternSet.ARN",
	"description":   "description.RegexPatternSet.Description",
	"id":            "description.RegexPatternSet.Id",
	"og_account_id": "metadata.SourceID",
	"lock_token":    "description.RegexPatternSetSummary.LockToken",
	"name":          "description.RegexPatternSet.Name",
	"partition":     "metadata.Partition",
	"tags_src":      "description.Tags.TagInfoForResource.TagList",
	"title":         "description.RegexPatternSet.Name",
}

func ListWAFv2RegexPatternSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2RegexPatternSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RegexPatternSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RegexPatternSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RegexPatternSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RegexPatternSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RegexPatternSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFv2RegexPatternSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFv2RegexPatternSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RegexPatternSet NewWAFv2RegexPatternSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFv2RegexPatternSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFv2RegexPatternSetFilters = map[string]string{
	"account_id":    "metadata.AccountID",
	"arn":           "description.RegexPatternSet.ARN",
	"description":   "description.RegexPatternSet.Description",
	"id":            "description.IPSetSummary.Id",
	"og_account_id": "metadata.SourceID",
	"lock_token":    "description.RegexPatternSetSummary.LockToken",
	"name":          "description.IPSetSummary.Name",
	"partition":     "metadata.Partition",
	"scope":         "description.IPSetSummary.Scope",
	"tags_src":      "description.Tags.TagInfoForResource.TagList",
	"title":         "description.RegexPatternSet.Name",
}

func GetWAFv2RegexPatternSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2RegexPatternSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFv2RegexPatternSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFv2RegexPatternSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFv2RegexPatternSet =============================

// ==========================  START: WAFv2RuleGroup =============================

type WAFv2RuleGroup struct {
	Description   aws.WAFv2RuleGroupDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type WAFv2RuleGroupHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  WAFv2RuleGroup `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type WAFv2RuleGroupHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []WAFv2RuleGroupHit `json:"hits"`
}

type WAFv2RuleGroupSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  WAFv2RuleGroupHits `json:"hits"`
}

type WAFv2RuleGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFv2RuleGroupPaginator(filters []essdk.BoolFilter, limit *int64) (WAFv2RuleGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafv2_rulegroup", filters, limit)
	if err != nil {
		return WAFv2RuleGroupPaginator{}, err
	}

	p := WAFv2RuleGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFv2RuleGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFv2RuleGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFv2RuleGroupPaginator) NextPage(ctx context.Context) ([]WAFv2RuleGroup, error) {
	var response WAFv2RuleGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFv2RuleGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFv2RuleGroupFilters = map[string]string{
	"account_id":        "metadata.AccountID",
	"arn":               "description.RuleGroup.ARN",
	"capacity":          "description.RuleGroup.Capacity",
	"description":       "description.RuleGroup.Description",
	"id":                "description.RuleGroup.Id",
	"og_account_id":     "metadata.SourceID",
	"lock_token":        "description.RuleGroupSummary.LockToken",
	"name":              "description.RuleGroup.Name",
	"partition":         "metadata.Partition",
	"rules":             "description.RuleGroup.Rules",
	"tags_src":          "description.Tags.TagInfoForResource.TagList",
	"title":             "description.RuleGroup.Name",
	"visibility_config": "description.RuleGroup.VisibilityConfig",
}

func ListWAFv2RuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFv2RuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RuleGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RuleGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFv2RuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFv2RuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFv2RuleGroup NewWAFv2RuleGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFv2RuleGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFv2RuleGroupFilters = map[string]string{
	"account_id":        "metadata.AccountID",
	"arn":               "description.RuleGroup.ARN",
	"capacity":          "description.RuleGroup.Capacity",
	"description":       "description.RuleGroup.Description",
	"id":                "description.RuleGroup.Id",
	"og_account_id":     "metadata.SourceID",
	"lock_token":        "description.RuleGroupSummary.LockToken",
	"name":              "description.RuleGroup.Name",
	"partition":         "metadata.Partition",
	"rules":             "description.RuleGroup.Rules",
	"scope":             "description.Tags",
	"tags_src":          "description.Tags.TagInfoForResource.TagList",
	"title":             "description.RuleGroup.Name",
	"visibility_config": "description.RuleGroup.VisibilityConfig",
}

func GetWAFv2RuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFv2RuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFv2RuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFv2RuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFv2RuleGroup =============================

// ==========================  START: KMSKey =============================

type KMSKey struct {
	Description   aws.KMSKeyDescription `json:"description"`
	Metadata      aws.Metadata          `json:"metadata"`
	ResourceJobID int                   `json:"resource_job_id"`
	SourceJobID   int                   `json:"source_job_id"`
	ResourceType  string                `json:"resource_type"`
	SourceType    string                `json:"source_type"`
	ID            string                `json:"id"`
	ARN           string                `json:"arn"`
	SourceID      string                `json:"source_id"`
}

type KMSKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KMSKey        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KMSKeyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KMSKeyHit       `json:"hits"`
}

type KMSKeySearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  KMSKeyHits `json:"hits"`
}

type KMSKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKMSKeyPaginator(filters []essdk.BoolFilter, limit *int64) (KMSKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kms_key", filters, limit)
	if err != nil {
		return KMSKeyPaginator{}, err
	}

	p := KMSKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KMSKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KMSKeyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KMSKeyPaginator) NextPage(ctx context.Context) ([]KMSKey, error) {
	var response KMSKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KMSKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKMSKeyFilters = map[string]string{
	"aliases":                  "description.Aliases",
	"arn":                      "description.Metadata.Arn",
	"aws_account_id":           "description.Metadata.AWSAccountId",
	"creation_date":            "description.Metadata.CreationDate",
	"customer_master_key_spec": "description.Metadata.CustomerMasterKeySpec",
	"deletion_date":            "description.Metadata.DeletionDate",
	"description":              "description.Metadata.Description",
	"enabled":                  "description.Metadata.Enabled",
	"id":                       "description.Metadata.KeyId",
	"og_account_id":            "metadata.SourceID",
	"key_manager":              "description.Metadata.KeyManager",
	"key_rotation_enabled":     "description.KeyRotationEnabled",
	"key_state":                "description.Metadata.KeyState",
	"key_usage":                "description.Metadata.KeyUsage",
	"origin":                   "description.Metadata.Origin",
	"tags":                     "description.Tags",
	"tags_src":                 "description.Tags",
	"title":                    "description.Title",
	"valid_to":                 "description.Metadata.ValidTo",
}

func ListKMSKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKMSKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKey NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKey NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKMSKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKMSKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKey NewKMSKeyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKMSKey paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKMSKeyFilters = map[string]string{
	"aliases":                  "description.Aliases",
	"arn":                      "description.Metadata.Arn",
	"aws_account_id":           "description.Metadata.AWSAccountId",
	"creation_date":            "description.Metadata.CreationDate",
	"customer_master_key_spec": "description.Metadata.CustomerMasterKeySpec",
	"deletion_date":            "description.Metadata.DeletionDate",
	"description":              "description.Metadata.Description",
	"enabled":                  "description.Metadata.Enabled",
	"id":                       "description.Metadata.KeyId",
	"og_account_id":            "metadata.SourceID",
	"key_manager":              "description.Metadata.KeyManager",
	"key_rotation_enabled":     "description.KeyRotationEnabled",
	"key_state":                "description.Metadata.KeyState",
	"key_usage":                "description.Metadata.KeyUsage",
	"origin":                   "description.Metadata.Origin",
	"tags":                     "description.Tags",
	"tags_src":                 "description.Tags",
	"title":                    "description.Title",
	"valid_to":                 "description.Metadata.ValidTo",
}

func GetKMSKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKMSKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKMSKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKMSKeyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KMSKey =============================

// ==========================  START: KMSKeyRotation =============================

type KMSKeyRotation struct {
	Description   aws.KMSKeyRotationDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type KMSKeyRotationHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  KMSKeyRotation `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type KMSKeyRotationHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []KMSKeyRotationHit `json:"hits"`
}

type KMSKeyRotationSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  KMSKeyRotationHits `json:"hits"`
}

type KMSKeyRotationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKMSKeyRotationPaginator(filters []essdk.BoolFilter, limit *int64) (KMSKeyRotationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kms_keyrotation", filters, limit)
	if err != nil {
		return KMSKeyRotationPaginator{}, err
	}

	p := KMSKeyRotationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KMSKeyRotationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KMSKeyRotationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KMSKeyRotationPaginator) NextPage(ctx context.Context) ([]KMSKeyRotation, error) {
	var response KMSKeyRotationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KMSKeyRotation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKMSKeyRotationFilters = map[string]string{
	"key_arn":       "description.KeyArn",
	"key_id":        "description.KeyId",
	"rotation_date": "description.RotationDate",
	"rotation_type": "description.RotationType",
	"title":         "description.KeyId",
}

func ListKMSKeyRotation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKMSKeyRotation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKeyRotation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKeyRotation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKeyRotation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKeyRotation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKeyRotation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKMSKeyRotationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKMSKeyRotationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSKeyRotation NewKMSKeyRotationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKMSKeyRotation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKMSKeyRotationFilters = map[string]string{
	"key_arn":       "description.KeyArn",
	"key_id":        "description.KeyId",
	"rotation_date": "description.RotationDate",
	"rotation_type": "description.RotationType",
	"title":         "description.KeyId",
}

func GetKMSKeyRotation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKMSKeyRotation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKMSKeyRotationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKMSKeyRotationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KMSKeyRotation =============================

// ==========================  START: KMSAlias =============================

type KMSAlias struct {
	Description   aws.KMSAliasDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type KMSAliasHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KMSAlias      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KMSAliasHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KMSAliasHit     `json:"hits"`
}

type KMSAliasSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  KMSAliasHits `json:"hits"`
}

type KMSAliasPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKMSAliasPaginator(filters []essdk.BoolFilter, limit *int64) (KMSAliasPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kms_alias", filters, limit)
	if err != nil {
		return KMSAliasPaginator{}, err
	}

	p := KMSAliasPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KMSAliasPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KMSAliasPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KMSAliasPaginator) NextPage(ctx context.Context) ([]KMSAlias, error) {
	var response KMSAliasSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KMSAlias
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKMSAliasFilters = map[string]string{
	"alias_name":        "description.Alias.AliasName",
	"arn":               "description.Alias.AliasArn",
	"creation_date":     "description.Alias.CreationDate",
	"og_account_id":     "metadata.SourceID",
	"last_updated_date": "description.Alias.LastUpdatedDate",
	"target_key_id":     "description.Alias.TargetKeyId",
	"title":             "description.Alias.AliasName",
}

func ListKMSAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKMSAlias")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSAlias NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSAlias NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSAlias GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSAlias GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSAlias GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKMSAliasPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKMSAliasFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKMSAlias NewKMSAliasPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKMSAlias paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKMSAliasFilters = map[string]string{
	"alias_name":        "description.Alias.AliasName",
	"arn":               "description.Alias.AliasArn",
	"creation_date":     "description.Alias.CreationDate",
	"og_account_id":     "metadata.SourceID",
	"last_updated_date": "description.Alias.LastUpdatedDate",
	"target_key_id":     "description.Alias.TargetKeyId",
	"title":             "description.Alias.AliasName",
}

func GetKMSAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKMSAlias")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKMSAliasPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKMSAliasFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KMSAlias =============================

// ==========================  START: LambdaFunction =============================

type LambdaFunction struct {
	Description   aws.LambdaFunctionDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type LambdaFunctionHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  LambdaFunction `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type LambdaFunctionHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []LambdaFunctionHit `json:"hits"`
}

type LambdaFunctionSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  LambdaFunctionHits `json:"hits"`
}

type LambdaFunctionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaFunctionPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaFunctionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_function", filters, limit)
	if err != nil {
		return LambdaFunctionPaginator{}, err
	}

	p := LambdaFunctionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaFunctionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaFunctionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LambdaFunctionPaginator) NextPage(ctx context.Context) ([]LambdaFunction, error) {
	var response LambdaFunctionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaFunction
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaFunctionFilters = map[string]string{
	"architectures":                  "description.Function.Configuration.Architectures",
	"arn":                            "description.Function.Configuration.FunctionArn",
	"code":                           "description.Function.Code",
	"code_sha_256":                   "description.Function.Configuration.CodeSha256",
	"code_size":                      "description.Function.Configuration.CodeSize",
	"dead_letter_config_target_arn":  "description.Function.Configuration.DeadLetterConfig.TargetArn",
	"description":                    "description.Function.Configuration.Description",
	"environment_variables":          "description.Function.Configuration.Environment.Variables",
	"file_system_configs":            "description.Function.Configuration.FileSystemConfigs",
	"handler":                        "description.Function.Configuration.Handler",
	"og_account_id":                  "metadata.SourceID",
	"kms_key_arn":                    "description.Function.Configuration.KMSKeyArn",
	"last_modified":                  "description.Function.Configuration.LastModified",
	"last_update_status":             "description.Function.Configuration.LastUpdateStatus",
	"last_update_status_reason":      "description.Function.Configuration.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.Function.Configuration.LastUpdateStatusReasonCode",
	"layers":                         "description.Function.Configuration.Layers",
	"master_arn":                     "description.Function.Configuration.MasterArn",
	"memory_size":                    "description.Function.Configuration.MemorySize",
	"name":                           "description.Function.Configuration.FunctionName",
	"package_type":                   "description.Function.Configuration.PackageType",
	"policy":                         "description.Policy.Policy",
	"reserved_concurrent_executions": "description.Function.Concurrency.ReservedConcurrentExecutions",
	"revision_id":                    "description.Policy.RevisionId",
	"role":                           "description.Function.Configuration.Role",
	"runtime":                        "description.Function.Configuration.Runtime",
	"snap_start":                     "description.Function.Configuration.SnapStart",
	"state":                          "description.Function.Configuration.State",
	"state_reason":                   "description.Function.Configuration.StateReason",
	"state_reason_code":              "description.Function.Configuration.StateReasonCode",
	"tags":                           "description.Function.Tags",
	"timeout":                        "description.Function.Configuration.Timeout",
	"title":                          "description.Function.Configuration.FunctionName",
	"tracing_config":                 "description.Function.Configuration.TracingConfig",
	"url_config":                     "description.UrlConfig",
	"version":                        "description.Function.Configuration.Version",
	"vpc_id":                         "description.Function.Configuration.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.Function.Configuration.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.Function.Configuration.VpcConfig.SubnetIds",
}

func ListLambdaFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaFunction")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunction NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunction NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunction GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunction GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunction GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLambdaFunctionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLambdaFunctionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunction NewLambdaFunctionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLambdaFunction paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLambdaFunctionFilters = map[string]string{
	"architectures":                  "description.Function.Configuration.Architectures",
	"arn":                            "description.Function.Configuration.FunctionArn",
	"code":                           "description.Function.Code",
	"code_sha_256":                   "description.Function.Configuration.CodeSha256",
	"code_size":                      "description.Function.Configuration.CodeSize",
	"dead_letter_config_target_arn":  "description.Function.Configuration.DeadLetterConfig.TargetArn",
	"description":                    "description.Function.Configuration.Description",
	"environment_variables":          "description.Function.Configuration.Environment.Variables",
	"file_system_configs":            "description.Function.Configuration.FileSystemConfigs",
	"handler":                        "description.Function.Configuration.Handler",
	"og_account_id":                  "metadata.SourceID",
	"kms_key_arn":                    "description.Function.Configuration.KMSKeyArn",
	"last_modified":                  "description.Function.Configuration.LastModified",
	"last_update_status":             "description.Function.Configuration.LastUpdateStatus",
	"last_update_status_reason":      "description.Function.Configuration.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.Function.Configuration.LastUpdateStatusReasonCode",
	"layers":                         "description.Function.Configuration.Layers",
	"master_arn":                     "description.Function.Configuration.MasterArn",
	"memory_size":                    "description.Function.Configuration.MemorySize",
	"name":                           "description.Function.Configuration.FunctionName",
	"package_type":                   "description.Function.Configuration.PackageType",
	"policy":                         "description.Policy.Policy",
	"reserved_concurrent_executions": "description.Function.Concurrency.ReservedConcurrentExecutions",
	"revision_id":                    "description.Policy.RevisionId",
	"role":                           "description.Function.Configuration.Role",
	"runtime":                        "description.Function.Configuration.Runtime",
	"snap_start":                     "description.Function.Configuration.SnapStart",
	"state":                          "description.Function.Configuration.State",
	"state_reason":                   "description.Function.Configuration.StateReason",
	"state_reason_code":              "description.Function.Configuration.StateReasonCode",
	"tags":                           "description.Function.Tags",
	"timeout":                        "description.Function.Configuration.Timeout",
	"title":                          "description.Function.Configuration.FunctionName",
	"tracing_config":                 "description.Function.Configuration.TracingConfig",
	"url_config":                     "description.UrlConfig",
	"version":                        "description.Function.Configuration.Version",
	"vpc_id":                         "description.Function.Configuration.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.Function.Configuration.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.Function.Configuration.VpcConfig.SubnetIds",
}

func GetLambdaFunction(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaFunction")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLambdaFunctionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLambdaFunctionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LambdaFunction =============================

// ==========================  START: LambdaFunctionVersion =============================

type LambdaFunctionVersion struct {
	Description   aws.LambdaFunctionVersionDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type LambdaFunctionVersionHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  LambdaFunctionVersion `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type LambdaFunctionVersionHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []LambdaFunctionVersionHit `json:"hits"`
}

type LambdaFunctionVersionSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  LambdaFunctionVersionHits `json:"hits"`
}

type LambdaFunctionVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaFunctionVersionPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaFunctionVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_functionversion", filters, limit)
	if err != nil {
		return LambdaFunctionVersionPaginator{}, err
	}

	p := LambdaFunctionVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaFunctionVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaFunctionVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LambdaFunctionVersionPaginator) NextPage(ctx context.Context) ([]LambdaFunctionVersion, error) {
	var response LambdaFunctionVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaFunctionVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaFunctionVersionFilters = map[string]string{
	"architectures":                  "description.FunctionVersion.Architectures",
	"arn":                            "description.FunctionVersion.FunctionArn",
	"code_sha_256":                   "description.FunctionVersion.CodeSha256",
	"code_size":                      "description.FunctionVersion.CodeSize",
	"dead_letter_config":             "description.FunctionVersion.DeadLetterConfig",
	"description":                    "description.FunctionVersion.Description",
	"environment_variables":          "description.FunctionVersion.Environment.Variables",
	"ephemeral_storage_size":         "description.FunctionVersion.EphemeralStorage.Size",
	"file_system_configs":            "description.FunctionVersion.FileSystemConfigs",
	"function_name":                  "description.FunctionVersion.FunctionName",
	"handler":                        "description.FunctionVersion.Handler",
	"image_config_response":          "description.FunctionVersion.ImageConfigResponse",
	"og_account_id":                  "metadata.SourceID",
	"kms_key_arn":                    "description.FunctionVersion.KMSKeyArn",
	"last_modified":                  "description.FunctionVersion.LastModified",
	"last_update_status":             "description.FunctionVersion.LastUpdateStatus",
	"last_update_status_reason":      "description.FunctionVersion.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.FunctionVersion.LastUpdateStatusReasonCode",
	"layers":                         "description.FunctionVersion.Layers",
	"logging_config":                 "description.FunctionVersion.LoggingConfig",
	"master_arn":                     "description.FunctionVersion.MasterArn",
	"memory_size":                    "description.FunctionVersion.MemorySize",
	"policy":                         "description.Policy",
	"revision_id":                    "description.Policy.RevisionId",
	"role":                           "description.FunctionVersion.Role",
	"runtime":                        "description.FunctionVersion.Runtime",
	"runtime_version_config":         "description.FunctionVersion.RuntimeVersionConfig",
	"signing_job_arn":                "description.FunctionVersion.SigningJobArn",
	"signing_profile_version_arn":    "description.FunctionVersion.SigningProfileVersionArn",
	"snap_start":                     "description.FunctionVersion.SnapStart",
	"state":                          "description.FunctionVersion.State",
	"state_reason":                   "description.FunctionVersion.StateReason",
	"state_reason_code":              "description.FunctionVersion.StateReasonCode",
	"timeout":                        "description.FunctionVersion.Timeout",
	"title":                          "description.FunctionVersion",
	"tracing_config":                 "description.FunctionVersion.TracingConfig",
	"version":                        "description.FunctionVersion.Version",
	"vpc_id":                         "description.FunctionVersion.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.FunctionVersion.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.FunctionVersion.VpcConfig.SubnetIds",
}

func ListLambdaFunctionVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaFunctionVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunctionVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunctionVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunctionVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunctionVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunctionVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLambdaFunctionVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLambdaFunctionVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaFunctionVersion NewLambdaFunctionVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLambdaFunctionVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLambdaFunctionVersionFilters = map[string]string{
	"architectures":                  "description.FunctionVersion.Architectures",
	"arn":                            "description.FunctionVersion.FunctionArn",
	"code_sha_256":                   "description.FunctionVersion.CodeSha256",
	"code_size":                      "description.FunctionVersion.CodeSize",
	"dead_letter_config":             "description.FunctionVersion.DeadLetterConfig",
	"description":                    "description.FunctionVersion.Description",
	"environment_variables":          "description.FunctionVersion.Environment.Variables",
	"ephemeral_storage_size":         "description.FunctionVersion.EphemeralStorage.Size",
	"file_system_configs":            "description.FunctionVersion.FileSystemConfigs",
	"function_name":                  "description.FunctionVersion.FunctionName",
	"handler":                        "description.FunctionVersion.Handler",
	"image_config_response":          "description.FunctionVersion.ImageConfigResponse",
	"og_account_id":                  "metadata.SourceID",
	"kms_key_arn":                    "description.FunctionVersion.KMSKeyArn",
	"last_modified":                  "description.FunctionVersion.LastModified",
	"last_update_status":             "description.FunctionVersion.LastUpdateStatus",
	"last_update_status_reason":      "description.FunctionVersion.LastUpdateStatusReason",
	"last_update_status_reason_code": "description.FunctionVersion.LastUpdateStatusReasonCode",
	"layers":                         "description.FunctionVersion.Layers",
	"logging_config":                 "description.FunctionVersion.LoggingConfig",
	"master_arn":                     "description.FunctionVersion.MasterArn",
	"memory_size":                    "description.FunctionVersion.MemorySize",
	"policy":                         "description.Policy",
	"revision_id":                    "description.Policy.RevisionId",
	"role":                           "description.FunctionVersion.Role",
	"runtime":                        "description.FunctionVersion.Runtime",
	"runtime_version_config":         "description.FunctionVersion.RuntimeVersionConfig",
	"signing_job_arn":                "description.FunctionVersion.SigningJobArn",
	"signing_profile_version_arn":    "description.FunctionVersion.SigningProfileVersionArn",
	"snap_start":                     "description.FunctionVersion.SnapStart",
	"state":                          "description.FunctionVersion.State",
	"state_reason":                   "description.FunctionVersion.StateReason",
	"state_reason_code":              "description.FunctionVersion.StateReasonCode",
	"timeout":                        "description.FunctionVersion.Timeout",
	"title":                          "description.FunctionVersion",
	"tracing_config":                 "description.FunctionVersion.TracingConfig",
	"version":                        "description.FunctionVersion.Version",
	"vpc_id":                         "description.FunctionVersion.VpcConfig.VpcId",
	"vpc_security_group_ids":         "description.FunctionVersion.VpcConfig.SecurityGroupIds",
	"vpc_subnet_ids":                 "description.FunctionVersion.VpcConfig.SubnetIds",
}

func GetLambdaFunctionVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaFunctionVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLambdaFunctionVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLambdaFunctionVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LambdaFunctionVersion =============================

// ==========================  START: LambdaAlias =============================

type LambdaAlias struct {
	Description   aws.LambdaAliasDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type LambdaAliasHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LambdaAlias   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LambdaAliasHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LambdaAliasHit  `json:"hits"`
}

type LambdaAliasSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  LambdaAliasHits `json:"hits"`
}

type LambdaAliasPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaAliasPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaAliasPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_alias", filters, limit)
	if err != nil {
		return LambdaAliasPaginator{}, err
	}

	p := LambdaAliasPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaAliasPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaAliasPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LambdaAliasPaginator) NextPage(ctx context.Context) ([]LambdaAlias, error) {
	var response LambdaAliasSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaAlias
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaAliasFilters = map[string]string{
	"alias_arn":        "description.Alias.AliasArn",
	"description":      "description.Alias.Description",
	"function_name":    "description.FunctionName",
	"function_version": "description.Alias.FunctionVersion",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Alias.Name",
	"policy":           "description.Policy",
	"revision_id":      "description.Alias.RevisionId",
	"title":            "description.Alias.Name",
	"url_config":       "description.UrlConfig",
}

func ListLambdaAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaAlias")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaAlias NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaAlias NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaAlias GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaAlias GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaAlias GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLambdaAliasPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLambdaAliasFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaAlias NewLambdaAliasPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLambdaAlias paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLambdaAliasFilters = map[string]string{
	"alias_arn":        "description.Alias.AliasArn",
	"description":      "description.Alias.Description",
	"function_name":    "description.FunctionName",
	"function_version": "description.Alias.FunctionVersion",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Alias.Name",
	"policy":           "description.Policy",
	"region":           "description.Alias.AliasName",
	"revision_id":      "description.Alias.RevisionId",
	"title":            "description.Alias.Name",
	"url_config":       "description.UrlConfig",
}

func GetLambdaAlias(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaAlias")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLambdaAliasPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLambdaAliasFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LambdaAlias =============================

// ==========================  START: LambdaLayer =============================

type LambdaLayer struct {
	Description   aws.LambdaLayerDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type LambdaLayerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LambdaLayer   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LambdaLayerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LambdaLayerHit  `json:"hits"`
}

type LambdaLayerSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  LambdaLayerHits `json:"hits"`
}

type LambdaLayerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaLayerPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaLayerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_lambdalayer", filters, limit)
	if err != nil {
		return LambdaLayerPaginator{}, err
	}

	p := LambdaLayerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaLayerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaLayerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LambdaLayerPaginator) NextPage(ctx context.Context) ([]LambdaLayer, error) {
	var response LambdaLayerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaLayer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaLayerFilters = map[string]string{
	"compatible_architectures": "description.Layer.LatestMatchingVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.Layer.LatestMatchingVersion.CompatibleRuntimes",
	"created_date":             "description.Layer.LatestMatchingVersion.CreatedDate",
	"description":              "description.Layer.LatestMatchingVersion.Description",
	"og_account_id":            "metadata.SourceID",
	"layer_arn":                "description.Layer.LayerArn",
	"layer_name":               "description.Layer.LayerName",
	"layer_version_arn":        "description.Layer.LatestMatchingVersion.LayerVersionArn",
	"license_info":             "description.Layer.LatestMatchingVersion.LicenseInfo",
	"title":                    "description.Layer.LayerName",
	"version":                  "description.Layer.LatestMatchingVersion.Version",
}

func ListLambdaLayer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaLayer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLambdaLayerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLambdaLayerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayer NewLambdaLayerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLambdaLayer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLambdaLayerFilters = map[string]string{
	"compatible_architectures": "description.Layer.LatestMatchingVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.Layer.LatestMatchingVersion.CompatibleRuntimes",
	"created_date":             "description.Layer.LatestMatchingVersion.CreatedDate",
	"description":              "description.Layer.LatestMatchingVersion.Description",
	"og_account_id":            "metadata.SourceID",
	"layer_arn":                "description.Layer.LayerArn",
	"layer_name":               "description.Layer.LayerName",
	"layer_version_arn":        "description.Layer.LatestMatchingVersion.LayerVersionArn",
	"license_info":             "description.Layer.LatestMatchingVersion.LicenseInfo",
	"title":                    "description.Layer.LayerName",
	"version":                  "description.Layer.LatestMatchingVersion.Version",
}

func GetLambdaLayer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaLayer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLambdaLayerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLambdaLayerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LambdaLayer =============================

// ==========================  START: LambdaLayerVersion =============================

type LambdaLayerVersion struct {
	Description   aws.LambdaLayerVersionDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type LambdaLayerVersionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  LambdaLayerVersion `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type LambdaLayerVersionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []LambdaLayerVersionHit `json:"hits"`
}

type LambdaLayerVersionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  LambdaLayerVersionHits `json:"hits"`
}

type LambdaLayerVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLambdaLayerVersionPaginator(filters []essdk.BoolFilter, limit *int64) (LambdaLayerVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lambda_layerversion", filters, limit)
	if err != nil {
		return LambdaLayerVersionPaginator{}, err
	}

	p := LambdaLayerVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LambdaLayerVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LambdaLayerVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LambdaLayerVersionPaginator) NextPage(ctx context.Context) ([]LambdaLayerVersion, error) {
	var response LambdaLayerVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LambdaLayerVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLambdaLayerVersionFilters = map[string]string{
	"compatible_architectures": "description.LayerVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.LayerVersion.CompatibleRuntimes",
	"content":                  "description.LayerVersion.Content",
	"created_date":             "description.LayerVersion.CreatedDate",
	"description":              "description.LayerVersion.Description",
	"og_account_id":            "metadata.SourceID",
	"layer_arn":                "description.LayerVersion.LayerArn",
	"layer_name":               "description.LayerName",
	"layer_version_arn":        "description.LayerVersion.LayerVersionArn",
	"license_info":             "description.LayerVersion.LicenseInfo",
	"policy":                   "description.Policy",
	"revision_id":              "description.Policy.RevisionId",
	"title":                    "description.LayerName",
	"version":                  "description.LayerVersion.Version",
}

func ListLambdaLayerVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLambdaLayerVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayerVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayerVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayerVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayerVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayerVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLambdaLayerVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLambdaLayerVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLambdaLayerVersion NewLambdaLayerVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLambdaLayerVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLambdaLayerVersionFilters = map[string]string{
	"compatible_architectures": "description.LayerVersion.CompatibleArchitectures",
	"compatible_runtimes":      "description.LayerVersion.CompatibleRuntimes",
	"content":                  "description.LayerVersion.Content",
	"created_date":             "description.LayerVersion.CreatedDate",
	"description":              "description.LayerVersion.Description",
	"og_account_id":            "metadata.SourceID",
	"layer_arn":                "description.LayerVersion.LayerArn",
	"layer_name":               "description.LayerName",
	"layer_version_arn":        "description.LayerVersion.LayerVersionArn",
	"license_info":             "description.LayerVersion.LicenseInfo",
	"policy":                   "description.Policy",
	"revision_id":              "description.Policy.RevisionId",
	"title":                    "description.LayerName",
	"version":                  "description.LayerVersion.Version",
}

func GetLambdaLayerVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLambdaLayerVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLambdaLayerVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLambdaLayerVersionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LambdaLayerVersion =============================

// ==========================  START: S3AccessPoint =============================

type S3AccessPoint struct {
	Description   aws.S3AccessPointDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type S3AccessPointHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  S3AccessPoint `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type S3AccessPointHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []S3AccessPointHit `json:"hits"`
}

type S3AccessPointSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  S3AccessPointHits `json:"hits"`
}

type S3AccessPointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewS3AccessPointPaginator(filters []essdk.BoolFilter, limit *int64) (S3AccessPointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_s3_accesspoint", filters, limit)
	if err != nil {
		return S3AccessPointPaginator{}, err
	}

	p := S3AccessPointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p S3AccessPointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p S3AccessPointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p S3AccessPointPaginator) NextPage(ctx context.Context) ([]S3AccessPoint, error) {
	var response S3AccessPointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []S3AccessPoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listS3AccessPointFilters = map[string]string{
	"access_point_arn":              "arn",
	"access_point_policy_is_public": "description.PolicyStatus.IsPublic",
	"block_public_acls":             "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":           "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_name":                   "description.AccessPoint.Bucket",
	"creation_date":                 "description.AccessPoint.CreationDate",
	"ignore_public_acls":            "description.AccessPoint.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"og_account_id":                 "metadata.SourceID",
	"name":                          "description.AccessPoint.Name",
	"network_origin":                "description.AccessPoint.NetworkOrigin",
	"restrict_public_buckets":       "description.AccessPoint.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"title":                         "description.AccessPoint.Name",
	"vpc_id":                        "description.AccessPoint.VpcConfiguration.VpcId",
}

func ListS3AccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListS3AccessPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccessPoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccessPoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccessPoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewS3AccessPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listS3AccessPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListS3AccessPoint NewS3AccessPointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListS3AccessPoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getS3AccessPointFilters = map[string]string{
	"access_point_arn":              "arn",
	"access_point_policy_is_public": "description.PolicyStatus.IsPublic",
	"block_public_acls":             "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicAcls",
	"block_public_policy":           "description.AccessPoint.PublicAccessBlockConfiguration.BlockPublicPolicy",
	"bucket_name":                   "description.AccessPoint.Bucket",
	"creation_date":                 "description.AccessPoint.CreationDate",
	"ignore_public_acls":            "description.AccessPoint.PublicAccessBlockConfiguration.IgnorePublicAcls",
	"og_account_id":                 "metadata.SourceID",
	"name":                          "description.AccessPoint.Name",
	"network_origin":                "description.AccessPoint.NetworkOrigin",
	"region":                        "metadata.region",
	"restrict_public_buckets":       "description.AccessPoint.PublicAccessBlockConfiguration.RestrictPublicBuckets",
	"title":                         "description.AccessPoint.Name",
	"vpc_id":                        "description.AccessPoint.VpcConfiguration.VpcId",
}

func GetS3AccessPoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetS3AccessPoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewS3AccessPointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getS3AccessPointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: S3AccessPoint =============================

// ==========================  START: CostExplorerByAccountMonthly =============================

type CostExplorerByAccountMonthly struct {
	Description   aws.CostExplorerByAccountMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type CostExplorerByAccountMonthlyHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  CostExplorerByAccountMonthly `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type CostExplorerByAccountMonthlyHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []CostExplorerByAccountMonthlyHit `json:"hits"`
}

type CostExplorerByAccountMonthlySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  CostExplorerByAccountMonthlyHits `json:"hits"`
}

type CostExplorerByAccountMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByAccountMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByAccountMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byaccountmonthly", filters, limit)
	if err != nil {
		return CostExplorerByAccountMonthlyPaginator{}, err
	}

	p := CostExplorerByAccountMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByAccountMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByAccountMonthlyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByAccountMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByAccountMonthly, error) {
	var response CostExplorerByAccountMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByAccountMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByAccountMonthlyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func ListCostExplorerByAccountMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByAccountMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountMonthly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountMonthly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByAccountMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByAccountMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountMonthly NewCostExplorerByAccountMonthlyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByAccountMonthly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByAccountMonthlyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func GetCostExplorerByAccountMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByAccountMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByAccountMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByAccountMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByAccountMonthly =============================

// ==========================  START: CostExplorerByServiceMonthly =============================

type CostExplorerByServiceMonthly struct {
	Description   aws.CostExplorerByServiceMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type CostExplorerByServiceMonthlyHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  CostExplorerByServiceMonthly `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type CostExplorerByServiceMonthlyHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []CostExplorerByServiceMonthlyHit `json:"hits"`
}

type CostExplorerByServiceMonthlySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  CostExplorerByServiceMonthlyHits `json:"hits"`
}

type CostExplorerByServiceMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byservicemonthly", filters, limit)
	if err != nil {
		return CostExplorerByServiceMonthlyPaginator{}, err
	}

	p := CostExplorerByServiceMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceMonthlyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByServiceMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceMonthly, error) {
	var response CostExplorerByServiceMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceMonthlyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"service":       "description.Dimension1",
}

func ListCostExplorerByServiceMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceMonthly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceMonthly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByServiceMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByServiceMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceMonthly NewCostExplorerByServiceMonthlyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByServiceMonthly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByServiceMonthlyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"service":       "description.Dimension1",
}

func GetCostExplorerByServiceMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByServiceMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceMonthly =============================

// ==========================  START: CostExplorerByRecordTypeMonthly =============================

type CostExplorerByRecordTypeMonthly struct {
	Description   aws.CostExplorerByRecordTypeMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type CostExplorerByRecordTypeMonthlyHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  CostExplorerByRecordTypeMonthly `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type CostExplorerByRecordTypeMonthlyHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []CostExplorerByRecordTypeMonthlyHit `json:"hits"`
}

type CostExplorerByRecordTypeMonthlySearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  CostExplorerByRecordTypeMonthlyHits `json:"hits"`
}

type CostExplorerByRecordTypeMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByRecordTypeMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByRecordTypeMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byrecordtypemonthly", filters, limit)
	if err != nil {
		return CostExplorerByRecordTypeMonthlyPaginator{}, err
	}

	p := CostExplorerByRecordTypeMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByRecordTypeMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByRecordTypeMonthlyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByRecordTypeMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByRecordTypeMonthly, error) {
	var response CostExplorerByRecordTypeMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByRecordTypeMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByRecordTypeMonthlyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func ListCostExplorerByRecordTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByRecordTypeMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeMonthly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeMonthly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByRecordTypeMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByRecordTypeMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeMonthly NewCostExplorerByRecordTypeMonthlyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeMonthly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByRecordTypeMonthlyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func GetCostExplorerByRecordTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByRecordTypeMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByRecordTypeMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByRecordTypeMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByRecordTypeMonthly =============================

// ==========================  START: CostExplorerByServiceUsageTypeMonthly =============================

type CostExplorerByServiceUsageTypeMonthly struct {
	Description   aws.CostExplorerByServiceUsageTypeMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                                         `json:"metadata"`
	ResourceJobID int                                                  `json:"resource_job_id"`
	SourceJobID   int                                                  `json:"source_job_id"`
	ResourceType  string                                               `json:"resource_type"`
	SourceType    string                                               `json:"source_type"`
	ID            string                                               `json:"id"`
	ARN           string                                               `json:"arn"`
	SourceID      string                                               `json:"source_id"`
}

type CostExplorerByServiceUsageTypeMonthlyHit struct {
	ID      string                                `json:"_id"`
	Score   float64                               `json:"_score"`
	Index   string                                `json:"_index"`
	Type    string                                `json:"_type"`
	Version int64                                 `json:"_version,omitempty"`
	Source  CostExplorerByServiceUsageTypeMonthly `json:"_source"`
	Sort    []interface{}                         `json:"sort"`
}

type CostExplorerByServiceUsageTypeMonthlyHits struct {
	Total essdk.SearchTotal                          `json:"total"`
	Hits  []CostExplorerByServiceUsageTypeMonthlyHit `json:"hits"`
}

type CostExplorerByServiceUsageTypeMonthlySearchResponse struct {
	PitID string                                    `json:"pit_id"`
	Hits  CostExplorerByServiceUsageTypeMonthlyHits `json:"hits"`
}

type CostExplorerByServiceUsageTypeMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceUsageTypeMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceUsageTypeMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byusagetypemonthly", filters, limit)
	if err != nil {
		return CostExplorerByServiceUsageTypeMonthlyPaginator{}, err
	}

	p := CostExplorerByServiceUsageTypeMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceUsageTypeMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceUsageTypeMonthlyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByServiceUsageTypeMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceUsageTypeMonthly, error) {
	var response CostExplorerByServiceUsageTypeMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceUsageTypeMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceUsageTypeMonthlyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"service":       "dimension1",
	"usage_type":    "dimension2",
}

func ListCostExplorerByServiceUsageTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceUsageTypeMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeMonthly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeMonthly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByServiceUsageTypeMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByServiceUsageTypeMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeMonthly NewCostExplorerByServiceUsageTypeMonthlyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeMonthly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByServiceUsageTypeMonthlyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"service":       "dimension1",
	"usage_type":    "dimension2",
}

func GetCostExplorerByServiceUsageTypeMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceUsageTypeMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceUsageTypeMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByServiceUsageTypeMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceUsageTypeMonthly =============================

// ==========================  START: CostExplorerForcastMonthly =============================

type CostExplorerForcastMonthly struct {
	Description   aws.CostExplorerForcastMonthlyDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CostExplorerForcastMonthlyHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CostExplorerForcastMonthly `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CostExplorerForcastMonthlyHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CostExplorerForcastMonthlyHit `json:"hits"`
}

type CostExplorerForcastMonthlySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CostExplorerForcastMonthlyHits `json:"hits"`
}

type CostExplorerForcastMonthlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerForcastMonthlyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerForcastMonthlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_forcastmonthly", filters, limit)
	if err != nil {
		return CostExplorerForcastMonthlyPaginator{}, err
	}

	p := CostExplorerForcastMonthlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerForcastMonthlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerForcastMonthlyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerForcastMonthlyPaginator) NextPage(ctx context.Context) ([]CostExplorerForcastMonthly, error) {
	var response CostExplorerForcastMonthlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerForcastMonthly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerForcastMonthlyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"mean_value":    "description.MeanValue",
	"period_end":    "description.PeriodEnd",
	"period_start":  "description.PeriodStart",
}

func ListCostExplorerForcastMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerForcastMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastMonthly NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastMonthly NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastMonthly GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerForcastMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerForcastMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastMonthly NewCostExplorerForcastMonthlyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerForcastMonthly paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerForcastMonthlyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"mean_value":    "description.MeanValue",
	"period_end":    "description.PeriodEnd",
	"period_start":  "description.PeriodStart",
}

func GetCostExplorerForcastMonthly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerForcastMonthly")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerForcastMonthlyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerForcastMonthlyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerForcastMonthly =============================

// ==========================  START: CostExplorerByAccountDaily =============================

type CostExplorerByAccountDaily struct {
	Description   aws.CostExplorerByAccountDailyDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CostExplorerByAccountDailyHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CostExplorerByAccountDaily `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CostExplorerByAccountDailyHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CostExplorerByAccountDailyHit `json:"hits"`
}

type CostExplorerByAccountDailySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CostExplorerByAccountDailyHits `json:"hits"`
}

type CostExplorerByAccountDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByAccountDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByAccountDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byaccountdaily", filters, limit)
	if err != nil {
		return CostExplorerByAccountDailyPaginator{}, err
	}

	p := CostExplorerByAccountDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByAccountDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByAccountDailyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByAccountDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByAccountDaily, error) {
	var response CostExplorerByAccountDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByAccountDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByAccountDailyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func ListCostExplorerByAccountDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByAccountDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountDaily NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountDaily NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByAccountDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByAccountDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByAccountDaily NewCostExplorerByAccountDailyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByAccountDaily paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByAccountDailyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
}

func GetCostExplorerByAccountDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByAccountDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByAccountDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByAccountDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByAccountDaily =============================

// ==========================  START: CostExplorerByServiceDaily =============================

type CostExplorerByServiceDaily struct {
	Description   aws.CostExplorerByServiceDailyDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CostExplorerByServiceDailyHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CostExplorerByServiceDaily `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CostExplorerByServiceDailyHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CostExplorerByServiceDailyHit `json:"hits"`
}

type CostExplorerByServiceDailySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CostExplorerByServiceDailyHits `json:"hits"`
}

type CostExplorerByServiceDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byservicedaily", filters, limit)
	if err != nil {
		return CostExplorerByServiceDailyPaginator{}, err
	}

	p := CostExplorerByServiceDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceDailyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByServiceDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceDaily, error) {
	var response CostExplorerByServiceDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceDailyFilters = map[string]string{
	"cost_source":   "description.Dimension2",
	"og_account_id": "metadata.SourceID",
	"service":       "description.Dimension1",
}

func ListCostExplorerByServiceDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceDaily NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceDaily NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByServiceDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByServiceDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceDaily NewCostExplorerByServiceDailyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByServiceDaily paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByServiceDailyFilters = map[string]string{
	"cost_source":   "description.Dimension2",
	"og_account_id": "metadata.SourceID",
	"service":       "description.Dimension1",
}

func GetCostExplorerByServiceDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByServiceDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceDaily =============================

// ==========================  START: CostExplorerByRecordTypeDaily =============================

type CostExplorerByRecordTypeDaily struct {
	Description   aws.CostExplorerByRecordTypeDailyDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type CostExplorerByRecordTypeDailyHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  CostExplorerByRecordTypeDaily `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type CostExplorerByRecordTypeDailyHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []CostExplorerByRecordTypeDailyHit `json:"hits"`
}

type CostExplorerByRecordTypeDailySearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  CostExplorerByRecordTypeDailyHits `json:"hits"`
}

type CostExplorerByRecordTypeDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByRecordTypeDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByRecordTypeDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byrecordtypedaily", filters, limit)
	if err != nil {
		return CostExplorerByRecordTypeDailyPaginator{}, err
	}

	p := CostExplorerByRecordTypeDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByRecordTypeDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByRecordTypeDailyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByRecordTypeDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByRecordTypeDaily, error) {
	var response CostExplorerByRecordTypeDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByRecordTypeDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByRecordTypeDailyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func ListCostExplorerByRecordTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByRecordTypeDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeDaily NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeDaily NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByRecordTypeDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByRecordTypeDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeDaily NewCostExplorerByRecordTypeDailyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByRecordTypeDaily paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByRecordTypeDailyFilters = map[string]string{
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.Dimension1",
	"record_type":       "description.Dimension2",
}

func GetCostExplorerByRecordTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByRecordTypeDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByRecordTypeDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByRecordTypeDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByRecordTypeDaily =============================

// ==========================  START: CostExplorerByServiceUsageTypeDaily =============================

type CostExplorerByServiceUsageTypeDaily struct {
	Description   aws.CostExplorerByServiceUsageTypeDailyDescription `json:"description"`
	Metadata      aws.Metadata                                       `json:"metadata"`
	ResourceJobID int                                                `json:"resource_job_id"`
	SourceJobID   int                                                `json:"source_job_id"`
	ResourceType  string                                             `json:"resource_type"`
	SourceType    string                                             `json:"source_type"`
	ID            string                                             `json:"id"`
	ARN           string                                             `json:"arn"`
	SourceID      string                                             `json:"source_id"`
}

type CostExplorerByServiceUsageTypeDailyHit struct {
	ID      string                              `json:"_id"`
	Score   float64                             `json:"_score"`
	Index   string                              `json:"_index"`
	Type    string                              `json:"_type"`
	Version int64                               `json:"_version,omitempty"`
	Source  CostExplorerByServiceUsageTypeDaily `json:"_source"`
	Sort    []interface{}                       `json:"sort"`
}

type CostExplorerByServiceUsageTypeDailyHits struct {
	Total essdk.SearchTotal                        `json:"total"`
	Hits  []CostExplorerByServiceUsageTypeDailyHit `json:"hits"`
}

type CostExplorerByServiceUsageTypeDailySearchResponse struct {
	PitID string                                  `json:"pit_id"`
	Hits  CostExplorerByServiceUsageTypeDailyHits `json:"hits"`
}

type CostExplorerByServiceUsageTypeDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerByServiceUsageTypeDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerByServiceUsageTypeDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_byusagetypedaily", filters, limit)
	if err != nil {
		return CostExplorerByServiceUsageTypeDailyPaginator{}, err
	}

	p := CostExplorerByServiceUsageTypeDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerByServiceUsageTypeDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerByServiceUsageTypeDailyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerByServiceUsageTypeDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerByServiceUsageTypeDaily, error) {
	var response CostExplorerByServiceUsageTypeDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerByServiceUsageTypeDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerByServiceUsageTypeDailyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"service":       "dimension1",
	"usage_type":    "dimension2",
}

func ListCostExplorerByServiceUsageTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerByServiceUsageTypeDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeDaily NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeDaily NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerByServiceUsageTypeDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerByServiceUsageTypeDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeDaily NewCostExplorerByServiceUsageTypeDailyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerByServiceUsageTypeDaily paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerByServiceUsageTypeDailyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"service":       "dimension1",
	"usage_type":    "dimension2",
}

func GetCostExplorerByServiceUsageTypeDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerByServiceUsageTypeDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerByServiceUsageTypeDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerByServiceUsageTypeDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerByServiceUsageTypeDaily =============================

// ==========================  START: CostExplorerForcastDaily =============================

type CostExplorerForcastDaily struct {
	Description   aws.CostExplorerForcastDailyDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type CostExplorerForcastDailyHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  CostExplorerForcastDaily `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type CostExplorerForcastDailyHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []CostExplorerForcastDailyHit `json:"hits"`
}

type CostExplorerForcastDailySearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  CostExplorerForcastDailyHits `json:"hits"`
}

type CostExplorerForcastDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostExplorerForcastDailyPaginator(filters []essdk.BoolFilter, limit *int64) (CostExplorerForcastDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_costexplorer_forcastdaily", filters, limit)
	if err != nil {
		return CostExplorerForcastDailyPaginator{}, err
	}

	p := CostExplorerForcastDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostExplorerForcastDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostExplorerForcastDailyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostExplorerForcastDailyPaginator) NextPage(ctx context.Context) ([]CostExplorerForcastDaily, error) {
	var response CostExplorerForcastDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostExplorerForcastDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostExplorerForcastDailyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"mean_value":    "description.MeanValue",
	"period_end":    "description.PeriodEnd",
	"period_start":  "description.PeriodStart",
}

func ListCostExplorerForcastDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostExplorerForcastDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastDaily NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastDaily NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastDaily GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostExplorerForcastDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostExplorerForcastDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostExplorerForcastDaily NewCostExplorerForcastDailyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostExplorerForcastDaily paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostExplorerForcastDailyFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"mean_value":    "description.MeanValue",
	"period_end":    "description.PeriodEnd",
	"period_start":  "description.PeriodStart",
}

func GetCostExplorerForcastDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostExplorerForcastDaily")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostExplorerForcastDailyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostExplorerForcastDailyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostExplorerForcastDaily =============================

// ==========================  START: ECRRepository =============================

type ECRRepository struct {
	Description   aws.ECRRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type ECRRepositoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECRRepository `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECRRepositoryHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []ECRRepositoryHit `json:"hits"`
}

type ECRRepositorySearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  ECRRepositoryHits `json:"hits"`
}

type ECRRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (ECRRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_repository", filters, limit)
	if err != nil {
		return ECRRepositoryPaginator{}, err
	}

	p := ECRRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRRepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECRRepositoryPaginator) NextPage(ctx context.Context) ([]ECRRepository, error) {
	var response ECRRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRRepositoryFilters = map[string]string{
	"arn":                               "description.Repository.RepositoryArn",
	"created_at":                        "description.Repository.CreatedAt",
	"encryption_configuration":          "description.Repository.EncryptionConfiguration",
	"image_details":                     "description.ImageDetails",
	"image_scanning_configuration":      "description.Repository.ImageScanningConfiguration",
	"image_scanning_findings":           "description.ImageScanFinding",
	"image_tag_mutability":              "description.Repository.ImageTagMutability",
	"og_account_id":                     "metadata.SourceID",
	"last_evaluated_at":                 "description.LifecyclePolicy.LastEvaluatedAt",
	"lifecycle_policy":                  "description.LifecyclePolicy.LifecyclePolicyText",
	"policy":                            "description.Policy.PolicyText",
	"registry_id":                       "description.Repository.RegistryId",
	"repository_name":                   "description.Repository.RepositoryName",
	"repository_scanning_configuration": "description.RepositoryScanningConfiguration",
	"repository_uri":                    "description.Repository.RepositoryUri",
	"tags_src":                          "description.Tags",
	"title":                             "description.Repository.RepositoryName",
}

func ListECRRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECRRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECRRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRepository NewECRRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECRRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECRRepositoryFilters = map[string]string{
	"arn":                               "description.Repository.RepositoryArn",
	"created_at":                        "description.Repository.CreatedAt",
	"encryption_configuration":          "description.Repository.EncryptionConfiguration",
	"image_details":                     "description.ImageDetails",
	"image_scanning_configuration":      "description.Repository.ImageScanningConfiguration",
	"image_scanning_findings":           "description.ImageScanFinding",
	"image_tag_mutability":              "description.Repository.ImageTagMutability",
	"og_account_id":                     "metadata.SourceID",
	"last_evaluated_at":                 "description.LifecyclePolicy.LastEvaluatedAt",
	"lifecycle_policy":                  "description.LifecyclePolicy.LifecyclePolicyText",
	"policy":                            "description.Policy.PolicyText",
	"registry_id":                       "description.Repository.RegistryId",
	"repository_name":                   "description.Repository.RepositoryName",
	"repository_scanning_configuration": "description.RepositoryScanningConfiguration",
	"repository_uri":                    "description.Repository.RepositoryUri",
	"tags_src":                          "description.Tags",
	"title":                             "description.Repository.RepositoryName",
}

func GetECRRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECRRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECRRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECRRepository =============================

// ==========================  START: ECRImage =============================

type ECRImage struct {
	Description   aws.ECRImageDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type ECRImageHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECRImage      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECRImageHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECRImageHit     `json:"hits"`
}

type ECRImageSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ECRImageHits `json:"hits"`
}

type ECRImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRImagePaginator(filters []essdk.BoolFilter, limit *int64) (ECRImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_image", filters, limit)
	if err != nil {
		return ECRImagePaginator{}, err
	}

	p := ECRImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRImagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECRImagePaginator) NextPage(ctx context.Context) ([]ECRImage, error) {
	var response ECRImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRImage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRImageFilters = map[string]string{
	"artifact_media_type":         "description.Image.ArtifactMediaType",
	"image_digest":                "description.Image.ImageDigest",
	"image_manifest_media_type":   "description.Image.ImageManifestMediaType",
	"image_pushed_at":             "description.Image.ImagePushedAt",
	"image_scan_findings_summary": "description.Image.ImageScanFindingsSummary",
	"image_scan_status":           "description.Image.ImageScanStatus",
	"image_size_in_bytes":         "description.Image.ImageSizeInBytes",
	"image_tags":                  "description.Image.ImageTags",
	"image_uri":                   "description.ImageUri",
	"og_account_id":               "metadata.SourceID",
	"last_recorded_pull_time":     "description.Image.LastRecordedPullTime",
	"registry_id":                 "description.Image.RegistryId",
	"repository_name":             "description.Image.RepositoryName",
}

func ListECRImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRImage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRImage NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECRImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listECRImageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRImage NewECRImagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECRImage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECRImageFilters = map[string]string{
	"artifact_media_type":         "description.Image.ArtifactMediaType",
	"image_digest":                "description.Image.ImageDigest",
	"image_manifest_media_type":   "description.Image.ImageManifestMediaType",
	"image_pushed_at":             "description.Image.ImagePushedAt",
	"image_scan_findings_summary": "description.Image.ImageScanFindingsSummary",
	"image_scan_status":           "description.Image.ImageScanStatus",
	"image_size_in_bytes":         "description.Image.ImageSizeInBytes",
	"image_tags":                  "description.Image.ImageTags",
	"image_uri":                   "description.ImageUri",
	"og_account_id":               "metadata.SourceID",
	"last_recorded_pull_time":     "description.Image.LastRecordedPullTime",
	"registry_id":                 "description.Image.RegistryId",
	"repository_name":             "description.Image.RepositoryName",
}

func GetECRImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECRImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getECRImageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECRImage =============================

// ==========================  START: ECRPublicRepository =============================

type ECRPublicRepository struct {
	Description   aws.ECRPublicRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type ECRPublicRepositoryHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ECRPublicRepository `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ECRPublicRepositoryHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ECRPublicRepositoryHit `json:"hits"`
}

type ECRPublicRepositorySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ECRPublicRepositoryHits `json:"hits"`
}

type ECRPublicRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRPublicRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (ECRPublicRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_publicrepository", filters, limit)
	if err != nil {
		return ECRPublicRepositoryPaginator{}, err
	}

	p := ECRPublicRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRPublicRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRPublicRepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECRPublicRepositoryPaginator) NextPage(ctx context.Context) ([]ECRPublicRepository, error) {
	var response ECRPublicRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRPublicRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRPublicRepositoryFilters = map[string]string{
	"arn":             "description.PublicRepository.RepositoryArn",
	"created_at":      "description.PublicRepository.CreatedAt",
	"image_details":   "description.ImageDetails",
	"og_account_id":   "metadata.SourceID",
	"policy":          "description.Policy.PolicyText",
	"registry_id":     "description.PublicRepository.RegistryId",
	"repository_name": "description.PublicRepository.RepositoryName",
	"repository_uri":  "description.PublicRepository.RepositoryUri",
	"tags_src":        "description.Tags",
	"title":           "description.PublicRepository.RepositoryName",
}

func ListECRPublicRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRPublicRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECRPublicRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECRPublicRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRepository NewECRPublicRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECRPublicRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECRPublicRepositoryFilters = map[string]string{
	"arn":             "description.PublicRepository.RepositoryArn",
	"created_at":      "description.PublicRepository.CreatedAt",
	"image_details":   "description.ImageDetails",
	"og_account_id":   "metadata.SourceID",
	"policy":          "description.Policy.PolicyText",
	"registry_id":     "description.PublicRepository.RegistryId",
	"repository_name": "description.PublicRepository.RepositoryName",
	"repository_uri":  "description.PublicRepository.RepositoryUri",
	"tags_src":        "description.Tags",
	"title":           "description.PublicRepository.RepositoryName",
}

func GetECRPublicRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRPublicRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECRPublicRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECRPublicRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECRPublicRepository =============================

// ==========================  START: ECRPublicRegistry =============================

type ECRPublicRegistry struct {
	Description   aws.ECRPublicRegistryDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ECRPublicRegistryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ECRPublicRegistry `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ECRPublicRegistryHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ECRPublicRegistryHit `json:"hits"`
}

type ECRPublicRegistrySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ECRPublicRegistryHits `json:"hits"`
}

type ECRPublicRegistryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRPublicRegistryPaginator(filters []essdk.BoolFilter, limit *int64) (ECRPublicRegistryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_publicregistry", filters, limit)
	if err != nil {
		return ECRPublicRegistryPaginator{}, err
	}

	p := ECRPublicRegistryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRPublicRegistryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRPublicRegistryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECRPublicRegistryPaginator) NextPage(ctx context.Context) ([]ECRPublicRegistry, error) {
	var response ECRPublicRegistrySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRPublicRegistry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRPublicRegistryFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"registry_arn":  "description.PublicRegistry.RegistryArn",
	"registry_id":   "description.PublicRegistry.RegistryId",
	"title":         "description.PublicRegistry.RegistryId",
}

func ListECRPublicRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRPublicRegistry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRegistry NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRegistry NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECRPublicRegistryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECRPublicRegistryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRPublicRegistry NewECRPublicRegistryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECRPublicRegistry paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECRPublicRegistryFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"registry_arn":  "description.PublicRegistry.RegistryArn",
	"registry_id":   "description.PublicRegistry.RegistryId",
	"title":         "description.PublicRegistry.RegistryId",
}

func GetECRPublicRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRPublicRegistry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECRPublicRegistryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECRPublicRegistryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECRPublicRegistry =============================

// ==========================  START: ECRRegistry =============================

type ECRRegistry struct {
	Description   aws.ECRRegistryDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type ECRRegistryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ECRRegistry   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ECRRegistryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ECRRegistryHit  `json:"hits"`
}

type ECRRegistrySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  ECRRegistryHits `json:"hits"`
}

type ECRRegistryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRRegistryPaginator(filters []essdk.BoolFilter, limit *int64) (ECRRegistryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_registry", filters, limit)
	if err != nil {
		return ECRRegistryPaginator{}, err
	}

	p := ECRRegistryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRRegistryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRRegistryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECRRegistryPaginator) NextPage(ctx context.Context) ([]ECRRegistry, error) {
	var response ECRRegistrySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRRegistry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRRegistryFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"registry_id":   "description.RegistryId",
	"rules":         "description.ReplicationRules",
	"title":         "description.RegistryId",
}

func ListECRRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRRegistry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistry NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistry NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECRRegistryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECRRegistryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistry NewECRRegistryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECRRegistry paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECRRegistryFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"registry_id":   "description.Registry.RegistryId",
	"rules":         "description.ReplicationRules",
	"title":         "description.RegistryId",
}

func GetECRRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRRegistry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECRRegistryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECRRegistryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECRRegistry =============================

// ==========================  START: ECRRegistryScanningConfiguration =============================

type ECRRegistryScanningConfiguration struct {
	Description   aws.ECRRegistryScanningConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                                    `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type ECRRegistryScanningConfigurationHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  ECRRegistryScanningConfiguration `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type ECRRegistryScanningConfigurationHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []ECRRegistryScanningConfigurationHit `json:"hits"`
}

type ECRRegistryScanningConfigurationSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  ECRRegistryScanningConfigurationHits `json:"hits"`
}

type ECRRegistryScanningConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewECRRegistryScanningConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (ECRRegistryScanningConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ecr_registryscanningconfiguration", filters, limit)
	if err != nil {
		return ECRRegistryScanningConfigurationPaginator{}, err
	}

	p := ECRRegistryScanningConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ECRRegistryScanningConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ECRRegistryScanningConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ECRRegistryScanningConfigurationPaginator) NextPage(ctx context.Context) ([]ECRRegistryScanningConfiguration, error) {
	var response ECRRegistryScanningConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ECRRegistryScanningConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listECRRegistryScanningConfigurationFilters = map[string]string{
	"title": "registryid",
}

func ListECRRegistryScanningConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListECRRegistryScanningConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistryScanningConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistryScanningConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistryScanningConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistryScanningConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistryScanningConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewECRRegistryScanningConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listECRRegistryScanningConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListECRRegistryScanningConfiguration NewECRRegistryScanningConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListECRRegistryScanningConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getECRRegistryScanningConfigurationFilters = map[string]string{
	"title": "registryid",
}

func GetECRRegistryScanningConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetECRRegistryScanningConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewECRRegistryScanningConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getECRRegistryScanningConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ECRRegistryScanningConfiguration =============================

// ==========================  START: EventBridgeBus =============================

type EventBridgeBus struct {
	Description   aws.EventBridgeBusDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type EventBridgeBusHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EventBridgeBus `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EventBridgeBusHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EventBridgeBusHit `json:"hits"`
}

type EventBridgeBusSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EventBridgeBusHits `json:"hits"`
}

type EventBridgeBusPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventBridgeBusPaginator(filters []essdk.BoolFilter, limit *int64) (EventBridgeBusPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eventbridge_eventbus", filters, limit)
	if err != nil {
		return EventBridgeBusPaginator{}, err
	}

	p := EventBridgeBusPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventBridgeBusPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventBridgeBusPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EventBridgeBusPaginator) NextPage(ctx context.Context) ([]EventBridgeBus, error) {
	var response EventBridgeBusSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventBridgeBus
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventBridgeBusFilters = map[string]string{
	"arn":           "description.Bus.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Bus.Name",
	"policy":        "description.Bus.Policy",
	"tags_src":      "description.Tags",
	"title":         "description.Bus.Name",
}

func ListEventBridgeBus(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventBridgeBus")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeBus NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeBus NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeBus GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeBus GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeBus GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEventBridgeBusPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEventBridgeBusFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeBus NewEventBridgeBusPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEventBridgeBus paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEventBridgeBusFilters = map[string]string{
	"arn":           "description.Bus.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Bus.Name",
	"policy":        "description.Bus.Policy",
	"tags_src":      "description.Tags",
	"title":         "description.Bus.Name",
}

func GetEventBridgeBus(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventBridgeBus")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEventBridgeBusPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEventBridgeBusFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EventBridgeBus =============================

// ==========================  START: EventBridgeRule =============================

type EventBridgeRule struct {
	Description   aws.EventBridgeRuleDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type EventBridgeRuleHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EventBridgeRule `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EventBridgeRuleHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EventBridgeRuleHit `json:"hits"`
}

type EventBridgeRuleSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EventBridgeRuleHits `json:"hits"`
}

type EventBridgeRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventBridgeRulePaginator(filters []essdk.BoolFilter, limit *int64) (EventBridgeRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_eventbridge_eventrule", filters, limit)
	if err != nil {
		return EventBridgeRulePaginator{}, err
	}

	p := EventBridgeRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventBridgeRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventBridgeRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EventBridgeRulePaginator) NextPage(ctx context.Context) ([]EventBridgeRule, error) {
	var response EventBridgeRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventBridgeRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventBridgeRuleFilters = map[string]string{
	"arn":            "description.Rule.Arn",
	"created_by":     "description.Rule.CreatedBy",
	"description":    "description.Rule.Description",
	"event_bus_name": "description.Rule.EventBusName",
	"event_pattern":  "description.Rule.EventPattern",
	"og_account_id":  "metadata.SourceID",
	"managed_by":     "description.Rule.ManagedBy",
	"name":           "description.Rule.Name",
	"name_prefix":    "description.Rule.Name",
	"state":          "description.Rule.State",
	"tags_src":       "description.Tags",
	"targets":        "description.Targets",
	"title":          "description.Rule.Name",
}

func ListEventBridgeRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventBridgeRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEventBridgeRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEventBridgeRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventBridgeRule NewEventBridgeRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEventBridgeRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEventBridgeRuleFilters = map[string]string{
	"arn":            "description.Rule.Arn",
	"created_by":     "description.Rule.CreatedBy",
	"description":    "description.Rule.Description",
	"event_bus_name": "description.Rule.EventBusName",
	"event_pattern":  "description.Rule.EventPattern",
	"og_account_id":  "metadata.SourceID",
	"managed_by":     "description.Rule.ManagedBy",
	"name":           "description.Rule.Name",
	"name_prefix":    "description.Rule.Name",
	"state":          "description.Rule.State",
	"tags_src":       "description.Tags",
	"targets":        "description.Targets",
	"title":          "description.Rule.Name",
}

func GetEventBridgeRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventBridgeRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEventBridgeRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEventBridgeRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EventBridgeRule =============================

// ==========================  START: AppStreamApplication =============================

type AppStreamApplication struct {
	Description   aws.AppStreamApplicationDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AppStreamApplicationHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AppStreamApplication `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AppStreamApplicationHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AppStreamApplicationHit `json:"hits"`
}

type AppStreamApplicationSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AppStreamApplicationHits `json:"hits"`
}

type AppStreamApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppStreamApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (AppStreamApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appstream_application", filters, limit)
	if err != nil {
		return AppStreamApplicationPaginator{}, err
	}

	p := AppStreamApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppStreamApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppStreamApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppStreamApplicationPaginator) NextPage(ctx context.Context) ([]AppStreamApplication, error) {
	var response AppStreamApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppStreamApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppStreamApplicationFilters = map[string]string{
	"arn":           "description.Application.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Application.Name",
	"tags":          "description.Tags",
	"title":         "description.Application.Name",
}

func ListAppStreamApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppStreamApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppStreamApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppStreamApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamApplication NewAppStreamApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppStreamApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppStreamApplicationFilters = map[string]string{
	"arn":           "description.Application.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Application.Name",
	"tags":          "description.Tags",
	"title":         "description.Application.Name",
}

func GetAppStreamApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppStreamApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppStreamApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppStreamApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppStreamApplication =============================

// ==========================  START: AppStreamStack =============================

type AppStreamStack struct {
	Description   aws.AppStreamStackDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type AppStreamStackHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AppStreamStack `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AppStreamStackHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AppStreamStackHit `json:"hits"`
}

type AppStreamStackSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AppStreamStackHits `json:"hits"`
}

type AppStreamStackPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppStreamStackPaginator(filters []essdk.BoolFilter, limit *int64) (AppStreamStackPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appstream_stack", filters, limit)
	if err != nil {
		return AppStreamStackPaginator{}, err
	}

	p := AppStreamStackPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppStreamStackPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppStreamStackPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppStreamStackPaginator) NextPage(ctx context.Context) ([]AppStreamStack, error) {
	var response AppStreamStackSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppStreamStack
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppStreamStackFilters = map[string]string{
	"arn":           "description.Stack.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Stack.Name",
	"tags":          "description.Tags",
	"title":         "description.Stack.Name",
}

func ListAppStreamStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppStreamStack")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamStack NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamStack NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamStack GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamStack GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamStack GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppStreamStackPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppStreamStackFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamStack NewAppStreamStackPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppStreamStack paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppStreamStackFilters = map[string]string{
	"arn":           "description.Stack.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Stack.Name",
	"tags":          "description.Tags",
	"title":         "description.Stack.Name",
}

func GetAppStreamStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppStreamStack")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppStreamStackPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppStreamStackFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppStreamStack =============================

// ==========================  START: AppStreamFleet =============================

type AppStreamFleet struct {
	Description   aws.AppStreamFleetDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type AppStreamFleetHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AppStreamFleet `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AppStreamFleetHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AppStreamFleetHit `json:"hits"`
}

type AppStreamFleetSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AppStreamFleetHits `json:"hits"`
}

type AppStreamFleetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppStreamFleetPaginator(filters []essdk.BoolFilter, limit *int64) (AppStreamFleetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appstream_fleet", filters, limit)
	if err != nil {
		return AppStreamFleetPaginator{}, err
	}

	p := AppStreamFleetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppStreamFleetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppStreamFleetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppStreamFleetPaginator) NextPage(ctx context.Context) ([]AppStreamFleet, error) {
	var response AppStreamFleetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppStreamFleet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppStreamFleetFilters = map[string]string{
	"arn":                                    "description.Fleet.Arn",
	"compute_capacity_status":                "description.Fleet.ComputeCapacityStatus",
	"created_time":                           "description.Fleet.CreatedTime",
	"description":                            "description.Fleet.Description",
	"directory_name":                         "description.Fleet.DomainJoinInfo.DirectoryName",
	"disconnect_timeout_in_seconds":          "description.Fleet.DisconnectTimeoutInSeconds",
	"display_name":                           "description.Fleet.DisplayName",
	"enable_default_internet_access":         "description.Fleet.EnableDefaultInternetAccess",
	"fleet_errors":                           "description.Fleet.FleetErrors",
	"fleet_type":                             "description.Fleet.FleetType",
	"iam_role_arn":                           "description.Fleet.IamRoleArn",
	"idle_disconnect_timeout_in_seconds":     "description.Fleet.IdleDisconnectTimeoutInSeconds",
	"image_arn":                              "description.Fleet.ImageArn",
	"image_name":                             "description.Fleet.ImageName",
	"instance_type":                          "description.Fleet.InstanceType",
	"og_account_id":                          "metadata.SourceID",
	"max_concurrent_sessions":                "description.Fleet.MaxConcurrentSessions",
	"max_user_duration_in_seconds":           "description.Fleet.MaxUserDurationInSeconds",
	"name":                                   "description.Fleet.Name",
	"organizational_unit_distinguished_name": "description.Fleet.DomainJoinInfo.OrganizationalUnitDistinguishedName",
	"platform":                               "description.Fleet.Platform",
	"session_script_s3_location":             "description.Fleet.SessionScriptS3Location",
	"state":                                  "description.Fleet.State",
	"stream_view":                            "description.Fleet.StreamView",
	"tags":                                   "description.Tags",
	"title":                                  "description.Fleet.DisplayName",
	"usb_device_filter_strings":              "description.Fleet.UsbDeviceFilterStrings",
	"vpc_config":                             "description.Fleet.VpcConfig",
}

func ListAppStreamFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppStreamFleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamFleet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamFleet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamFleet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppStreamFleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppStreamFleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamFleet NewAppStreamFleetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppStreamFleet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppStreamFleetFilters = map[string]string{
	"arn":                                    "description.Fleet.Arn",
	"compute_capacity_status":                "description.Fleet.ComputeCapacityStatus",
	"created_time":                           "description.Fleet.CreatedTime",
	"description":                            "description.Fleet.Description",
	"directory_name":                         "description.Fleet.DomainJoinInfo.DirectoryName",
	"disconnect_timeout_in_seconds":          "description.Fleet.DisconnectTimeoutInSeconds",
	"display_name":                           "description.Fleet.DisplayName",
	"enable_default_internet_access":         "description.Fleet.EnableDefaultInternetAccess",
	"fleet_errors":                           "description.Fleet.FleetErrors",
	"fleet_type":                             "description.Fleet.FleetType",
	"iam_role_arn":                           "description.Fleet.IamRoleArn",
	"idle_disconnect_timeout_in_seconds":     "description.Fleet.IdleDisconnectTimeoutInSeconds",
	"image_arn":                              "description.Fleet.ImageArn",
	"image_name":                             "description.Fleet.ImageName",
	"instance_type":                          "description.Fleet.InstanceType",
	"og_account_id":                          "metadata.SourceID",
	"max_concurrent_sessions":                "description.Fleet.MaxConcurrentSessions",
	"max_user_duration_in_seconds":           "description.Fleet.MaxUserDurationInSeconds",
	"name":                                   "description.Fleet.Name",
	"organizational_unit_distinguished_name": "description.Fleet.DomainJoinInfo.OrganizationalUnitDistinguishedName",
	"platform":                               "description.Fleet.Platform",
	"session_script_s3_location":             "description.Fleet.SessionScriptS3Location",
	"state":                                  "description.Fleet.State",
	"stream_view":                            "description.Fleet.StreamView",
	"tags":                                   "description.Tags",
	"title":                                  "description.Fleet.DisplayName",
	"usb_device_filter_strings":              "description.Fleet.UsbDeviceFilterStrings",
	"vpc_config":                             "description.Fleet.VpcConfig",
}

func GetAppStreamFleet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppStreamFleet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppStreamFleetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppStreamFleetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppStreamFleet =============================

// ==========================  START: AppStreamImage =============================

type AppStreamImage struct {
	Description   aws.AppStreamImageDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type AppStreamImageHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AppStreamImage `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AppStreamImageHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AppStreamImageHit `json:"hits"`
}

type AppStreamImageSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AppStreamImageHits `json:"hits"`
}

type AppStreamImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppStreamImagePaginator(filters []essdk.BoolFilter, limit *int64) (AppStreamImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appstream_image", filters, limit)
	if err != nil {
		return AppStreamImagePaginator{}, err
	}

	p := AppStreamImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppStreamImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppStreamImagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppStreamImagePaginator) NextPage(ctx context.Context) ([]AppStreamImage, error) {
	var response AppStreamImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppStreamImage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppStreamImageFilters = map[string]string{
	"applications":                    "description.Image.Applications",
	"appstream_agent_version":         "description.Image.AppstreamAgentVersion",
	"arn":                             "description.Image.Arn",
	"base_image_arn":                  "description.Image.BaseImageArn",
	"created_time":                    "description.Image.CreatedTime",
	"description":                     "description.Image.Description",
	"display_name":                    "description.Image.DisplayName",
	"image_builder_name":              "description.Image.ImageBuilderName",
	"image_builder_supported":         "description.Image.ImageBuilderSupported",
	"image_errors":                    "description.Image.ImageErrors",
	"image_permissions":               "description.Image.ImagePermissions",
	"og_account_id":                   "metadata.SourceID",
	"name":                            "description.Image.Name",
	"platform":                        "description.Image.Platform",
	"public_base_image_released_date": "description.Image.PublicBaseImageReleasedDate",
	"state":                           "description.Image.State",
	"state_change_reason":             "description.Image.StateChangeReason",
	"tags":                            "description.Tags",
	"title":                           "description.Image.Name",
	"visibility":                      "description.Image.Visibility",
}

func ListAppStreamImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppStreamImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamImage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamImage NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppStreamImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppStreamImageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppStreamImage NewAppStreamImagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppStreamImage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppStreamImageFilters = map[string]string{
	"applications":                    "description.Image.Applications",
	"appstream_agent_version":         "description.Image.AppstreamAgentVersion",
	"arn":                             "description.Image.Arn",
	"base_image_arn":                  "description.Image.BaseImageArn",
	"created_time":                    "description.Image.CreatedTime",
	"description":                     "description.Image.Description",
	"display_name":                    "description.Image.DisplayName",
	"image_builder_name":              "description.Image.ImageBuilderName",
	"image_builder_supported":         "description.Image.ImageBuilderSupported",
	"image_errors":                    "description.Image.ImageErrors",
	"image_permissions":               "description.Image.ImagePermissions",
	"og_account_id":                   "metadata.SourceID",
	"name":                            "description.Image.Name",
	"platform":                        "description.Image.Platform",
	"public_base_image_released_date": "description.Image.PublicBaseImageReleasedDate",
	"state":                           "description.Image.State",
	"state_change_reason":             "description.Image.StateChangeReason",
	"tags":                            "description.Tags",
	"title":                           "description.Image.Name",
	"visibility":                      "description.Image.Visibility",
}

func GetAppStreamImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppStreamImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppStreamImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppStreamImageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppStreamImage =============================

// ==========================  START: AthenaWorkGroup =============================

type AthenaWorkGroup struct {
	Description   aws.AthenaWorkGroupDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type AthenaWorkGroupHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  AthenaWorkGroup `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type AthenaWorkGroupHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []AthenaWorkGroupHit `json:"hits"`
}

type AthenaWorkGroupSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  AthenaWorkGroupHits `json:"hits"`
}

type AthenaWorkGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAthenaWorkGroupPaginator(filters []essdk.BoolFilter, limit *int64) (AthenaWorkGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_athena_workgroup", filters, limit)
	if err != nil {
		return AthenaWorkGroupPaginator{}, err
	}

	p := AthenaWorkGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AthenaWorkGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AthenaWorkGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AthenaWorkGroupPaginator) NextPage(ctx context.Context) ([]AthenaWorkGroup, error) {
	var response AthenaWorkGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AthenaWorkGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAthenaWorkGroupFilters = map[string]string{
	"additional_configuration":           "description.WorkGroup.Configuration.AdditionalConfiguration",
	"bytes_scanned_cutoff_per_query":     "description.WorkGroup.Configuration.BytesScannedCutoffPerQuery",
	"creation_time":                      "description.WorkGroup.CreationTime",
	"customer_content_kms_key":           "description.WorkGroup.Configuration.CustomerContentEncryptionConfiguration.KmsKey",
	"description":                        "description.WorkGroup.Description",
	"effective_engine_version":           "description.WorkGroup.Configuration.EngineVersion.EffectiveEngineVersion",
	"encryption_option":                  "description.WorkGroup.Configuration.ResultConfiguration.EncryptionConfiguration.EncryptionOption",
	"enforce_workgroup_configuration":    "description.WorkGroup.Configuration.EnforceWorkGroupConfiguration",
	"execution_role":                     "description.WorkGroup.Configuration.ExecutionRole",
	"expected_bucket_owner":              "description.WorkGroup.Configuration.ResultConfiguration.ExpectedBucketOwner",
	"og_account_id":                      "metadata.SourceID",
	"name":                               "description.WorkGroup.Name",
	"output_location":                    "description.WorkGroup.Configuration.ResultConfiguration.OutputLocation",
	"publish_cloudwatch_metrics_enabled": "description.WorkGroup.Configuration.PublishCloudWatchMetricsEnabled",
	"requester_pays_enabled":             "description.WorkGroup.Configuration.RequesterPaysEnabled",
	"result_configuration_kms_key":       "description.WorkGroup.Configuration.ResultConfiguration.EncryptionConfiguration.KmsKey",
	"s3_acl_option":                      "description.WorkGroup.Configuration.ResultConfiguration.AclConfiguration.S3AclOption",
	"selected_engine_version":            "description.WorkGroup.Configuration.EngineVersion.SelectedEngineVersion",
}

func ListAthenaWorkGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAthenaWorkGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaWorkGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaWorkGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaWorkGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaWorkGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaWorkGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAthenaWorkGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAthenaWorkGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaWorkGroup NewAthenaWorkGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAthenaWorkGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAthenaWorkGroupFilters = map[string]string{
	"additional_configuration":           "description.WorkGroup.Configuration.AdditionalConfiguration",
	"bytes_scanned_cutoff_per_query":     "description.WorkGroup.Configuration.BytesScannedCutoffPerQuery",
	"creation_time":                      "description.WorkGroup.CreationTime",
	"customer_content_kms_key":           "description.WorkGroup.Configuration.CustomerContentEncryptionConfiguration.KmsKey",
	"description":                        "description.WorkGroup.Description",
	"effective_engine_version":           "description.WorkGroup.Configuration.EngineVersion.EffectiveEngineVersion",
	"encryption_option":                  "description.WorkGroup.Configuration.ResultConfiguration.EncryptionConfiguration.EncryptionOption",
	"enforce_workgroup_configuration":    "description.WorkGroup.Configuration.EnforceWorkGroupConfiguration",
	"execution_role":                     "description.WorkGroup.Configuration.ExecutionRole",
	"expected_bucket_owner":              "description.WorkGroup.Configuration.ResultConfiguration.ExpectedBucketOwner",
	"og_account_id":                      "metadata.SourceID",
	"name":                               "description.WorkGroup.Name",
	"output_location":                    "description.WorkGroup.Configuration.ResultConfiguration.OutputLocation",
	"publish_cloudwatch_metrics_enabled": "description.WorkGroup.Configuration.PublishCloudWatchMetricsEnabled",
	"requester_pays_enabled":             "description.WorkGroup.Configuration.RequesterPaysEnabled",
	"result_configuration_kms_key":       "description.WorkGroup.Configuration.ResultConfiguration.EncryptionConfiguration.KmsKey",
	"s3_acl_option":                      "description.WorkGroup.Configuration.ResultConfiguration.AclConfiguration.S3AclOption",
	"selected_engine_version":            "description.WorkGroup.Configuration.EngineVersion.SelectedEngineVersion",
}

func GetAthenaWorkGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAthenaWorkGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAthenaWorkGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAthenaWorkGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AthenaWorkGroup =============================

// ==========================  START: AthenaQueryExecution =============================

type AthenaQueryExecution struct {
	Description   aws.AthenaQueryExecutionDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AthenaQueryExecutionHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AthenaQueryExecution `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AthenaQueryExecutionHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AthenaQueryExecutionHit `json:"hits"`
}

type AthenaQueryExecutionSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AthenaQueryExecutionHits `json:"hits"`
}

type AthenaQueryExecutionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAthenaQueryExecutionPaginator(filters []essdk.BoolFilter, limit *int64) (AthenaQueryExecutionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_athena_queryexecution", filters, limit)
	if err != nil {
		return AthenaQueryExecutionPaginator{}, err
	}

	p := AthenaQueryExecutionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AthenaQueryExecutionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AthenaQueryExecutionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AthenaQueryExecutionPaginator) NextPage(ctx context.Context) ([]AthenaQueryExecution, error) {
	var response AthenaQueryExecutionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AthenaQueryExecution
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAthenaQueryExecutionFilters = map[string]string{
	"catalog":                                "description.QueryExecution.QueryExecutionContext.Catalog",
	"completion_date_time":                   "description.QueryExecution.Status.CompletionDateTime",
	"data_manifest_location":                 "description.QueryExecution.Statistics.DataManifestLocation",
	"data_scanned_in_bytes":                  "description.QueryExecution.Statistics.DataScannedInBytes",
	"database":                               "description.QueryExecution.QueryExecutionContext.Database",
	"effective_engine_version":               "description.QueryExecution.EngineVersion.EffectiveEngineVersion",
	"encryption_option":                      "description.QueryExecution.ResultConfiguration.EncryptionConfiguration.EncryptionOption",
	"engine_execution_time_in_millis":        "description.QueryExecution.Statistics.EngineExecutionTimeInMillis",
	"error_category":                         "description.QueryExecution.Status.AthenaError.ErrorCategory",
	"error_message":                          "description.QueryExecution.Status.AthenaError.ErrorMessage",
	"error_type":                             "description.QueryExecution.Status.AthenaError.ErrorType",
	"execution_parameters":                   "description.QueryExecution.ExecutionParameters",
	"expected_bucket_owner":                  "description.QueryExecution.ResultConfiguration.ExpectedBucketOwner",
	"id":                                     "description.QueryExecution.QueryExecutionId",
	"og_account_id":                          "metadata.SourceID",
	"kms_key":                                "description.QueryExecution.ResultConfiguration.EncryptionConfiguration.KmsKey",
	"output_location":                        "description.QueryExecution.ResultConfiguration.OutputLocation",
	"query":                                  "description.QueryExecution.Query",
	"query_planning_time_in_millis":          "description.QueryExecution.Statistics.QueryPlanningTimeInMillis",
	"query_queue_time_in_millis":             "description.QueryExecution.Statistics.QueryQueueTimeInMillis",
	"result_reuse_by_age_enabled":            "description.QueryExecution.ResultReuseConfiguration.ResultReuseByAgeConfiguration.Enabled",
	"result_reuse_by_age_mag_age_in_minutes": "description.QueryExecution.ResultReuseConfiguration.ResultReuseByAgeConfiguration.MaxAgeInMinutes",
	"retryable":                              "description.QueryExecution.Status.AthenaError.Retryable",
	"reused_previous_result":                 "description.QueryExecution.Statistics.ResultReuseInformation.ReusedPreviousResult",
	"s3_acl_option":                          "description.QueryExecution.ResultConfiguration.AclConfiguration.S3AclOption",
	"selected_engine_version":                "description.QueryExecution.EngineVersion.SelectedEngineVersion",
	"service_processing_time_in_millis":      "description.QueryExecution.Statistics.ServiceProcessingTimeInMillis",
	"state":                                  "description.QueryExecution.Status.State",
	"state_change_reason":                    "description.QueryExecution.Status.StateChangeReason",
	"statement_type":                         "description.QueryExecution.StatementType",
	"submission_date_time":                   "description.QueryExecution.Status.SubmissionDateTime",
	"substatement_type":                      "description.QueryExecution.SubstatementType",
	"total_execution_time_in_millis":         "description.QueryExecution.Statistics.TotalExecutionTimeInMillis",
	"workgroup":                              "description.QueryExecution.WorkGroup",
}

func ListAthenaQueryExecution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAthenaQueryExecution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaQueryExecution NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaQueryExecution NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaQueryExecution GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaQueryExecution GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaQueryExecution GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAthenaQueryExecutionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAthenaQueryExecutionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAthenaQueryExecution NewAthenaQueryExecutionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAthenaQueryExecution paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAthenaQueryExecutionFilters = map[string]string{
	"catalog":                                "description.QueryExecution.QueryExecutionContext.Catalog",
	"completion_date_time":                   "description.QueryExecution.Status.CompletionDateTime",
	"data_manifest_location":                 "description.QueryExecution.Statistics.DataManifestLocation",
	"data_scanned_in_bytes":                  "description.QueryExecution.Statistics.DataScannedInBytes",
	"database":                               "description.QueryExecution.QueryExecutionContext.Database",
	"effective_engine_version":               "description.QueryExecution.EngineVersion.EffectiveEngineVersion",
	"encryption_option":                      "description.QueryExecution.ResultConfiguration.EncryptionConfiguration.EncryptionOption",
	"engine_execution_time_in_millis":        "description.QueryExecution.Statistics.EngineExecutionTimeInMillis",
	"error_category":                         "description.QueryExecution.Status.AthenaError.ErrorCategory",
	"error_message":                          "description.QueryExecution.Status.AthenaError.ErrorMessage",
	"error_type":                             "description.QueryExecution.Status.AthenaError.ErrorType",
	"execution_parameters":                   "description.QueryExecution.ExecutionParameters",
	"expected_bucket_owner":                  "description.QueryExecution.ResultConfiguration.ExpectedBucketOwner",
	"id":                                     "description.QueryExecution.QueryExecutionId",
	"og_account_id":                          "metadata.SourceID",
	"kms_key":                                "description.QueryExecution.ResultConfiguration.EncryptionConfiguration.KmsKey",
	"name":                                   "description.QueryExecution.Query",
	"output_location":                        "description.QueryExecution.ResultConfiguration.OutputLocation",
	"query":                                  "description.QueryExecution.Query",
	"query_planning_time_in_millis":          "description.QueryExecution.Statistics.QueryPlanningTimeInMillis",
	"query_queue_time_in_millis":             "description.QueryExecution.Statistics.QueryQueueTimeInMillis",
	"result_reuse_by_age_enabled":            "description.QueryExecution.ResultReuseConfiguration.ResultReuseByAgeConfiguration.Enabled",
	"result_reuse_by_age_mag_age_in_minutes": "description.QueryExecution.ResultReuseConfiguration.ResultReuseByAgeConfiguration.MaxAgeInMinutes",
	"retryable":                              "description.QueryExecution.Status.AthenaError.Retryable",
	"reused_previous_result":                 "description.QueryExecution.Statistics.ResultReuseInformation.ReusedPreviousResult",
	"s3_acl_option":                          "description.QueryExecution.ResultConfiguration.AclConfiguration.S3AclOption",
	"selected_engine_version":                "description.QueryExecution.EngineVersion.SelectedEngineVersion",
	"service_processing_time_in_millis":      "description.QueryExecution.Statistics.ServiceProcessingTimeInMillis",
	"state":                                  "description.QueryExecution.Status.State",
	"state_change_reason":                    "description.QueryExecution.Status.StateChangeReason",
	"statement_type":                         "description.QueryExecution.StatementType",
	"submission_date_time":                   "description.QueryExecution.Status.SubmissionDateTime",
	"substatement_type":                      "description.QueryExecution.SubstatementType",
	"total_execution_time_in_millis":         "description.QueryExecution.Statistics.TotalExecutionTimeInMillis",
	"workgroup":                              "description.QueryExecution.WorkGroup",
}

func GetAthenaQueryExecution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAthenaQueryExecution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAthenaQueryExecutionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAthenaQueryExecutionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AthenaQueryExecution =============================

// ==========================  START: KinesisStream =============================

type KinesisStream struct {
	Description   aws.KinesisStreamDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type KinesisStreamHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KinesisStream `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KinesisStreamHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []KinesisStreamHit `json:"hits"`
}

type KinesisStreamSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  KinesisStreamHits `json:"hits"`
}

type KinesisStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisStreamPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesis_stream", filters, limit)
	if err != nil {
		return KinesisStreamPaginator{}, err
	}

	p := KinesisStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisStreamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KinesisStreamPaginator) NextPage(ctx context.Context) ([]KinesisStream, error) {
	var response KinesisStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisStreamFilters = map[string]string{
	"consumer_count":            "description.DescriptionSummary.ConsumerCount",
	"encryption_type":           "description.Stream.EncryptionType",
	"enhanced_monitoring":       "description.Stream.EnhancedMonitoring",
	"has_more_shards":           "description.Stream.HasMoreShards",
	"og_account_id":             "metadata.SourceID",
	"key_id":                    "description.Stream.KeyId",
	"open_shard_count":          "description.DescriptionSummary.OpenShardCount",
	"retention_period_hours":    "description.Stream.RetentionPeriodHours",
	"shards":                    "description.Stream.Shards",
	"stream_arn":                "description.Stream.StreamARN",
	"stream_creation_timestamp": "description.Stream.StreamCreationTimestamp",
	"stream_name":               "description.Stream.StreamName",
	"stream_status":             "description.Stream.StreamStatus",
	"tags_src":                  "description.Tags",
	"title":                     "description.Stream.StreamName",
}

func ListKinesisStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisStream NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisStream NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKinesisStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKinesisStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisStream NewKinesisStreamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKinesisStream paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKinesisStreamFilters = map[string]string{
	"consumer_count":            "description.DescriptionSummary.ConsumerCount",
	"encryption_type":           "description.Stream.EncryptionType",
	"enhanced_monitoring":       "description.Stream.EnhancedMonitoring",
	"has_more_shards":           "description.Stream.HasMoreShards",
	"og_account_id":             "metadata.SourceID",
	"key_id":                    "description.Stream.KeyId",
	"open_shard_count":          "description.DescriptionSummary.OpenShardCount",
	"retention_period_hours":    "description.Stream.RetentionPeriodHours",
	"shards":                    "description.Stream.Shards",
	"stream_arn":                "description.Stream.StreamARN",
	"stream_creation_timestamp": "description.Stream.StreamCreationTimestamp",
	"stream_name":               "description.Stream.StreamName",
	"stream_status":             "description.Stream.StreamStatus",
	"tags_src":                  "description.Tags",
	"title":                     "description.Stream.StreamName",
}

func GetKinesisStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKinesisStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKinesisStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KinesisStream =============================

// ==========================  START: KinesisVideoStream =============================

type KinesisVideoStream struct {
	Description   aws.KinesisVideoStreamDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type KinesisVideoStreamHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  KinesisVideoStream `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type KinesisVideoStreamHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []KinesisVideoStreamHit `json:"hits"`
}

type KinesisVideoStreamSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  KinesisVideoStreamHits `json:"hits"`
}

type KinesisVideoStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisVideoStreamPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisVideoStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesisvideo_stream", filters, limit)
	if err != nil {
		return KinesisVideoStreamPaginator{}, err
	}

	p := KinesisVideoStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisVideoStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisVideoStreamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KinesisVideoStreamPaginator) NextPage(ctx context.Context) ([]KinesisVideoStream, error) {
	var response KinesisVideoStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisVideoStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisVideoStreamFilters = map[string]string{
	"creation_time":           "description.Stream.CreationTime",
	"data_retention_in_hours": "description.Stream.DataRetentionInHours",
	"device_name":             "description.Stream.DeviceName",
	"og_account_id":           "metadata.SourceID",
	"kms_key_id":              "description.Stream.KmsKeyId",
	"media_type":              "description.Stream.MediaType",
	"status":                  "description.Stream.Status",
	"stream_arn":              "description.Stream.StreamARN",
	"stream_name":             "description.Stream.StreamName",
	"tags":                    "description.Tags",
	"title":                   "description.Stream.StreamName",
	"version":                 "description.Stream.Version",
}

func ListKinesisVideoStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisVideoStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisVideoStream NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisVideoStream NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisVideoStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisVideoStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisVideoStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKinesisVideoStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKinesisVideoStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisVideoStream NewKinesisVideoStreamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKinesisVideoStream paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKinesisVideoStreamFilters = map[string]string{
	"creation_time":           "description.Stream.CreationTime",
	"data_retention_in_hours": "description.Stream.DataRetentionInHours",
	"device_name":             "description.Stream.DeviceName",
	"og_account_id":           "metadata.SourceID",
	"kms_key_id":              "description.Stream.KmsKeyId",
	"media_type":              "description.Stream.MediaType",
	"status":                  "description.Stream.Status",
	"stream_arn":              "description.Stream.StreamARN",
	"stream_name":             "description.Stream.StreamName",
	"tags":                    "description.Tags",
	"title":                   "description.Stream.StreamName",
	"version":                 "description.Stream.Version",
}

func GetKinesisVideoStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisVideoStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKinesisVideoStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKinesisVideoStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KinesisVideoStream =============================

// ==========================  START: KinesisConsumer =============================

type KinesisConsumer struct {
	Description   aws.KinesisConsumerDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type KinesisConsumerHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  KinesisConsumer `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type KinesisConsumerHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []KinesisConsumerHit `json:"hits"`
}

type KinesisConsumerSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  KinesisConsumerHits `json:"hits"`
}

type KinesisConsumerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisConsumerPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisConsumerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesis_consumer", filters, limit)
	if err != nil {
		return KinesisConsumerPaginator{}, err
	}

	p := KinesisConsumerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisConsumerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisConsumerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KinesisConsumerPaginator) NextPage(ctx context.Context) ([]KinesisConsumer, error) {
	var response KinesisConsumerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisConsumer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisConsumerFilters = map[string]string{
	"consumer_arn":                "description.Consumer.ConsumerARN",
	"consumer_creation_timestamp": "description.Consumer.ConsumerCreationTimestamp",
	"consumer_name":               "description.Consumer.ConsumerName",
	"consumer_status":             "description.Consumer.ConsumerStatus",
	"og_account_id":               "metadata.SourceID",
	"stream_arn":                  "description.StreamARN",
	"title":                       "description.Consumer.ConsumerName",
}

func ListKinesisConsumer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisConsumer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisConsumer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisConsumer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisConsumer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisConsumer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisConsumer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKinesisConsumerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKinesisConsumerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisConsumer NewKinesisConsumerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKinesisConsumer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKinesisConsumerFilters = map[string]string{
	"consumer_arn":                "description.Consumer.ConsumerARN",
	"consumer_creation_timestamp": "description.Consumer.ConsumerCreationTimestamp",
	"consumer_name":               "description.Consumer.ConsumerName",
	"consumer_status":             "description.Consumer.ConsumerStatus",
	"og_account_id":               "metadata.SourceID",
	"stream_arn":                  "description.StreamARN",
	"title":                       "description.Consumer.ConsumerName",
}

func GetKinesisConsumer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisConsumer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKinesisConsumerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKinesisConsumerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KinesisConsumer =============================

// ==========================  START: KinesisAnalyticsV2Application =============================

type KinesisAnalyticsV2Application struct {
	Description   aws.KinesisAnalyticsV2ApplicationDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type KinesisAnalyticsV2ApplicationHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  KinesisAnalyticsV2Application `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type KinesisAnalyticsV2ApplicationHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []KinesisAnalyticsV2ApplicationHit `json:"hits"`
}

type KinesisAnalyticsV2ApplicationSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  KinesisAnalyticsV2ApplicationHits `json:"hits"`
}

type KinesisAnalyticsV2ApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKinesisAnalyticsV2ApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (KinesisAnalyticsV2ApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kinesisanalyticsv2_application", filters, limit)
	if err != nil {
		return KinesisAnalyticsV2ApplicationPaginator{}, err
	}

	p := KinesisAnalyticsV2ApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KinesisAnalyticsV2ApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KinesisAnalyticsV2ApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KinesisAnalyticsV2ApplicationPaginator) NextPage(ctx context.Context) ([]KinesisAnalyticsV2Application, error) {
	var response KinesisAnalyticsV2ApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KinesisAnalyticsV2Application
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKinesisAnalyticsV2ApplicationFilters = map[string]string{
	"application_arn":                         "description.Application.ApplicationARN",
	"application_configuration_description":   "description.Application.ApplicationConfigurationDescription",
	"application_description":                 "description.Application.ApplicationDescription",
	"application_name":                        "description.Application.ApplicationName",
	"application_status":                      "description.Application.ApplicationStatus",
	"application_version_id":                  "description.Application.ApplicationVersionId",
	"cloud_watch_logging_option_descriptions": "description.Application.CloudWatchLoggingOptionDescriptions",
	"create_timestamp":                        "description.Application.CreateTimestamp",
	"og_account_id":                           "metadata.SourceID",
	"last_update_timestamp":                   "description.Application.LastUpdateTimestamp",
	"runtime_environment":                     "description.Application.RuntimeEnvironment",
	"service_execution_role":                  "description.Application.ServiceExecutionRole",
	"tags_src":                                "description.Tags",
	"title":                                   "description.Application.ApplicationName",
}

func ListKinesisAnalyticsV2Application(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKinesisAnalyticsV2Application")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisAnalyticsV2Application NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisAnalyticsV2Application NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisAnalyticsV2Application GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisAnalyticsV2Application GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisAnalyticsV2Application GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKinesisAnalyticsV2ApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKinesisAnalyticsV2ApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKinesisAnalyticsV2Application NewKinesisAnalyticsV2ApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKinesisAnalyticsV2Application paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKinesisAnalyticsV2ApplicationFilters = map[string]string{
	"application_arn":                         "description.Application.ApplicationARN",
	"application_configuration_description":   "description.Application.ApplicationConfigurationDescription",
	"application_description":                 "description.Application.ApplicationDescription",
	"application_name":                        "description.Application.ApplicationName",
	"application_status":                      "description.Application.ApplicationStatus",
	"application_version_id":                  "description.Application.ApplicationVersionId",
	"cloud_watch_logging_option_descriptions": "description.Application.CloudWatchLoggingOptionDescriptions",
	"create_timestamp":                        "description.Application.CreateTimestamp",
	"og_account_id":                           "metadata.SourceID",
	"last_update_timestamp":                   "description.Application.LastUpdateTimestamp",
	"runtime_environment":                     "description.Application.RuntimeEnvironment",
	"service_execution_role":                  "description.Application.ServiceExecutionRole",
	"tags_src":                                "description.Tags",
	"title":                                   "description.Application.ApplicationName",
}

func GetKinesisAnalyticsV2Application(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKinesisAnalyticsV2Application")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKinesisAnalyticsV2ApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKinesisAnalyticsV2ApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KinesisAnalyticsV2Application =============================

// ==========================  START: GlacierVault =============================

type GlacierVault struct {
	Description   aws.GlacierVaultDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type GlacierVaultHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GlacierVault  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GlacierVaultHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GlacierVaultHit `json:"hits"`
}

type GlacierVaultSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  GlacierVaultHits `json:"hits"`
}

type GlacierVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlacierVaultPaginator(filters []essdk.BoolFilter, limit *int64) (GlacierVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glacier_vault", filters, limit)
	if err != nil {
		return GlacierVaultPaginator{}, err
	}

	p := GlacierVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlacierVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlacierVaultPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlacierVaultPaginator) NextPage(ctx context.Context) ([]GlacierVault, error) {
	var response GlacierVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlacierVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlacierVaultFilters = map[string]string{
	"creation_date":             "description.Vault.CreationDate",
	"og_account_id":             "metadata.SourceID",
	"last_inventory_date":       "description.Vault.LastInventoryDate",
	"number_of_archives":        "description.Vault.NumberOfArchives",
	"policy":                    "description.AccessPolicy.Policy",
	"size_in_bytes":             "description.Vault.SizeInBytes",
	"tags":                      "description.Tags",
	"tags_src":                  "description.Tags",
	"title":                     "description.Vault.VaultName",
	"vault_arn":                 "description.Vault.VaultARN",
	"vault_lock_policy":         "description.LockPolicy.Policy",
	"vault_name":                "description.Vault.VaultName",
	"vault_notification_config": "description.VaultNotificationConfig",
}

func ListGlacierVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlacierVault")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlacierVault NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlacierVault NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlacierVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlacierVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlacierVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlacierVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlacierVaultFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlacierVault NewGlacierVaultPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlacierVault paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlacierVaultFilters = map[string]string{
	"creation_date":             "description.Vault.CreationDate",
	"og_account_id":             "metadata.SourceID",
	"last_inventory_date":       "description.Vault.LastInventoryDate",
	"number_of_archives":        "description.Vault.NumberOfArchives",
	"policy":                    "description.AccessPolicy.Policy",
	"size_in_bytes":             "description.Vault.SizeInBytes",
	"tags":                      "description.Tags",
	"tags_src":                  "description.Tags",
	"title":                     "description.Vault.VaultName",
	"vault_arn":                 "description.Vault.VaultARN",
	"vault_lock_policy":         "description.LockPolicy.Policy",
	"vault_name":                "description.Vault.VaultName",
	"vault_notification_config": "description.VaultNotificationConfig",
}

func GetGlacierVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlacierVault")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlacierVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlacierVaultFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlacierVault =============================

// ==========================  START: WorkspacesWorkspace =============================

type WorkspacesWorkspace struct {
	Description   aws.WorkspacesWorkspaceDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type WorkspacesWorkspaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  WorkspacesWorkspace `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type WorkspacesWorkspaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []WorkspacesWorkspaceHit `json:"hits"`
}

type WorkspacesWorkspaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  WorkspacesWorkspaceHits `json:"hits"`
}

type WorkspacesWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkspacesWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (WorkspacesWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_workspaces_workspace", filters, limit)
	if err != nil {
		return WorkspacesWorkspacePaginator{}, err
	}

	p := WorkspacesWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkspacesWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkspacesWorkspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkspacesWorkspacePaginator) NextPage(ctx context.Context) ([]WorkspacesWorkspace, error) {
	var response WorkspacesWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkspacesWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkspacesWorkspaceFilters = map[string]string{
	"arn":                            "arn",
	"bundle_id":                      "description.Workspace.BundleId",
	"directory_id":                   "description.Workspace.DirectoryId",
	"error_code":                     "description.Workspace.ErrorCode",
	"error_message":                  "description.Workspace.ErrorMessage",
	"ip_address":                     "description.Workspace.IpAddress",
	"og_account_id":                  "metadata.SourceID",
	"modification_states":            "description.Workspace.ModificationStates",
	"name":                           "description.Workspace.ComputerName",
	"root_volume_encryption_enabled": "description.Workspace.RootVolumeEncryptionEnabled",
	"state":                          "description.Workspace.State",
	"subnet_id":                      "description.Workspace.SubnetId",
	"tags_src":                       "description.Tags",
	"title":                          "description.Workspace.ComputerName",
	"user_name":                      "description.Workspace.UserName",
	"user_volume_encryption_enabled": "description.Workspace.UserVolumeEncryptionEnabled",
	"volume_encryption_key":          "description.Workspace.VolumeEncryptionKey",
	"workspace_id":                   "description.Workspace.WorkspaceId",
	"workspace_properties":           "description.Workspace.WorkspaceProperties",
}

func ListWorkspacesWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkspacesWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesWorkspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesWorkspace NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkspacesWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkspacesWorkspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesWorkspace NewWorkspacesWorkspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkspacesWorkspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkspacesWorkspaceFilters = map[string]string{
	"arn":                            "arn",
	"bundle_id":                      "description.Workspace.BundleId",
	"directory_id":                   "description.Workspace.DirectoryId",
	"error_code":                     "description.Workspace.ErrorCode",
	"error_message":                  "description.Workspace.ErrorMessage",
	"ip_address":                     "description.Workspace.IpAddress",
	"og_account_id":                  "metadata.SourceID",
	"modification_states":            "description.Workspace.ModificationStates",
	"name":                           "description.Workspace.ComputerName",
	"root_volume_encryption_enabled": "description.Workspace.RootVolumeEncryptionEnabled",
	"state":                          "description.Workspace.State",
	"subnet_id":                      "description.Workspace.SubnetId",
	"tags_src":                       "description.Tags",
	"title":                          "description.Workspace.ComputerName",
	"user_name":                      "description.Workspace.UserName",
	"user_volume_encryption_enabled": "description.Workspace.UserVolumeEncryptionEnabled",
	"volume_encryption_key":          "description.Workspace.VolumeEncryptionKey",
	"workspace_id":                   "description.Workspace.WorkspaceId",
	"workspace_properties":           "description.Workspace.WorkspaceProperties",
}

func GetWorkspacesWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkspacesWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkspacesWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkspacesWorkspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WorkspacesWorkspace =============================

// ==========================  START: WorkspacesBundle =============================

type WorkspacesBundle struct {
	Description   aws.WorkspacesBundleDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type WorkspacesBundleHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  WorkspacesBundle `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type WorkspacesBundleHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []WorkspacesBundleHit `json:"hits"`
}

type WorkspacesBundleSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  WorkspacesBundleHits `json:"hits"`
}

type WorkspacesBundlePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkspacesBundlePaginator(filters []essdk.BoolFilter, limit *int64) (WorkspacesBundlePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_workspaces_bundle", filters, limit)
	if err != nil {
		return WorkspacesBundlePaginator{}, err
	}

	p := WorkspacesBundlePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkspacesBundlePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkspacesBundlePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkspacesBundlePaginator) NextPage(ctx context.Context) ([]WorkspacesBundle, error) {
	var response WorkspacesBundleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkspacesBundle
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkspacesBundleFilters = map[string]string{
	"arn":           "arn",
	"bundle_id":     "description.Bundle.BundleId",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Bundle.Name",
	"title":         "description.Bundle.Name",
}

func ListWorkspacesBundle(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkspacesBundle")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesBundle NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesBundle NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesBundle GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesBundle GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesBundle GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkspacesBundlePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkspacesBundleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkspacesBundle NewWorkspacesBundlePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkspacesBundle paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkspacesBundleFilters = map[string]string{
	"arn":           "arn",
	"bundle_id":     "description.Bundle.BundleId",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Bundle.Name",
	"title":         "description.Bundle.Name",
}

func GetWorkspacesBundle(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkspacesBundle")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkspacesBundlePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkspacesBundleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WorkspacesBundle =============================

// ==========================  START: KeyspacesKeyspace =============================

type KeyspacesKeyspace struct {
	Description   aws.KeyspacesKeyspaceDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type KeyspacesKeyspaceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  KeyspacesKeyspace `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type KeyspacesKeyspaceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []KeyspacesKeyspaceHit `json:"hits"`
}

type KeyspacesKeyspaceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  KeyspacesKeyspaceHits `json:"hits"`
}

type KeyspacesKeyspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyspacesKeyspacePaginator(filters []essdk.BoolFilter, limit *int64) (KeyspacesKeyspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_keyspaces_keyspace", filters, limit)
	if err != nil {
		return KeyspacesKeyspacePaginator{}, err
	}

	p := KeyspacesKeyspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyspacesKeyspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyspacesKeyspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyspacesKeyspacePaginator) NextPage(ctx context.Context) ([]KeyspacesKeyspace, error) {
	var response KeyspacesKeyspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyspacesKeyspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyspacesKeyspaceFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"keyspace_name": "description.Keyspace.KeyspaceName",
	"resource_arn":  "description.Keyspace.ResourceArn",
	"title":         "description.Keyspace.KeyspaceName",
}

func ListKeyspacesKeyspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyspacesKeyspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesKeyspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesKeyspace NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesKeyspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesKeyspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesKeyspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyspacesKeyspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyspacesKeyspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesKeyspace NewKeyspacesKeyspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyspacesKeyspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyspacesKeyspaceFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"keyspace_name": "description.Keyspace.KeyspaceName",
	"resource_arn":  "description.Keyspace.ResourceArn",
	"title":         "description.Keyspace.KeyspaceName",
}

func GetKeyspacesKeyspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyspacesKeyspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyspacesKeyspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyspacesKeyspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyspacesKeyspace =============================

// ==========================  START: KeyspacesTable =============================

type KeyspacesTable struct {
	Description   aws.KeyspacesTableDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type KeyspacesTableHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  KeyspacesTable `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type KeyspacesTableHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []KeyspacesTableHit `json:"hits"`
}

type KeyspacesTableSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  KeyspacesTableHits `json:"hits"`
}

type KeyspacesTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyspacesTablePaginator(filters []essdk.BoolFilter, limit *int64) (KeyspacesTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_keyspaces_table", filters, limit)
	if err != nil {
		return KeyspacesTablePaginator{}, err
	}

	p := KeyspacesTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyspacesTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyspacesTablePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyspacesTablePaginator) NextPage(ctx context.Context) ([]KeyspacesTable, error) {
	var response KeyspacesTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyspacesTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyspacesTableFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"resource_arn":  "description.Table.ResourceArn",
	"table_name":    "description.Table.TableName",
	"title":         "description.Table.TableName",
}

func ListKeyspacesTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyspacesTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesTable NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesTable NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyspacesTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyspacesTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyspacesTable NewKeyspacesTablePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyspacesTable paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyspacesTableFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"resource_arn":  "description.Table.ResourceArn",
	"table_name":    "description.Table.TableName",
	"title":         "description.Table.TableName",
}

func GetKeyspacesTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyspacesTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyspacesTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyspacesTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyspacesTable =============================

// ==========================  START: GrafanaWorkspace =============================

type GrafanaWorkspace struct {
	Description   aws.GrafanaWorkspaceDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type GrafanaWorkspaceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  GrafanaWorkspace `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type GrafanaWorkspaceHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []GrafanaWorkspaceHit `json:"hits"`
}

type GrafanaWorkspaceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  GrafanaWorkspaceHits `json:"hits"`
}

type GrafanaWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGrafanaWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (GrafanaWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_grafana_workspace", filters, limit)
	if err != nil {
		return GrafanaWorkspacePaginator{}, err
	}

	p := GrafanaWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GrafanaWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GrafanaWorkspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GrafanaWorkspacePaginator) NextPage(ctx context.Context) ([]GrafanaWorkspace, error) {
	var response GrafanaWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GrafanaWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGrafanaWorkspaceFilters = map[string]string{
	"arn":           "arn",
	"id":            "description.Workspace.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Workspace.Name",
	"tags":          "description.Workspace.Tags",
	"title":         "description.Workspace.Name",
}

func ListGrafanaWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGrafanaWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGrafanaWorkspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGrafanaWorkspace NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGrafanaWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGrafanaWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGrafanaWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGrafanaWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listGrafanaWorkspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGrafanaWorkspace NewGrafanaWorkspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGrafanaWorkspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGrafanaWorkspaceFilters = map[string]string{
	"arn":           "arn",
	"id":            "description.Workspace.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Workspace.Name",
	"tags":          "description.Workspace.Tags",
	"title":         "description.Workspace.Name",
}

func GetGrafanaWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGrafanaWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGrafanaWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getGrafanaWorkspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GrafanaWorkspace =============================

// ==========================  START: AMPWorkspace =============================

type AMPWorkspace struct {
	Description   aws.AMPWorkspaceDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type AMPWorkspaceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AMPWorkspace  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AMPWorkspaceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AMPWorkspaceHit `json:"hits"`
}

type AMPWorkspaceSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  AMPWorkspaceHits `json:"hits"`
}

type AMPWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAMPWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (AMPWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_amp_workspace", filters, limit)
	if err != nil {
		return AMPWorkspacePaginator{}, err
	}

	p := AMPWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AMPWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AMPWorkspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AMPWorkspacePaginator) NextPage(ctx context.Context) ([]AMPWorkspace, error) {
	var response AMPWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AMPWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAMPWorkspaceFilters = map[string]string{
	"arn":           "description.Workspace.Arn",
	"og_account_id": "metadata.SourceID",
	"tags":          "description.Workspace.Tags",
	"title":         "description.Workspace.WorkspaceId",
	"workspace_id":  "description.Workspace.WorkspaceId",
}

func ListAMPWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAMPWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAMPWorkspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAMPWorkspace NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAMPWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAMPWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAMPWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAMPWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listAMPWorkspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAMPWorkspace NewAMPWorkspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAMPWorkspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAMPWorkspaceFilters = map[string]string{
	"arn":           "description.Workspace.Arn",
	"og_account_id": "metadata.SourceID",
	"tags":          "description.Workspace.Tags",
	"title":         "description.Workspace.WorkspaceId",
	"workspace_id":  "description.Workspace.WorkspaceId",
}

func GetAMPWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAMPWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAMPWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getAMPWorkspaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AMPWorkspace =============================

// ==========================  START: KafkaCluster =============================

type KafkaCluster struct {
	Description   aws.KafkaClusterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type KafkaClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KafkaCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KafkaClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KafkaClusterHit `json:"hits"`
}

type KafkaClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  KafkaClusterHits `json:"hits"`
}

type KafkaClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKafkaClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KafkaClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_kafka_cluster", filters, limit)
	if err != nil {
		return KafkaClusterPaginator{}, err
	}

	p := KafkaClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KafkaClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KafkaClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KafkaClusterPaginator) NextPage(ctx context.Context) ([]KafkaCluster, error) {
	var response KafkaClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KafkaCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKafkaClusterFilters = map[string]string{
	"arn":           "description.Cluster.ClusterArn",
	"cluster_name":  "description.Cluster.ClusterName",
	"og_account_id": "metadata.SourceID",
	"tags":          "description.Cluster.Tags",
	"title":         "description.Cluster.ClusterName",
}

func ListKafkaCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKafkaCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKafkaCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKafkaCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKafkaCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKafkaCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKafkaCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKafkaClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKafkaClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKafkaCluster NewKafkaClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKafkaCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKafkaClusterFilters = map[string]string{
	"arn":           "description.Cluster.ClusterArn",
	"cluster_name":  "description.Cluster.ClusterName",
	"og_account_id": "metadata.SourceID",
	"tags":          "description.Cluster.Tags",
	"title":         "description.Cluster.ClusterName",
}

func GetKafkaCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKafkaCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKafkaClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKafkaClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KafkaCluster =============================

// ==========================  START: MWAAEnvironment =============================

type MWAAEnvironment struct {
	Description   aws.MWAAEnvironmentDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type MWAAEnvironmentHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  MWAAEnvironment `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type MWAAEnvironmentHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []MWAAEnvironmentHit `json:"hits"`
}

type MWAAEnvironmentSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  MWAAEnvironmentHits `json:"hits"`
}

type MWAAEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMWAAEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (MWAAEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mwaa_environment", filters, limit)
	if err != nil {
		return MWAAEnvironmentPaginator{}, err
	}

	p := MWAAEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MWAAEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MWAAEnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MWAAEnvironmentPaginator) NextPage(ctx context.Context) ([]MWAAEnvironment, error) {
	var response MWAAEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MWAAEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMWAAEnvironmentFilters = map[string]string{
	"arn":           "description.Environment.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Environment.Name",
	"tags":          "description.Environment.Tags",
	"title":         "description.Environment.Name",
}

func ListMWAAEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMWAAEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMWAAEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMWAAEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMWAAEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMWAAEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMWAAEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMWAAEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMWAAEnvironmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMWAAEnvironment NewMWAAEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMWAAEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMWAAEnvironmentFilters = map[string]string{
	"arn":           "description.Environment.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Environment.Name",
	"tags":          "description.Environment.Tags",
	"title":         "description.Environment.Name",
}

func GetMWAAEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMWAAEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMWAAEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMWAAEnvironmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MWAAEnvironment =============================

// ==========================  START: MemoryDbCluster =============================

type MemoryDbCluster struct {
	Description   aws.MemoryDbClusterDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type MemoryDbClusterHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  MemoryDbCluster `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type MemoryDbClusterHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []MemoryDbClusterHit `json:"hits"`
}

type MemoryDbClusterSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  MemoryDbClusterHits `json:"hits"`
}

type MemoryDbClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMemoryDbClusterPaginator(filters []essdk.BoolFilter, limit *int64) (MemoryDbClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_memorydb_cluster", filters, limit)
	if err != nil {
		return MemoryDbClusterPaginator{}, err
	}

	p := MemoryDbClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MemoryDbClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MemoryDbClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MemoryDbClusterPaginator) NextPage(ctx context.Context) ([]MemoryDbCluster, error) {
	var response MemoryDbClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MemoryDbCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMemoryDbClusterFilters = map[string]string{
	"arn":           "description.Cluster.ARN",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Cluster.Name",
	"title":         "description.Cluster.Name",
}

func ListMemoryDbCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMemoryDbCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMemoryDbCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMemoryDbCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMemoryDbCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMemoryDbCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMemoryDbCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMemoryDbClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMemoryDbClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMemoryDbCluster NewMemoryDbClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMemoryDbCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMemoryDbClusterFilters = map[string]string{
	"arn":           "description.Cluster.ARN",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Cluster.Name",
	"title":         "description.Cluster.Name",
}

func GetMemoryDbCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMemoryDbCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMemoryDbClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMemoryDbClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MemoryDbCluster =============================

// ==========================  START: MQBroker =============================

type MQBroker struct {
	Description   aws.MQBrokerDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type MQBrokerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MQBroker      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MQBrokerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []MQBrokerHit     `json:"hits"`
}

type MQBrokerSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  MQBrokerHits `json:"hits"`
}

type MQBrokerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMQBrokerPaginator(filters []essdk.BoolFilter, limit *int64) (MQBrokerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mq_broker", filters, limit)
	if err != nil {
		return MQBrokerPaginator{}, err
	}

	p := MQBrokerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MQBrokerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MQBrokerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MQBrokerPaginator) NextPage(ctx context.Context) ([]MQBroker, error) {
	var response MQBrokerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MQBroker
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMQBrokerFilters = map[string]string{
	"actions_required":                  "description.BrokerDescription.ActionsRequired",
	"arn":                               "description.BrokerDescription.BrokerArn",
	"authentication_strategy":           "description.BrokerDescription.AuthenticationStrategy",
	"auto_minor_version_upgrade":        "description.BrokerDescription.AutoMinorVersionUpgrade",
	"broker_id":                         "description.BrokerDescription.BrokerId",
	"broker_instances":                  "description.BrokerDescription.BrokerInstances",
	"broker_name":                       "description.BrokerDescription.BrokerName",
	"broker_state":                      "description.BrokerDescription.BrokerState",
	"configurations":                    "description.BrokerDescription.Configurations",
	"created":                           "description.BrokerDescription.Created",
	"data_replication_metadata":         "description.BrokerDescription.DataReplicationMetadata",
	"data_replication_mode":             "description.BrokerDescription.DataReplicationMode",
	"deployment_mode":                   "description.BrokerDescription.DeploymentMode",
	"encryption_options":                "description.BrokerDescription.EncryptionOptions",
	"engine_type":                       "description.BrokerDescription.EngineType",
	"engine_version":                    "description.BrokerDescription.EngineVersion",
	"host_instance_type":                "description.BrokerDescription.HostInstanceType",
	"og_account_id":                     "metadata.SourceID",
	"ldap_server_metadata":              "description.BrokerDescription.LdapServerMetadata",
	"logs":                              "description.BrokerDescription.Logs",
	"maintenance_window_start_time":     "description.BrokerDescription.MaintenanceWindowStartTime",
	"pending_authentication_strategy":   "description.BrokerDescription.PendingAuthenticationStrategy",
	"pending_data_replication_metadata": "description.BrokerDescription.PendingDataReplicationMetadata",
	"pending_data_replication_mode":     "description.BrokerDescription.PendingDataReplicationMode",
	"pending_engine_version":            "description.BrokerDescription.PendingEngineVersion",
	"pending_host_instance_type":        "description.BrokerDescription.PendingHostInstanceType",
	"pending_ldap_server_metadata":      "description.BrokerDescription.PendingLdapServerMetadata",
	"pending_security_groups":           "description.BrokerDescription.PendingSecurityGroups",
	"publicly_accessible":               "description.BrokerDescription.PubliclyAccessible",
	"security_groups":                   "description.BrokerDescription.SecurityGroups",
	"storage_type":                      "description.BrokerDescription.StorageType",
	"subnet_ids":                        "description.BrokerDescription.SubnetIds",
	"tags":                              "description.BrokerDescription.Tags",
	"title":                             "description.BrokerDescription.BrokerName",
	"users":                             "description.BrokerDescription.Users",
}

func ListMQBroker(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMQBroker")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMQBroker NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMQBroker NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMQBroker GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMQBroker GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMQBroker GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMQBrokerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMQBrokerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMQBroker NewMQBrokerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMQBroker paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMQBrokerFilters = map[string]string{
	"actions_required":                  "description.BrokerDescription.ActionsRequired",
	"arn":                               "description.BrokerDescription.BrokerArn",
	"authentication_strategy":           "description.BrokerDescription.AuthenticationStrategy",
	"auto_minor_version_upgrade":        "description.BrokerDescription.AutoMinorVersionUpgrade",
	"broker_id":                         "description.BrokerDescription.BrokerId",
	"broker_instances":                  "description.BrokerDescription.BrokerInstances",
	"broker_name":                       "description.Broker.BrokerName",
	"broker_state":                      "description.BrokerDescription.BrokerState",
	"configurations":                    "description.BrokerDescription.Configurations",
	"created":                           "description.BrokerDescription.Created",
	"data_replication_metadata":         "description.BrokerDescription.DataReplicationMetadata",
	"data_replication_mode":             "description.BrokerDescription.DataReplicationMode",
	"deployment_mode":                   "description.BrokerDescription.DeploymentMode",
	"encryption_options":                "description.BrokerDescription.EncryptionOptions",
	"engine_type":                       "description.BrokerDescription.EngineType",
	"engine_version":                    "description.BrokerDescription.EngineVersion",
	"host_instance_type":                "description.BrokerDescription.HostInstanceType",
	"og_account_id":                     "metadata.SourceID",
	"ldap_server_metadata":              "description.BrokerDescription.LdapServerMetadata",
	"logs":                              "description.BrokerDescription.Logs",
	"maintenance_window_start_time":     "description.BrokerDescription.MaintenanceWindowStartTime",
	"pending_authentication_strategy":   "description.BrokerDescription.PendingAuthenticationStrategy",
	"pending_data_replication_metadata": "description.BrokerDescription.PendingDataReplicationMetadata",
	"pending_data_replication_mode":     "description.BrokerDescription.PendingDataReplicationMode",
	"pending_engine_version":            "description.BrokerDescription.PendingEngineVersion",
	"pending_host_instance_type":        "description.BrokerDescription.PendingHostInstanceType",
	"pending_ldap_server_metadata":      "description.BrokerDescription.PendingLdapServerMetadata",
	"pending_security_groups":           "description.BrokerDescription.PendingSecurityGroups",
	"publicly_accessible":               "description.BrokerDescription.PubliclyAccessible",
	"security_groups":                   "description.BrokerDescription.SecurityGroups",
	"storage_type":                      "description.BrokerDescription.StorageType",
	"subnet_ids":                        "description.BrokerDescription.SubnetIds",
	"tags":                              "description.BrokerDescription.Tags",
	"title":                             "description.BrokerDescription.BrokerName",
	"users":                             "description.BrokerDescription.Users",
}

func GetMQBroker(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMQBroker")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMQBrokerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMQBrokerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MQBroker =============================

// ==========================  START: NeptuneDatabase =============================

type NeptuneDatabase struct {
	Description   aws.NeptuneDatabaseDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type NeptuneDatabaseHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  NeptuneDatabase `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type NeptuneDatabaseHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []NeptuneDatabaseHit `json:"hits"`
}

type NeptuneDatabaseSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  NeptuneDatabaseHits `json:"hits"`
}

type NeptuneDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNeptuneDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (NeptuneDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_neptune_database", filters, limit)
	if err != nil {
		return NeptuneDatabasePaginator{}, err
	}

	p := NeptuneDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NeptuneDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NeptuneDatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NeptuneDatabasePaginator) NextPage(ctx context.Context) ([]NeptuneDatabase, error) {
	var response NeptuneDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NeptuneDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNeptuneDatabaseFilters = map[string]string{
	"db_instance_arn":        "description.Database.DBInstanceArn",
	"db_instance_identifier": "description.Database.DBInstanceIdentifier",
	"db_name":                "description.Database.DBName",
	"og_account_id":          "metadata.SourceID",
	"title":                  "description.Database.DBName",
}

func ListNeptuneDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNeptuneDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNeptuneDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listNeptuneDatabaseFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabase NewNeptuneDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNeptuneDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNeptuneDatabaseFilters = map[string]string{
	"db_instance_arn":        "description.Database.DBInstanceArn",
	"db_instance_identifier": "description.Database.DBInstanceIdentifier",
	"db_name":                "description.Database.DBName",
	"og_account_id":          "metadata.SourceID",
	"title":                  "description.Database.DBName",
}

func GetNeptuneDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNeptuneDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNeptuneDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getNeptuneDatabaseFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NeptuneDatabase =============================

// ==========================  START: NeptuneDatabaseCluster =============================

type NeptuneDatabaseCluster struct {
	Description   aws.NeptuneDatabaseClusterDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type NeptuneDatabaseClusterHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  NeptuneDatabaseCluster `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type NeptuneDatabaseClusterHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []NeptuneDatabaseClusterHit `json:"hits"`
}

type NeptuneDatabaseClusterSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  NeptuneDatabaseClusterHits `json:"hits"`
}

type NeptuneDatabaseClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNeptuneDatabaseClusterPaginator(filters []essdk.BoolFilter, limit *int64) (NeptuneDatabaseClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_neptune_dbcluster", filters, limit)
	if err != nil {
		return NeptuneDatabaseClusterPaginator{}, err
	}

	p := NeptuneDatabaseClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NeptuneDatabaseClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NeptuneDatabaseClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NeptuneDatabaseClusterPaginator) NextPage(ctx context.Context) ([]NeptuneDatabaseCluster, error) {
	var response NeptuneDatabaseClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NeptuneDatabaseCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNeptuneDatabaseClusterFilters = map[string]string{
	"allocated_storage":                   "description.Cluster.AllocatedStorage",
	"arn":                                 "description.Cluster.DBClusterArn",
	"associated_roles":                    "description.Cluster.AssociatedRoles",
	"automatic_restart_time":              "description.Cluster.AutomaticRestartTime",
	"availability_zones":                  "description.Cluster.AvailabilityZones",
	"backup_retention_period":             "description.Cluster.BackupRetentionPeriod",
	"clone_group_id":                      "description.Cluster.CloneGroupId",
	"cluster_create_time":                 "description.Cluster.ClusterCreateTime",
	"copy_tags_to_snapshot":               "description.Cluster.CopyTagsToSnapshot",
	"cross_account_clone":                 "description.Cluster.CrossAccountClone",
	"database_name":                       "description.Cluster.DatabaseName",
	"db_cluster_identifier":               "description.Cluster.DBClusterIdentifier",
	"db_cluster_members":                  "description.Cluster.DBClusterMembers",
	"db_cluster_parameter_group":          "description.Cluster.DBClusterParameterGroup",
	"db_cluster_resource_id":              "description.Cluster.DbClusterResourceId",
	"db_subnet_group":                     "description.Cluster.DBSubnetGroup",
	"deletion_protection":                 "description.Cluster.DeletionProtection",
	"earliest_restorable_time":            "description.Cluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.Cluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.Cluster.Endpoint",
	"engine":                              "description.Cluster.Engine",
	"engine_version":                      "description.Cluster.EngineVersion",
	"hosted_zone_id":                      "description.Cluster.HostedZoneId",
	"iam_database_authentication_enabled": "description.Cluster.IAMDatabaseAuthenticationEnabled",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.Cluster.KmsKeyId",
	"latest_restorable_time":              "description.Cluster.LatestRestorableTime",
	"multi_az":                            "description.Cluster.MultiAZ",
	"percent_progress":                    "description.Cluster.PercentProgress",
	"port":                                "description.Cluster.Port",
	"preferred_backup_window":             "description.Cluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.Cluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.Cluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.Cluster.ReaderEndpoint",
	"status":                              "description.Cluster.Status",
	"storage_encrypted":                   "description.Cluster.StorageEncrypted",
	"tags_src":                            "description.Tags",
	"title":                               "description.Cluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.Cluster.VpcSecurityGroups",
}

func ListNeptuneDatabaseCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNeptuneDatabaseCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNeptuneDatabaseClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNeptuneDatabaseClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseCluster NewNeptuneDatabaseClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNeptuneDatabaseCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNeptuneDatabaseClusterFilters = map[string]string{
	"allocated_storage":                   "description.Cluster.AllocatedStorage",
	"arn":                                 "description.Cluster.DBClusterArn",
	"associated_roles":                    "description.Cluster.AssociatedRoles",
	"automatic_restart_time":              "description.Cluster.AutomaticRestartTime",
	"availability_zones":                  "description.Cluster.AvailabilityZones",
	"backup_retention_period":             "description.Cluster.BackupRetentionPeriod",
	"clone_group_id":                      "description.Cluster.CloneGroupId",
	"cluster_create_time":                 "description.Cluster.ClusterCreateTime",
	"copy_tags_to_snapshot":               "description.Cluster.CopyTagsToSnapshot",
	"cross_account_clone":                 "description.Cluster.CrossAccountClone",
	"database_name":                       "description.Cluster.DatabaseName",
	"db_cluster_identifier":               "description.Cluster.DBClusterIdentifier",
	"db_cluster_members":                  "description.Cluster.DBClusterMembers",
	"db_cluster_parameter_group":          "description.Cluster.DBClusterParameterGroup",
	"db_cluster_resource_id":              "description.Cluster.DbClusterResourceId",
	"db_instance_identifier":              "description.Database.DBInstanceIdentifier",
	"db_subnet_group":                     "description.Cluster.DBSubnetGroup",
	"deletion_protection":                 "description.Cluster.DeletionProtection",
	"earliest_restorable_time":            "description.Cluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports":     "description.Cluster.EnabledCloudwatchLogsExports",
	"endpoint":                            "description.Cluster.Endpoint",
	"engine":                              "description.Cluster.Engine",
	"engine_version":                      "description.Cluster.EngineVersion",
	"hosted_zone_id":                      "description.Cluster.HostedZoneId",
	"iam_database_authentication_enabled": "description.Cluster.IAMDatabaseAuthenticationEnabled",
	"og_account_id":                       "metadata.SourceID",
	"kms_key_id":                          "description.Cluster.KmsKeyId",
	"latest_restorable_time":              "description.Cluster.LatestRestorableTime",
	"multi_az":                            "description.Cluster.MultiAZ",
	"percent_progress":                    "description.Cluster.PercentProgress",
	"port":                                "description.Cluster.Port",
	"preferred_backup_window":             "description.Cluster.PreferredBackupWindow",
	"preferred_maintenance_window":        "description.Cluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":            "description.Cluster.ReadReplicaIdentifiers",
	"reader_endpoint":                     "description.Cluster.ReaderEndpoint",
	"status":                              "description.Cluster.Status",
	"storage_encrypted":                   "description.Cluster.StorageEncrypted",
	"tags_src":                            "description.Tags",
	"title":                               "description.Cluster.DBClusterIdentifier",
	"vpc_security_groups":                 "description.Cluster.VpcSecurityGroups",
}

func GetNeptuneDatabaseCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNeptuneDatabaseCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNeptuneDatabaseClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNeptuneDatabaseClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NeptuneDatabaseCluster =============================

// ==========================  START: NeptuneDatabaseClusterSnapshot =============================

type NeptuneDatabaseClusterSnapshot struct {
	Description   aws.NeptuneDatabaseClusterSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type NeptuneDatabaseClusterSnapshotHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  NeptuneDatabaseClusterSnapshot `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type NeptuneDatabaseClusterSnapshotHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []NeptuneDatabaseClusterSnapshotHit `json:"hits"`
}

type NeptuneDatabaseClusterSnapshotSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  NeptuneDatabaseClusterSnapshotHits `json:"hits"`
}

type NeptuneDatabaseClusterSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNeptuneDatabaseClusterSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (NeptuneDatabaseClusterSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_neptune_dbclustersnapshot", filters, limit)
	if err != nil {
		return NeptuneDatabaseClusterSnapshotPaginator{}, err
	}

	p := NeptuneDatabaseClusterSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NeptuneDatabaseClusterSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NeptuneDatabaseClusterSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NeptuneDatabaseClusterSnapshotPaginator) NextPage(ctx context.Context) ([]NeptuneDatabaseClusterSnapshot, error) {
	var response NeptuneDatabaseClusterSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NeptuneDatabaseClusterSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNeptuneDatabaseClusterSnapshotFilters = map[string]string{
	"allocated_storage":                   "description.Snapshot.AllocatedStorage",
	"availability_zones":                  "description.Snapshot.AvailabilityZones",
	"cluster_create_time":                 "description.Snapshot.ClusterCreateTime",
	"db_cluster_identifier":               "description.Snapshot.DBClusterIdentifier",
	"db_cluster_snapshot_arn":             "description.Snapshot.DBClusterSnapshotArn",
	"db_cluster_snapshot_attributes":      "description.Attributes",
	"db_cluster_snapshot_identifier":      "description.Snapshot.DBClusterSnapshotIdentifier",
	"engine":                              "description.Snapshot.Engine",
	"engine_version":                      "description.Snapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.Snapshot.IAMDatabaseAuthenticationEnabled",
	"kms_key_id":                          "description.Snapshot.KmsKeyId",
	"license_model":                       "description.Snapshot.LicenseModel",
	"master_username":                     "description.Snapshot.MasterUsername",
	"percent_progress":                    "description.Snapshot.PercentProgress",
	"port":                                "description.Snapshot.Port",
	"snapshot_create_time":                "description.Snapshot.SnapshotCreateTime",
	"snapshot_type":                       "description.Snapshot.SnapshotType",
	"source_db_cluster_snapshot_arn":      "description.Snapshot.SourceDBClusterSnapshotArn",
	"status":                              "description.Snapshot.Status",
	"storage_encrypted":                   "description.Snapshot.StorageEncrypted",
	"title":                               "description.Snapshot.DBClusterSnapshotIdentifier",
	"vpc_id":                              "description.Snapshot.VpcId",
}

func ListNeptuneDatabaseClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNeptuneDatabaseClusterSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseClusterSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseClusterSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNeptuneDatabaseClusterSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNeptuneDatabaseClusterSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNeptuneDatabaseClusterSnapshot NewNeptuneDatabaseClusterSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNeptuneDatabaseClusterSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNeptuneDatabaseClusterSnapshotFilters = map[string]string{
	"allocated_storage":                   "description.Snapshot.AllocatedStorage",
	"availability_zones":                  "description.Snapshot.AvailabilityZones",
	"cluster_create_time":                 "description.Snapshot.ClusterCreateTime",
	"db_cluster_identifier":               "description.Snapshot.DBClusterIdentifier",
	"db_cluster_snapshot_arn":             "description.Snapshot.DBClusterSnapshotArn",
	"db_cluster_snapshot_attributes":      "description.Attributes",
	"db_cluster_snapshot_identifier":      "description.Snapshot.DBClusterSnapshotIdentifier",
	"engine":                              "description.Snapshot.Engine",
	"engine_version":                      "description.Snapshot.EngineVersion",
	"iam_database_authentication_enabled": "description.Snapshot.IAMDatabaseAuthenticationEnabled",
	"kms_key_id":                          "description.Snapshot.KmsKeyId",
	"license_model":                       "description.Snapshot.LicenseModel",
	"master_username":                     "description.Snapshot.MasterUsername",
	"percent_progress":                    "description.Snapshot.PercentProgress",
	"port":                                "description.Snapshot.Port",
	"snapshot_create_time":                "description.Snapshot.SnapshotCreateTime",
	"snapshot_type":                       "description.Snapshot.SnapshotType",
	"source_db_cluster_snapshot_arn":      "description.Snapshot.SourceDBClusterSnapshotArn",
	"status":                              "description.Snapshot.Status",
	"storage_encrypted":                   "description.Snapshot.StorageEncrypted",
	"title":                               "description.Snapshot.DBClusterSnapshotIdentifier",
	"vpc_id":                              "description.Snapshot.VpcId",
}

func GetNeptuneDatabaseClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNeptuneDatabaseClusterSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNeptuneDatabaseClusterSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNeptuneDatabaseClusterSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NeptuneDatabaseClusterSnapshot =============================

// ==========================  START: OpenSearchDomain =============================

type OpenSearchDomain struct {
	Description   aws.OpenSearchDomainDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type OpenSearchDomainHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  OpenSearchDomain `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type OpenSearchDomainHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []OpenSearchDomainHit `json:"hits"`
}

type OpenSearchDomainSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  OpenSearchDomainHits `json:"hits"`
}

type OpenSearchDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOpenSearchDomainPaginator(filters []essdk.BoolFilter, limit *int64) (OpenSearchDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_opensearch_domain", filters, limit)
	if err != nil {
		return OpenSearchDomainPaginator{}, err
	}

	p := OpenSearchDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OpenSearchDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OpenSearchDomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OpenSearchDomainPaginator) NextPage(ctx context.Context) ([]OpenSearchDomain, error) {
	var response OpenSearchDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OpenSearchDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOpenSearchDomainFilters = map[string]string{
	"access_policies":            "description.Domain.AccessPolicies",
	"advanced_options":           "description.Domain.AdvancedOptions",
	"advanced_security_options":  "description.Domain.AdvancedSecurityOptions",
	"arn":                        "description.Domain.ARN",
	"auto_tune_options":          "description.Domain.AutoTuneOptions",
	"cluster_config":             "description.Domain.ClusterConfig",
	"cognito_options":            "description.Domain.CognitoOptions",
	"created":                    "description.Domain.Created",
	"deleted":                    "description.Domain.Deleted",
	"domain_endpoint_options":    "description.Domain.DomainEndpointOptions",
	"domain_id":                  "description.Domain.DomainId",
	"domain_name":                "description.Domain.DomainName",
	"ebs_options":                "description.Domain.EBSOptions",
	"encryption_at_rest_options": "description.Domain.EncryptionAtRestOptions",
	"endpoint":                   "description.Domain.Endpoint",
	"endpoints":                  "description.Domain.Endpoints",
	"engine_version":             "description.Domain.EngineVersion",
	"og_account_id":              "metadata.SourceID",
	"log_publishing_options":     "description.Domain.LogPublishingOptions",
	"node_to_node_encryption_options_enabled": "description.Domain.NodeToNodeEncryptionOptions.Enabled",
	"processing":               "description.Domain.Processing",
	"service_software_options": "description.Domain.ServiceSoftwareOptions",
	"snapshot_options":         "description.Domain.SnapshotOptions",
	"tags_src":                 "description.Tags",
	"title":                    "description.Domain.DomainName",
	"upgrade_processing":       "description.Domain.UpgradeProcessing",
	"vpc_options":              "description.Domain.VPCOptions",
}

func ListOpenSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOpenSearchDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOpenSearchDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOpenSearchDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchDomain NewOpenSearchDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOpenSearchDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOpenSearchDomainFilters = map[string]string{
	"access_policies":            "description.Domain.AccessPolicies",
	"advanced_options":           "description.Domain.AdvancedOptions",
	"advanced_security_options":  "description.Domain.AdvancedSecurityOptions",
	"arn":                        "description.Domain.ARN",
	"auto_tune_options":          "description.Domain.AutoTuneOptions",
	"cluster_config":             "description.Domain.ClusterConfig",
	"cognito_options":            "description.Domain.CognitoOptions",
	"created":                    "description.Domain.Created",
	"deleted":                    "description.Domain.Deleted",
	"domain_endpoint_options":    "description.Domain.DomainEndpointOptions",
	"domain_id":                  "description.Domain.DomainId",
	"domain_name":                "description.Domain.DomainName",
	"ebs_options":                "description.Domain.EBSOptions",
	"encryption_at_rest_options": "description.Domain.EncryptionAtRestOptions",
	"endpoint":                   "description.Domain.Endpoint",
	"endpoints":                  "description.Domain.Endpoints",
	"engine_version":             "description.Domain.EngineVersion",
	"og_account_id":              "metadata.SourceID",
	"log_publishing_options":     "description.Domain.LogPublishingOptions",
	"node_to_node_encryption_options_enabled": "description.Domain.NodeToNodeEncryptionOptions.Enabled",
	"processing":               "description.Domain.Processing",
	"service_software_options": "description.Domain.ServiceSoftwareOptions",
	"snapshot_options":         "description.Domain.SnapshotOptions",
	"tags_src":                 "description.Tags",
	"title":                    "description.Domain.DomainName",
	"upgrade_processing":       "description.Domain.UpgradeProcessing",
	"vpc_options":              "description.Domain.VPCOptions",
}

func GetOpenSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOpenSearchDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOpenSearchDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOpenSearchDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OpenSearchDomain =============================

// ==========================  START: SESConfigurationSet =============================

type SESConfigurationSet struct {
	Description   aws.SESConfigurationSetDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type SESConfigurationSetHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  SESConfigurationSet `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type SESConfigurationSetHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []SESConfigurationSetHit `json:"hits"`
}

type SESConfigurationSetSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  SESConfigurationSetHits `json:"hits"`
}

type SESConfigurationSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSESConfigurationSetPaginator(filters []essdk.BoolFilter, limit *int64) (SESConfigurationSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ses_configurationset", filters, limit)
	if err != nil {
		return SESConfigurationSetPaginator{}, err
	}

	p := SESConfigurationSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SESConfigurationSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SESConfigurationSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SESConfigurationSetPaginator) NextPage(ctx context.Context) ([]SESConfigurationSet, error) {
	var response SESConfigurationSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SESConfigurationSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSESConfigurationSetFilters = map[string]string{
	"arn":           "arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.ConfigurationSet.Name",
	"title":         "description.ConfigurationSet.Name",
}

func ListSESConfigurationSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSESConfigurationSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESConfigurationSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESConfigurationSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESConfigurationSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESConfigurationSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESConfigurationSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSESConfigurationSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSESConfigurationSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESConfigurationSet NewSESConfigurationSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSESConfigurationSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSESConfigurationSetFilters = map[string]string{
	"arn":           "arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.ConfigurationSet.Name",
	"title":         "description.ConfigurationSet.Name",
}

func GetSESConfigurationSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSESConfigurationSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSESConfigurationSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSESConfigurationSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SESConfigurationSet =============================

// ==========================  START: SESIdentity =============================

type SESIdentity struct {
	Description   aws.SESIdentityDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type SESIdentityHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SESIdentity   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SESIdentityHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SESIdentityHit  `json:"hits"`
}

type SESIdentitySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SESIdentityHits `json:"hits"`
}

type SESIdentityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSESIdentityPaginator(filters []essdk.BoolFilter, limit *int64) (SESIdentityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ses_identity", filters, limit)
	if err != nil {
		return SESIdentityPaginator{}, err
	}

	p := SESIdentityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SESIdentityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SESIdentityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SESIdentityPaginator) NextPage(ctx context.Context) ([]SESIdentity, error) {
	var response SESIdentitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SESIdentity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSESIdentityFilters = map[string]string{
	"arn":           "arn",
	"identity_name": "description.Identity.Name",
	"identity_type": "description.Identity.IdentityType",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Identity.Name",
}

func ListSESIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSESIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESIdentity NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESIdentity NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSESIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSESIdentityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESIdentity NewSESIdentityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSESIdentity paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSESIdentityFilters = map[string]string{
	"arn":           "arn",
	"identity_name": "description.Identity.IdentityName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Identity.Name",
}

func GetSESIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSESIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSESIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSESIdentityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SESIdentity =============================

// ==========================  START: SESv2EmailIdentity =============================

type SESv2EmailIdentity struct {
	Description   aws.SESv2EmailIdentityDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SESv2EmailIdentityHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SESv2EmailIdentity `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SESv2EmailIdentityHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SESv2EmailIdentityHit `json:"hits"`
}

type SESv2EmailIdentitySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SESv2EmailIdentityHits `json:"hits"`
}

type SESv2EmailIdentityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSESv2EmailIdentityPaginator(filters []essdk.BoolFilter, limit *int64) (SESv2EmailIdentityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_sesv2_emailidentities", filters, limit)
	if err != nil {
		return SESv2EmailIdentityPaginator{}, err
	}

	p := SESv2EmailIdentityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SESv2EmailIdentityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SESv2EmailIdentityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SESv2EmailIdentityPaginator) NextPage(ctx context.Context) ([]SESv2EmailIdentity, error) {
	var response SESv2EmailIdentitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SESv2EmailIdentity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSESv2EmailIdentityFilters = map[string]string{
	"arn":   "description.ARN",
	"name":  "description.Identity.IdentityName",
	"tags":  "description.Identity.Tags",
	"title": "description.Identity.IdentityName",
}

func ListSESv2EmailIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSESv2EmailIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESv2EmailIdentity NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESv2EmailIdentity NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESv2EmailIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESv2EmailIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESv2EmailIdentity GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSESv2EmailIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSESv2EmailIdentityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSESv2EmailIdentity NewSESv2EmailIdentityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSESv2EmailIdentity paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSESv2EmailIdentityFilters = map[string]string{
	"arn":   "description.ARN",
	"name":  "description.Identity.IdentityName",
	"tags":  "description.Identity.Tags",
	"title": "description.Identity.IdentityName",
}

func GetSESv2EmailIdentity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSESv2EmailIdentity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSESv2EmailIdentityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSESv2EmailIdentityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SESv2EmailIdentity =============================

// ==========================  START: CloudFormationStack =============================

type CloudFormationStack struct {
	Description   aws.CloudFormationStackDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type CloudFormationStackHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  CloudFormationStack `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type CloudFormationStackHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []CloudFormationStackHit `json:"hits"`
}

type CloudFormationStackSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  CloudFormationStackHits `json:"hits"`
}

type CloudFormationStackPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFormationStackPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFormationStackPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudformation_stack", filters, limit)
	if err != nil {
		return CloudFormationStackPaginator{}, err
	}

	p := CloudFormationStackPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFormationStackPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFormationStackPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFormationStackPaginator) NextPage(ctx context.Context) ([]CloudFormationStack, error) {
	var response CloudFormationStackSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFormationStack
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFormationStackFilters = map[string]string{
	"capabilities":                  "description.Stack.Capabilities",
	"creation_time":                 "description.Stack.CreationTime",
	"description":                   "description.Stack.Description",
	"disable_rollback":              "description.Stack.DisableRollback",
	"enable_termination_protection": "description.Stack.EnableTerminationProtection",
	"id":                            "description.Stack.StackId",
	"og_account_id":                 "metadata.SourceID",
	"last_updated_time":             "description.Stack.LastUpdatedTime",
	"name":                          "description.Stack.StackName",
	"notification_arns":             "description.Stack.NotificationARNs",
	"outputs":                       "description.Stack.Outputs",
	"parameters":                    "description.Stack.Parameters",
	"parent_id":                     "description.Stack.ParentId",
	"resources":                     "description.StackResources",
	"role_arn":                      "description.Stack.RoleARN",
	"rollback_configuration":        "description.Stack.RollbackConfiguration",
	"root_id":                       "description.Stack.RootId",
	"stack_drift_status":            "description.Stack.DriftInformation.StackDriftStatus",
	"status":                        "description.Stack.StackStatus",
	"tags_src":                      "description.Stack.Tags",
	"template_body":                 "description.StackTemplate.TemplateBody",
	"title":                         "description.Stack.StackName",
}

func ListCloudFormationStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFormationStack")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStack NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStack NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStack GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStack GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStack GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFormationStackPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFormationStackFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStack NewCloudFormationStackPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFormationStack paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFormationStackFilters = map[string]string{
	"capabilities":                  "description.Stack.Capabilities",
	"creation_time":                 "description.Stack.CreationTime",
	"description":                   "description.Stack.Description",
	"disable_rollback":              "description.Stack.DisableRollback",
	"enable_termination_protection": "description.Stack.EnableTerminationProtection",
	"id":                            "description.Stack.StackId",
	"og_account_id":                 "metadata.SourceID",
	"last_updated_time":             "description.Stack.LastUpdatedTime",
	"name":                          "description.Stack.StackName",
	"notification_arns":             "description.Stack.NotificationARNs",
	"outputs":                       "description.Stack.Outputs",
	"parameters":                    "description.Stack.Parameters",
	"parent_id":                     "description.Stack.ParentId",
	"resources":                     "description.StackResources",
	"role_arn":                      "description.Stack.RoleARN",
	"rollback_configuration":        "description.Stack.RollbackConfiguration",
	"root_id":                       "description.Stack.RootId",
	"stack_drift_status":            "description.Stack.DriftInformation.StackDriftStatus",
	"status":                        "description.Stack.StackStatus",
	"tags_src":                      "description.Stack.Tags",
	"template_body":                 "description.StackTemplate.TemplateBody",
	"title":                         "description.Stack.StackName",
}

func GetCloudFormationStack(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFormationStack")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFormationStackPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFormationStackFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFormationStack =============================

// ==========================  START: CloudFormationStackSet =============================

type CloudFormationStackSet struct {
	Description   aws.CloudFormationStackSetDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CloudFormationStackSetHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CloudFormationStackSet `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CloudFormationStackSetHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CloudFormationStackSetHit `json:"hits"`
}

type CloudFormationStackSetSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CloudFormationStackSetHits `json:"hits"`
}

type CloudFormationStackSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFormationStackSetPaginator(filters []essdk.BoolFilter, limit *int64) (CloudFormationStackSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudformation_stackset", filters, limit)
	if err != nil {
		return CloudFormationStackSetPaginator{}, err
	}

	p := CloudFormationStackSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFormationStackSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFormationStackSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFormationStackSetPaginator) NextPage(ctx context.Context) ([]CloudFormationStackSet, error) {
	var response CloudFormationStackSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFormationStackSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFormationStackSetFilters = map[string]string{
	"administration_role_arn":           "description.StackSet.AdministrationRoleARN",
	"arn":                               "description.StackSet.StackSetARN",
	"auto_deployment":                   "description.StackSet.AutoDeployment",
	"capabilities":                      "description.StackSet.Capabilities",
	"description":                       "description.StackSet.Description",
	"drift_status":                      "description.StackSet.StackSetDriftDetectionDetails.DriftStatus",
	"execution_role_name":               "description.StackSet.ExecutionRoleName",
	"og_account_id":                     "metadata.SourceID",
	"last_drift_check_timestamp":        "description.StackSet.StackSetDriftDetectionDetails.LastDriftCheckTimestamp",
	"managed_execution":                 "description.StackSet.ManagedExecution",
	"organizational_unit_ids":           "description.StackSet.OrganizationalUnitIds",
	"parameters":                        "description.StackSet.Parameters",
	"permission_model":                  "description.StackSet.PermissionModel",
	"stack_set_drift_detection_details": "description.StackSet.StackSetDriftDetectionDetails",
	"stack_set_id":                      "description.StackSet.StackSetId",
	"stack_set_name":                    "description.StackSet.StackSetName",
	"status":                            "description.StackSet.Status",
	"tags_src":                          "description.StackSet.Tags",
	"template_body":                     "description.StackSet.TemplateBody",
	"title":                             "description.StackSet.StackSetName",
}

func ListCloudFormationStackSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFormationStackSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFormationStackSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFormationStackSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackSet NewCloudFormationStackSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFormationStackSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFormationStackSetFilters = map[string]string{
	"administration_role_arn":           "description.StackSet.AdministrationRoleARN",
	"arn":                               "description.StackSet.StackSetARN",
	"auto_deployment":                   "description.StackSet.AutoDeployment",
	"capabilities":                      "description.StackSet.Capabilities",
	"description":                       "description.StackSet.Description",
	"drift_status":                      "description.StackSet.StackSetDriftDetectionDetails.DriftStatus",
	"execution_role_name":               "description.StackSet.ExecutionRoleName",
	"og_account_id":                     "metadata.SourceID",
	"last_drift_check_timestamp":        "description.StackSet.StackSetDriftDetectionDetails.LastDriftCheckTimestamp",
	"managed_execution":                 "description.StackSet.ManagedExecution",
	"organizational_unit_ids":           "description.StackSet.OrganizationalUnitIds",
	"parameters":                        "description.StackSet.Parameters",
	"permission_model":                  "description.StackSet.PermissionModel",
	"stack_set_drift_detection_details": "description.StackSet.StackSetDriftDetectionDetails",
	"stack_set_id":                      "description.StackSet.StackSetId",
	"stack_set_name":                    "description.StackSet.StackSetName",
	"status":                            "description.StackSet.Status",
	"tags_src":                          "description.StackSet.Tags",
	"template_body":                     "description.StackSet.TemplateBody",
	"title":                             "description.StackSet.StackSetName",
}

func GetCloudFormationStackSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFormationStackSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFormationStackSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFormationStackSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFormationStackSet =============================

// ==========================  START: CloudFormationStackResource =============================

type CloudFormationStackResource struct {
	Description   aws.CloudFormationStackResourceDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type CloudFormationStackResourceHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  CloudFormationStackResource `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type CloudFormationStackResourceHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []CloudFormationStackResourceHit `json:"hits"`
}

type CloudFormationStackResourceSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  CloudFormationStackResourceHits `json:"hits"`
}

type CloudFormationStackResourcePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudFormationStackResourcePaginator(filters []essdk.BoolFilter, limit *int64) (CloudFormationStackResourcePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudformation_stackresource", filters, limit)
	if err != nil {
		return CloudFormationStackResourcePaginator{}, err
	}

	p := CloudFormationStackResourcePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudFormationStackResourcePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudFormationStackResourcePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudFormationStackResourcePaginator) NextPage(ctx context.Context) ([]CloudFormationStackResource, error) {
	var response CloudFormationStackResourceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudFormationStackResource
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudFormationStackResourceFilters = map[string]string{
	"description":            "description.StackResource.Description",
	"drift_information":      "description.StackResource.DriftInformation",
	"og_account_id":          "metadata.SourceID",
	"last_updated_timestamp": "description.StackResource.LastUpdatedTimestamp",
	"logical_resource_id":    "description.StackResource.LogicalResourceId",
	"module_info":            "description.StackResource.ModuleInfo",
	"name":                   "description.StackResource.StackName",
	"physical_resource_id":   "description.StackResource.PhysicalResourceId",
	"resource_status_reason": "description.StackResource.ResourceStatusReason",
	"resource_type":          "description.StackResource.ResourceType",
	"stack_id":               "description.StackResource.StackId",
	"stack_name":             "description.StackResource.StackName",
	"title":                  "description.StackResource.LogicalResourceId",
}

func ListCloudFormationStackResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudFormationStackResource")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackResource NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackResource NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudFormationStackResourcePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudFormationStackResourceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudFormationStackResource NewCloudFormationStackResourcePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudFormationStackResource paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudFormationStackResourceFilters = map[string]string{
	"description":            "description.StackResource.Description",
	"drift_information":      "description.StackResource.DriftInformation",
	"og_account_id":          "metadata.SourceID",
	"last_updated_timestamp": "description.StackResource.LastUpdatedTimestamp",
	"logical_resource_id":    "description.StackResource.LogicalResourceId",
	"module_info":            "description.StackResource.ModuleInfo",
	"physical_resource_id":   "description.StackResource.PhysicalResourceId",
	"resource_status_reason": "description.StackResource.ResourceStatusReason",
	"resource_type":          "description.StackResource.ResourceType",
	"stack_id":               "description.StackResource.StackId",
	"stack_name":             "description.StackResource.StackName",
	"title":                  "description.StackResource.LogicalResourceId",
}

func GetCloudFormationStackResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudFormationStackResource")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudFormationStackResourcePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudFormationStackResourceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudFormationStackResource =============================

// ==========================  START: CodeCommitRepository =============================

type CodeCommitRepository struct {
	Description   aws.CodeCommitRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type CodeCommitRepositoryHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  CodeCommitRepository `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type CodeCommitRepositoryHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []CodeCommitRepositoryHit `json:"hits"`
}

type CodeCommitRepositorySearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  CodeCommitRepositoryHits `json:"hits"`
}

type CodeCommitRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeCommitRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (CodeCommitRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codecommit_repository", filters, limit)
	if err != nil {
		return CodeCommitRepositoryPaginator{}, err
	}

	p := CodeCommitRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeCommitRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeCommitRepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeCommitRepositoryPaginator) NextPage(ctx context.Context) ([]CodeCommitRepository, error) {
	var response CodeCommitRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeCommitRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeCommitRepositoryFilters = map[string]string{
	"arn":                "description.Repository.Arn",
	"clone_url_http":     "description.Repository.CloneUrlHttp",
	"clone_url_ssh":      "description.Repository.CloneUrlSsh",
	"creation_date":      "description.Repository.CreationDate",
	"default_branch":     "description.Repository.DefaultBranch",
	"description":        "description.Repository.RepositoryDescription",
	"og_account_id":      "metadata.SourceID",
	"last_modified_date": "description.Repository.LastModifiedDate",
	"repository_id":      "description.Repository.RepositoryId",
	"repository_name":    "description.Repository.RepositoryName",
	"tags":               "description.Tags",
	"title":              "description.Repository.RepositoryName",
}

func ListCodeCommitRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeCommitRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeCommitRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeCommitRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeCommitRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeCommitRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeCommitRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeCommitRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeCommitRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeCommitRepository NewCodeCommitRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeCommitRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeCommitRepositoryFilters = map[string]string{
	"arn":                "description.Repository.Arn",
	"clone_url_http":     "description.Repository.CloneUrlHttp",
	"clone_url_ssh":      "description.Repository.CloneUrlSsh",
	"creation_date":      "description.Repository.CreationDate",
	"default_branch":     "description.Repository.DefaultBranch",
	"description":        "description.Repository.RepositoryDescription",
	"og_account_id":      "metadata.SourceID",
	"last_modified_date": "description.Repository.LastModifiedDate",
	"repository_id":      "description.Repository.RepositoryId",
	"repository_name":    "description.Repository.RepositoryName",
	"tags":               "description.Tags",
	"title":              "description.Repository.RepositoryName",
}

func GetCodeCommitRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeCommitRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeCommitRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeCommitRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeCommitRepository =============================

// ==========================  START: CodePipelinePipeline =============================

type CodePipelinePipeline struct {
	Description   aws.CodePipelinePipelineDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type CodePipelinePipelineHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  CodePipelinePipeline `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type CodePipelinePipelineHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []CodePipelinePipelineHit `json:"hits"`
}

type CodePipelinePipelineSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  CodePipelinePipelineHits `json:"hits"`
}

type CodePipelinePipelinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodePipelinePipelinePaginator(filters []essdk.BoolFilter, limit *int64) (CodePipelinePipelinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codepipeline_pipeline", filters, limit)
	if err != nil {
		return CodePipelinePipelinePaginator{}, err
	}

	p := CodePipelinePipelinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodePipelinePipelinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodePipelinePipelinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodePipelinePipelinePaginator) NextPage(ctx context.Context) ([]CodePipelinePipeline, error) {
	var response CodePipelinePipelineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodePipelinePipeline
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodePipelinePipelineFilters = map[string]string{
	"arn":             "description.Metadata.PipelineArn",
	"artifact_stores": "description.Pipeline.ArtifactStores",
	"created_at":      "description.Metadata.Created",
	"encryption_key":  "description.Pipeline.ArtifactStore.EncryptionKey",
	"og_account_id":   "metadata.SourceID",
	"name":            "description.Pipeline.Name",
	"role_arn":        "description.Pipeline.RoleArn",
	"stages":          "description.Pipeline.Stages",
	"tags_src":        "description.Tags",
	"title":           "description.Pipeline.Name",
	"updated_at":      "description.Metadata.Updated",
	"version":         "description.Pipeline.Version",
}

func ListCodePipelinePipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodePipelinePipeline")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodePipelinePipeline NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodePipelinePipeline NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodePipelinePipeline GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodePipelinePipeline GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodePipelinePipeline GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodePipelinePipelinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodePipelinePipelineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodePipelinePipeline NewCodePipelinePipelinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodePipelinePipeline paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodePipelinePipelineFilters = map[string]string{
	"arn":             "description.Metadata.PipelineArn",
	"artifact_stores": "description.Pipeline.ArtifactStores",
	"created_at":      "description.Metadata.Created",
	"encryption_key":  "description.Pipeline.ArtifactStore.EncryptionKey",
	"og_account_id":   "metadata.SourceID",
	"name":            "description.Pipeline.Name",
	"role_arn":        "description.Pipeline.RoleArn",
	"stages":          "description.Pipeline.Stages",
	"tags_src":        "description.Tags",
	"title":           "description.Pipeline.Name",
	"updated_at":      "description.Metadata.Updated",
	"version":         "description.Pipeline.Version",
}

func GetCodePipelinePipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodePipelinePipeline")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodePipelinePipelinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodePipelinePipelineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodePipelinePipeline =============================

// ==========================  START: DirectoryServiceDirectory =============================

type DirectoryServiceDirectory struct {
	Description   aws.DirectoryServiceDirectoryDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type DirectoryServiceDirectoryHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  DirectoryServiceDirectory `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type DirectoryServiceDirectoryHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []DirectoryServiceDirectoryHit `json:"hits"`
}

type DirectoryServiceDirectorySearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  DirectoryServiceDirectoryHits `json:"hits"`
}

type DirectoryServiceDirectoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectoryServiceDirectoryPaginator(filters []essdk.BoolFilter, limit *int64) (DirectoryServiceDirectoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directoryservice_directory", filters, limit)
	if err != nil {
		return DirectoryServiceDirectoryPaginator{}, err
	}

	p := DirectoryServiceDirectoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectoryServiceDirectoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectoryServiceDirectoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DirectoryServiceDirectoryPaginator) NextPage(ctx context.Context) ([]DirectoryServiceDirectory, error) {
	var response DirectoryServiceDirectorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectoryServiceDirectory
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectoryServiceDirectoryFilters = map[string]string{
	"access_url":                           "description.Directory.AccessUrl",
	"alias":                                "description.Directory.Alias",
	"arn":                                  "arn",
	"connect_settings":                     "description.Directory.ConnectSettings",
	"description":                          "description.Directory.Description",
	"desired_number_of_domain_controllers": "description.Directory.DesiredNumberOfDomainControllers",
	"directory_id":                         "description.Directory.DirectoryId",
	"dns_ip_addrs":                         "description.Directory.DnsIpAddrs",
	"edition":                              "description.Directory.Edition",
	"event_topics":                         "description.EventTopics",
	"og_account_id":                        "metadata.SourceID",
	"launch_time":                          "description.Directory.LaunchTime",
	"name":                                 "description.Directory.Name",
	"owner_directory_description":          "description.Directory.OwnerDirectoryDescription",
	"radius_settings":                      "description.Directory.RadiusSettings",
	"radius_status":                        "description.Directory.RadiusStatus",
	"regions_info":                         "description.Directory.RegionsInfo",
	"share_method":                         "description.Directory.ShareMethod",
	"share_notes":                          "description.Directory.ShareNotes",
	"share_status":                         "description.Directory.ShareStatus",
	"shared_directories":                   "description.SharedDirectory",
	"short_name":                           "description.Directory.ShortName",
	"size":                                 "description.Directory.Size",
	"snapshot_limit":                       "description.Snapshot.ManualSnapshotsLimit",
	"sso_enabled":                          "description.Directory.SsoEnabled",
	"stage":                                "description.Directory.Stage",
	"stage_last_updated_date_time":         "description.Directory.StageLastUpdatedDateTime",
	"stage_reason":                         "description.Directory.StageReason",
	"tags_src":                             "description.Tags",
	"title":                                "description.Directory.Name",
	"type":                                 "description.Directory.Type",
	"vpc_settings":                         "description.Directory.VpcSettings",
}

func ListDirectoryServiceDirectory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectoryServiceDirectory")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceDirectory NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceDirectory NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceDirectory GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceDirectory GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceDirectory GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDirectoryServiceDirectoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDirectoryServiceDirectoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceDirectory NewDirectoryServiceDirectoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDirectoryServiceDirectory paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDirectoryServiceDirectoryFilters = map[string]string{
	"access_url":                           "description.Directory.AccessUrl",
	"alias":                                "description.Directory.Alias",
	"arn":                                  "arn",
	"connect_settings":                     "description.Directory.ConnectSettings",
	"description":                          "description.Directory.Description",
	"desired_number_of_domain_controllers": "description.Directory.DesiredNumberOfDomainControllers",
	"directory_id":                         "description.Directory.DirectoryId",
	"dns_ip_addrs":                         "description.Directory.DnsIpAddrs",
	"edition":                              "description.Directory.Edition",
	"event_topics":                         "description.EventTopics",
	"og_account_id":                        "metadata.SourceID",
	"launch_time":                          "description.Directory.LaunchTime",
	"name":                                 "description.Directory.DirectoryId",
	"owner_directory_description":          "description.Directory.OwnerDirectoryDescription",
	"radius_settings":                      "description.Directory.RadiusSettings",
	"radius_status":                        "description.Directory.RadiusStatus",
	"regions_info":                         "description.Directory.RegionsInfo",
	"share_method":                         "description.Directory.ShareMethod",
	"share_notes":                          "description.Directory.ShareNotes",
	"share_status":                         "description.Directory.ShareStatus",
	"shared_directories":                   "description.SharedDirectory",
	"short_name":                           "description.Directory.ShortName",
	"size":                                 "description.Directory.Size",
	"snapshot_limit":                       "description.Snapshot.ManualSnapshotsLimit",
	"sso_enabled":                          "description.Directory.SsoEnabled",
	"stage":                                "description.Directory.Stage",
	"stage_last_updated_date_time":         "description.Directory.StageLastUpdatedDateTime",
	"stage_reason":                         "description.Directory.StageReason",
	"tags_src":                             "description.Tags",
	"title":                                "description.Directory.Name",
	"type":                                 "description.Directory.Type",
	"vpc_settings":                         "description.Directory.VpcSettings",
}

func GetDirectoryServiceDirectory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectoryServiceDirectory")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDirectoryServiceDirectoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDirectoryServiceDirectoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DirectoryServiceDirectory =============================

// ==========================  START: DirectoryServiceCertificate =============================

type DirectoryServiceCertificate struct {
	Description   aws.DirectoryServiceCertificateDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type DirectoryServiceCertificateHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  DirectoryServiceCertificate `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type DirectoryServiceCertificateHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []DirectoryServiceCertificateHit `json:"hits"`
}

type DirectoryServiceCertificateSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  DirectoryServiceCertificateHits `json:"hits"`
}

type DirectoryServiceCertificatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectoryServiceCertificatePaginator(filters []essdk.BoolFilter, limit *int64) (DirectoryServiceCertificatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directoryservice_certificate", filters, limit)
	if err != nil {
		return DirectoryServiceCertificatePaginator{}, err
	}

	p := DirectoryServiceCertificatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectoryServiceCertificatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectoryServiceCertificatePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DirectoryServiceCertificatePaginator) NextPage(ctx context.Context) ([]DirectoryServiceCertificate, error) {
	var response DirectoryServiceCertificateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectoryServiceCertificate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectoryServiceCertificateFilters = map[string]string{
	"certificate_id":            "description.Certificate.CertificateId",
	"client_cert_auth_settings": "description.Certificate.ClientCertAuthSettings",
	"common_name":               "description.Certificate.CommonName",
	"directory_id":              "description.DirectoryId",
	"expiry_date_time":          "description.Certificate.ExpiryDateTime",
	"og_account_id":             "metadata.SourceID",
	"registered_date_time":      "description.Certificate.RegisteredDateTime",
	"state":                     "description.Certificate.State",
	"state_reason":              "description.Certificate.StateReason",
	"title":                     "description.Certificate.CommonName",
	"type":                      "description.Certificate.Type",
}

func ListDirectoryServiceCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectoryServiceCertificate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceCertificate NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceCertificate NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDirectoryServiceCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDirectoryServiceCertificateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceCertificate NewDirectoryServiceCertificatePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDirectoryServiceCertificate paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDirectoryServiceCertificateFilters = map[string]string{
	"certificate_id":            "description.Certificate.CertificateId",
	"client_cert_auth_settings": "description.Certificate.ClientCertAuthSettings",
	"common_name":               "description.Certificate.CommonName",
	"directory_id":              "description.DirectoryId",
	"expiry_date_time":          "description.Certificate.ExpiryDateTime",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.Certificate.CertificateId",
	"registered_date_time":      "description.Certificate.RegisteredDateTime",
	"state":                     "description.Certificate.State",
	"state_reason":              "description.Certificate.StateReason",
	"title":                     "description.Certificate.CommonName",
	"type":                      "description.Certificate.Type",
}

func GetDirectoryServiceCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectoryServiceCertificate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDirectoryServiceCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDirectoryServiceCertificateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DirectoryServiceCertificate =============================

// ==========================  START: DirectoryServiceLogSubscription =============================

type DirectoryServiceLogSubscription struct {
	Description   aws.DirectoryServiceLogSubscriptionDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type DirectoryServiceLogSubscriptionHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  DirectoryServiceLogSubscription `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type DirectoryServiceLogSubscriptionHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []DirectoryServiceLogSubscriptionHit `json:"hits"`
}

type DirectoryServiceLogSubscriptionSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  DirectoryServiceLogSubscriptionHits `json:"hits"`
}

type DirectoryServiceLogSubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectoryServiceLogSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (DirectoryServiceLogSubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directoryservice_logsubscription", filters, limit)
	if err != nil {
		return DirectoryServiceLogSubscriptionPaginator{}, err
	}

	p := DirectoryServiceLogSubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectoryServiceLogSubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectoryServiceLogSubscriptionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DirectoryServiceLogSubscriptionPaginator) NextPage(ctx context.Context) ([]DirectoryServiceLogSubscription, error) {
	var response DirectoryServiceLogSubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectoryServiceLogSubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectoryServiceLogSubscriptionFilters = map[string]string{
	"directory_id":                   "description.LogSubscription.DirectoryId",
	"og_account_id":                  "metadata.SourceID",
	"log_group_name":                 "description.LogSubscription.LogGroupName",
	"subscription_created_date_time": "description.LogSubscription.SubscriptionCreatedDateTime",
	"title":                          "description.LogSubscription.LogGroupName",
}

func ListDirectoryServiceLogSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectoryServiceLogSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceLogSubscription NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceLogSubscription NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceLogSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceLogSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceLogSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDirectoryServiceLogSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDirectoryServiceLogSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectoryServiceLogSubscription NewDirectoryServiceLogSubscriptionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDirectoryServiceLogSubscription paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDirectoryServiceLogSubscriptionFilters = map[string]string{
	"directory_id":                   "description.LogSubscription.DirectoryId",
	"og_account_id":                  "metadata.SourceID",
	"log_group_name":                 "description.LogSubscription.LogGroupName",
	"subscription_created_date_time": "description.LogSubscription.SubscriptionCreatedDateTime",
	"title":                          "description.LogSubscription.LogGroupName",
}

func GetDirectoryServiceLogSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectoryServiceLogSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDirectoryServiceLogSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDirectoryServiceLogSubscriptionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DirectoryServiceLogSubscription =============================

// ==========================  START: SSOAdminInstance =============================

type SSOAdminInstance struct {
	Description   aws.SSOAdminInstanceDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type SSOAdminInstanceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  SSOAdminInstance `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type SSOAdminInstanceHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []SSOAdminInstanceHit `json:"hits"`
}

type SSOAdminInstanceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  SSOAdminInstanceHits `json:"hits"`
}

type SSOAdminInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSOAdminInstancePaginator(filters []essdk.BoolFilter, limit *int64) (SSOAdminInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssoadmin_instance", filters, limit)
	if err != nil {
		return SSOAdminInstancePaginator{}, err
	}

	p := SSOAdminInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSOAdminInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSOAdminInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSOAdminInstancePaginator) NextPage(ctx context.Context) ([]SSOAdminInstance, error) {
	var response SSOAdminInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSOAdminInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSOAdminInstanceFilters = map[string]string{
	"arn":               "description.Instance.InstanceArn",
	"identity_store_id": "description.Instance.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"title":             "description.Instance.InstanceArn",
}

func ListSSOAdminInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSOAdminInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSOAdminInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSOAdminInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminInstance NewSSOAdminInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSOAdminInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSOAdminInstanceFilters = map[string]string{
	"arn":               "description.Instance.InstanceArn",
	"identity_store_id": "description.Instance.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"title":             "description.Instance.InstanceArn",
}

func GetSSOAdminInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSOAdminInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSOAdminInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSOAdminInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSOAdminInstance =============================

// ==========================  START: SSOAdminAccountAssignment =============================

type SSOAdminAccountAssignment struct {
	Description   aws.SSOAdminAccountAssignmentDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type SSOAdminAccountAssignmentHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  SSOAdminAccountAssignment `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type SSOAdminAccountAssignmentHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []SSOAdminAccountAssignmentHit `json:"hits"`
}

type SSOAdminAccountAssignmentSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  SSOAdminAccountAssignmentHits `json:"hits"`
}

type SSOAdminAccountAssignmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSOAdminAccountAssignmentPaginator(filters []essdk.BoolFilter, limit *int64) (SSOAdminAccountAssignmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssoadmin_accountassignment", filters, limit)
	if err != nil {
		return SSOAdminAccountAssignmentPaginator{}, err
	}

	p := SSOAdminAccountAssignmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSOAdminAccountAssignmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSOAdminAccountAssignmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSOAdminAccountAssignmentPaginator) NextPage(ctx context.Context) ([]SSOAdminAccountAssignment, error) {
	var response SSOAdminAccountAssignmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSOAdminAccountAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSOAdminAccountAssignmentFilters = map[string]string{
	"instance_arn":       "description.Instance.InstanceArn",
	"og_account_id":      "metadata.SourceID",
	"permission_set_arn": "description.AccountAssignment.PermissionSetArn",
	"principal_id":       "description.AccountAssignment.PrincipalId",
	"principal_type":     "description.AccountAssignment.PrincipalType",
	"target_account_id":  "description.AccountAssignment.AccountId",
}

func ListSSOAdminAccountAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSOAdminAccountAssignment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminAccountAssignment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminAccountAssignment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminAccountAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminAccountAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminAccountAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSOAdminAccountAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSOAdminAccountAssignmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminAccountAssignment NewSSOAdminAccountAssignmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSOAdminAccountAssignment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSOAdminAccountAssignmentFilters = map[string]string{
	"instance_arn":       "description.Instance.InstanceArn",
	"og_account_id":      "metadata.SourceID",
	"permission_set_arn": "description.AccountAssignment.PermissionSetArn",
	"principal_id":       "description.AccountAssignment.PrincipalId",
	"principal_type":     "description.AccountAssignment.PrincipalType",
	"target_account_id":  "description.AccountAssignment.AccountId",
}

func GetSSOAdminAccountAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSOAdminAccountAssignment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSOAdminAccountAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSOAdminAccountAssignmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSOAdminAccountAssignment =============================

// ==========================  START: SSOAdminPermissionSet =============================

type SSOAdminPermissionSet struct {
	Description   aws.SSOAdminPermissionSetDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type SSOAdminPermissionSetHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  SSOAdminPermissionSet `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type SSOAdminPermissionSetHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []SSOAdminPermissionSetHit `json:"hits"`
}

type SSOAdminPermissionSetSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  SSOAdminPermissionSetHits `json:"hits"`
}

type SSOAdminPermissionSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSOAdminPermissionSetPaginator(filters []essdk.BoolFilter, limit *int64) (SSOAdminPermissionSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssoadmin_permissionset", filters, limit)
	if err != nil {
		return SSOAdminPermissionSetPaginator{}, err
	}

	p := SSOAdminPermissionSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSOAdminPermissionSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSOAdminPermissionSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSOAdminPermissionSetPaginator) NextPage(ctx context.Context) ([]SSOAdminPermissionSet, error) {
	var response SSOAdminPermissionSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSOAdminPermissionSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSOAdminPermissionSetFilters = map[string]string{
	"arn":              "description.PermissionSet.PermissionSetArn",
	"created_date":     "description.PermissionSet.CreatedDate",
	"description":      "description.PermissionSet.Description",
	"instance_arn":     "description.InstanceArn",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.PermissionSet.Name",
	"relay_state":      "description.PermissionSet.RelayState",
	"session_duration": "description.PermissionSet.SessionDuration",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.PermissionSet.Name",
}

func ListSSOAdminPermissionSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSOAdminPermissionSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPermissionSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPermissionSet NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPermissionSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPermissionSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPermissionSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSOAdminPermissionSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSOAdminPermissionSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPermissionSet NewSSOAdminPermissionSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSOAdminPermissionSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSOAdminPermissionSetFilters = map[string]string{
	"arn":              "description.PermissionSet.PermissionSetArn",
	"created_date":     "description.PermissionSet.CreatedDate",
	"description":      "description.PermissionSet.Description",
	"instance_arn":     "description.InstanceArn",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.PermissionSet.Name",
	"relay_state":      "description.PermissionSet.RelayState",
	"session_duration": "description.PermissionSet.SessionDuration",
	"tags":             "description.Tags",
	"tags_src":         "description.Tags",
	"title":            "description.PermissionSet.Name",
}

func GetSSOAdminPermissionSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSOAdminPermissionSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSOAdminPermissionSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSOAdminPermissionSetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSOAdminPermissionSet =============================

// ==========================  START: SSOAdminPolicyAttachment =============================

type SSOAdminPolicyAttachment struct {
	Description   aws.SSOAdminPolicyAttachmentDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type SSOAdminPolicyAttachmentHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  SSOAdminPolicyAttachment `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type SSOAdminPolicyAttachmentHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []SSOAdminPolicyAttachmentHit `json:"hits"`
}

type SSOAdminPolicyAttachmentSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  SSOAdminPolicyAttachmentHits `json:"hits"`
}

type SSOAdminPolicyAttachmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSSOAdminPolicyAttachmentPaginator(filters []essdk.BoolFilter, limit *int64) (SSOAdminPolicyAttachmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssoadmin_attachedmanagedpolicy", filters, limit)
	if err != nil {
		return SSOAdminPolicyAttachmentPaginator{}, err
	}

	p := SSOAdminPolicyAttachmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SSOAdminPolicyAttachmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SSOAdminPolicyAttachmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SSOAdminPolicyAttachmentPaginator) NextPage(ctx context.Context) ([]SSOAdminPolicyAttachment, error) {
	var response SSOAdminPolicyAttachmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SSOAdminPolicyAttachment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSSOAdminPolicyAttachmentFilters = map[string]string{
	"instance_arn":       "description.InstanceArn",
	"og_account_id":      "metadata.SourceID",
	"managed_policy_arn": "description.AttachedManagedPolicy.Arn",
	"name":               "description.AttachedManagedPolicy.Name",
	"permission_set_arn": "description.PermissionSetArn",
	"title":              "description.AttachedManagedPolicy.Name",
}

func ListSSOAdminPolicyAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSSOAdminPolicyAttachment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPolicyAttachment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPolicyAttachment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPolicyAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPolicyAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPolicyAttachment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSSOAdminPolicyAttachmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSSOAdminPolicyAttachmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSSOAdminPolicyAttachment NewSSOAdminPolicyAttachmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSSOAdminPolicyAttachment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSSOAdminPolicyAttachmentFilters = map[string]string{
	"instance_arn":       "description.InstanceArn",
	"og_account_id":      "metadata.SourceID",
	"managed_policy_arn": "description.AttachedManagedPolicy.Arn",
	"name":               "description.AttachedManagedPolicy.Name",
	"permission_set_arn": "description.PermissionSetArn",
	"title":              "description.AttachedManagedPolicy.Name",
}

func GetSSOAdminPolicyAttachment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSSOAdminPolicyAttachment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSSOAdminPolicyAttachmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSSOAdminPolicyAttachmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SSOAdminPolicyAttachment =============================

// ==========================  START: UserEffectiveAccess =============================

type UserEffectiveAccess struct {
	Description   aws.UserEffectiveAccessDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type UserEffectiveAccessHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  UserEffectiveAccess `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type UserEffectiveAccessHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []UserEffectiveAccessHit `json:"hits"`
}

type UserEffectiveAccessSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  UserEffectiveAccessHits `json:"hits"`
}

type UserEffectiveAccessPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewUserEffectiveAccessPaginator(filters []essdk.BoolFilter, limit *int64) (UserEffectiveAccessPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ssoadmin_usereffectiveaccess", filters, limit)
	if err != nil {
		return UserEffectiveAccessPaginator{}, err
	}

	p := UserEffectiveAccessPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p UserEffectiveAccessPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p UserEffectiveAccessPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p UserEffectiveAccessPaginator) NextPage(ctx context.Context) ([]UserEffectiveAccess, error) {
	var response UserEffectiveAccessSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []UserEffectiveAccess
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listUserEffectiveAccessFilters = map[string]string{
	"id":                 "id",
	"instance_arn":       "description.Instance.InstanceArn",
	"og_account_id":      "metadata.SourceID",
	"permission_set_arn": "description.AccountAssignment.PermissionSetArn",
	"target_account_id":  "description.AccountAssignment.AccountId",
	"user_id":            "description.UserId",
	"user_name":          "description.User.UserName",
}

func ListUserEffectiveAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListUserEffectiveAccess")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewUserEffectiveAccessPaginator(essdk.BuildFilter(ctx, d.QueryContext, listUserEffectiveAccessFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess NewUserEffectiveAccessPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListUserEffectiveAccess paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getUserEffectiveAccessFilters = map[string]string{
	"id":                 "id",
	"instance_arn":       "description.Instance.InstanceArn",
	"og_account_id":      "metadata.SourceID",
	"permission_set_arn": "description.AccountAssignment.PermissionSetArn",
	"target_account_id":  "description.AccountAssignment.AccountId",
	"user_id":            "description.UserId",
	"user_name":          "description.User.UserName",
}

func GetUserEffectiveAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetUserEffectiveAccess")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewUserEffectiveAccessPaginator(essdk.BuildFilter(ctx, d.QueryContext, getUserEffectiveAccessFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: UserEffectiveAccess =============================

// ==========================  START: WAFRule =============================

type WAFRule struct {
	Description   aws.WAFRuleDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type WAFRuleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFRule       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFRuleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFRuleHit      `json:"hits"`
}

type WAFRuleSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  WAFRuleHits `json:"hits"`
}

type WAFRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRulePaginator(filters []essdk.BoolFilter, limit *int64) (WAFRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_waf_rule", filters, limit)
	if err != nil {
		return WAFRulePaginator{}, err
	}

	p := WAFRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFRulePaginator) NextPage(ctx context.Context) ([]WAFRule, error) {
	var response WAFRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRuleFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Rule.MetricName",
	"name":          "description.Rule.Name",
	"predicates":    "description.Rule.Predicates",
	"rule_id":       "description.Rule.RuleId",
	"tags_src":      "description.Tags",
	"title":         "description.Rule.Name",
}

func ListWAFRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRule NewWAFRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFRuleFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Rule.MetricName",
	"name":          "description.Rule.Name",
	"predicates":    "description.Rule.Predicates",
	"rule_id":       "description.Rule.RuleId",
	"tags_src":      "description.Tags",
	"title":         "description.Rule.Name",
}

func GetWAFRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFRule =============================

// ==========================  START: WAFRegionalRule =============================

type WAFRegionalRule struct {
	Description   aws.WAFRegionalRuleDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type WAFRegionalRuleHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  WAFRegionalRule `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type WAFRegionalRuleHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []WAFRegionalRuleHit `json:"hits"`
}

type WAFRegionalRuleSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  WAFRegionalRuleHits `json:"hits"`
}

type WAFRegionalRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRegionalRulePaginator(filters []essdk.BoolFilter, limit *int64) (WAFRegionalRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafregional_rule", filters, limit)
	if err != nil {
		return WAFRegionalRulePaginator{}, err
	}

	p := WAFRegionalRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRegionalRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRegionalRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFRegionalRulePaginator) NextPage(ctx context.Context) ([]WAFRegionalRule, error) {
	var response WAFRegionalRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRegionalRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRegionalRuleFilters = map[string]string{
	"arn":           "arn",
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Rule.MetricName",
	"name":          "description.Rule.Name",
	"predicates":    "description.Rule.Predicates",
	"rule_id":       "description.Rule.RuleId",
	"title":         "description.Rule.Name",
}

func ListWAFRegionalRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRegionalRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFRegionalRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFRegionalRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRule NewWAFRegionalRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFRegionalRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFRegionalRuleFilters = map[string]string{
	"arn":           "arn",
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Rule.MetricName",
	"name":          "description.Rule.Name",
	"predicates":    "description.Rule.Predicates",
	"rule_id":       "description.Rule.RuleId",
	"title":         "description.Rule.Name",
}

func GetWAFRegionalRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRegionalRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFRegionalRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFRegionalRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFRegionalRule =============================

// ==========================  START: WAFRateBasedRule =============================

type WAFRateBasedRule struct {
	Description   aws.WAFRateBasedRuleDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type WAFRateBasedRuleHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  WAFRateBasedRule `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type WAFRateBasedRuleHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []WAFRateBasedRuleHit `json:"hits"`
}

type WAFRateBasedRuleSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  WAFRateBasedRuleHits `json:"hits"`
}

type WAFRateBasedRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRateBasedRulePaginator(filters []essdk.BoolFilter, limit *int64) (WAFRateBasedRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_waf_ratebasedrule", filters, limit)
	if err != nil {
		return WAFRateBasedRulePaginator{}, err
	}

	p := WAFRateBasedRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRateBasedRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRateBasedRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFRateBasedRulePaginator) NextPage(ctx context.Context) ([]WAFRateBasedRule, error) {
	var response WAFRateBasedRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRateBasedRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRateBasedRuleFilters = map[string]string{
	"akas":          "description.ARN",
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Rule.MetricName",
	"name":          "description.Rule.Name",
	"predicates":    "description.Rule.MatchPredicates",
	"rate_key":      "description.Rule.RateKey",
	"rate_limit":    "description.Rule.RateLimit",
	"rule_id":       "description.Rule.RuleId",
	"tags_src":      "description.Tags.TagList",
	"title":         "description.Rule.Name",
}

func ListWAFRateBasedRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRateBasedRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRateBasedRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRateBasedRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRateBasedRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRateBasedRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRateBasedRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFRateBasedRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFRateBasedRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRateBasedRule NewWAFRateBasedRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFRateBasedRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFRateBasedRuleFilters = map[string]string{
	"akas":          "description.ARN",
	"og_account_id": "metadata.SourceID",
	"metric_name":   "description.Rule.MetricName",
	"name":          "description.Rule.Name",
	"predicates":    "description.Rule.MatchPredicates",
	"rate_key":      "description.Rule.RateKey",
	"rate_limit":    "description.Rule.RateLimit",
	"rule_id":       "description.Rule.RuleId",
	"tags_src":      "description.Tags.TagList",
	"title":         "description.Rule.Name",
}

func GetWAFRateBasedRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRateBasedRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFRateBasedRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFRateBasedRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFRateBasedRule =============================

// ==========================  START: WAFRuleGroup =============================

type WAFRuleGroup struct {
	Description   aws.WAFRuleGroupDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type WAFRuleGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFRuleGroup  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFRuleGroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFRuleGroupHit `json:"hits"`
}

type WAFRuleGroupSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  WAFRuleGroupHits `json:"hits"`
}

type WAFRuleGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRuleGroupPaginator(filters []essdk.BoolFilter, limit *int64) (WAFRuleGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_waf_rulegroup", filters, limit)
	if err != nil {
		return WAFRuleGroupPaginator{}, err
	}

	p := WAFRuleGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRuleGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRuleGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFRuleGroupPaginator) NextPage(ctx context.Context) ([]WAFRuleGroup, error) {
	var response WAFRuleGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRuleGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRuleGroupFilters = map[string]string{
	"activated_rules": "description.ActivatedRules",
	"arn":             "description.ARN",
	"og_account_id":   "metadata.SourceID",
	"metric_name":     "description.RuleGroup.RuleGroup.MetricName",
	"name":            "description.RuleGroupSummary.Name",
	"rule_group_id":   "description.RuleGroupSummary.RuleGroupId",
	"tags_src":        "description.Tags",
	"title":           "description.RuleGroupSummary.Name",
}

func ListWAFRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRuleGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRuleGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFRuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFRuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRuleGroup NewWAFRuleGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFRuleGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFRuleGroupFilters = map[string]string{
	"activated_rules": "description.ActivatedRules",
	"arn":             "description.ARN",
	"og_account_id":   "metadata.SourceID",
	"metric_name":     "description.RuleGroup.RuleGroup.MetricName",
	"name":            "description.RuleGroupSummary.Name",
	"rule_group_id":   "description.Rule.RuleId",
	"tags_src":        "description.Tags",
	"title":           "description.RuleGroupSummary.Name",
}

func GetWAFRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFRuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFRuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFRuleGroup =============================

// ==========================  START: WAFWebAcl =============================

type WAFWebAcl struct {
	Description   aws.WAFWebAclDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type WAFWebAclHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WAFWebAcl     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WAFWebAclHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WAFWebAclHit    `json:"hits"`
}

type WAFWebAclSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  WAFWebAclHits `json:"hits"`
}

type WAFWebAclPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFWebAclPaginator(filters []essdk.BoolFilter, limit *int64) (WAFWebAclPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_waf_webacl", filters, limit)
	if err != nil {
		return WAFWebAclPaginator{}, err
	}

	p := WAFWebAclPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFWebAclPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFWebAclPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFWebAclPaginator) NextPage(ctx context.Context) ([]WAFWebAcl, error) {
	var response WAFWebAclSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFWebAcl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFWebAclFilters = map[string]string{
	"arn":                   "description.WebACL.WebACLArn",
	"default_action":        "description.WebACL.DefaultAction.Type",
	"og_account_id":         "metadata.SourceID",
	"logging_configuration": "description.LoggingConfiguration",
	"metric_name":           "description.WebACL.MetricName",
	"name":                  "description.WebACL.Name",
	"rules":                 "description.WebACL.Rules",
	"tags_src":              "description.Tags.TagList",
	"title":                 "description.WebACL.Name",
	"web_acl_id":            "description.WebACL.WebACLId",
}

func ListWAFWebAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFWebAcl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFWebAcl NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFWebAcl NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFWebAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFWebAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFWebAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFWebAclPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFWebAclFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFWebAcl NewWAFWebAclPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFWebAcl paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFWebAclFilters = map[string]string{
	"arn":                   "description.WebACL.WebACLArn",
	"default_action":        "description.WebACL.DefaultAction.Type",
	"og_account_id":         "metadata.SourceID",
	"logging_configuration": "description.LoggingConfiguration",
	"metric_name":           "description.WebACL.MetricName",
	"name":                  "description.WebACL.Name",
	"rules":                 "description.WebACL.Rules",
	"tags_src":              "description.Tags.TagList",
	"title":                 "description.WebACL.Name",
	"web_acl_id":            "description.WebACL.WebACLId",
}

func GetWAFWebAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFWebAcl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFWebAclPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFWebAclFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFWebAcl =============================

// ==========================  START: WellArchitectedWorkload =============================

type WellArchitectedWorkload struct {
	Description   aws.WellArchitectedWorkloadDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type WellArchitectedWorkloadHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  WellArchitectedWorkload `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type WellArchitectedWorkloadHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []WellArchitectedWorkloadHit `json:"hits"`
}

type WellArchitectedWorkloadSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  WellArchitectedWorkloadHits `json:"hits"`
}

type WellArchitectedWorkloadPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedWorkloadPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedWorkloadPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_workload", filters, limit)
	if err != nil {
		return WellArchitectedWorkloadPaginator{}, err
	}

	p := WellArchitectedWorkloadPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedWorkloadPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedWorkloadPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedWorkloadPaginator) NextPage(ctx context.Context) ([]WellArchitectedWorkload, error) {
	var response WellArchitectedWorkloadSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedWorkload
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedWorkloadFilters = map[string]string{
	"account_ids":                         "description.Workload.AccountIds",
	"architectural_design":                "description.Workload.ArchitecturalDesign",
	"aws_regions":                         "description.Workload.AwsRegions",
	"description":                         "description.Workload.Description",
	"environment":                         "description.Workload.Environment",
	"improvement_status":                  "description.Workload.ImprovementStatus",
	"industry":                            "description.Workload.Industry",
	"industry_type":                       "description.Workload.IndustryType",
	"is_review_owner_update_acknowledged": "description.Workload.IsReviewOwnerUpdateAcknowledged",
	"og_account_id":                       "metadata.SourceID",
	"lenses":                              "description.Workload.Lenses",
	"non_aws_regions":                     "description.Workload.NonAwsRegions",
	"notes":                               "description.Workload.Notes",
	"owner":                               "description.Workload.Owner",
	"pillar_priorities":                   "description.Workload.PillarPriorities",
	"review_owner":                        "description.Workload.ReviewOwner",
	"review_restriction_date":             "description.Workload.ReviewRestrictionDate",
	"risk_counts":                         "description.Workload.RiskCounts",
	"share_invitation_id":                 "description.Workload.ShareInvitationId",
	"tags":                                "description.Workload.Tags",
	"title":                               "description.Workload.WorkloadName",
	"updated_at":                          "description.Workload.UpdatedAt",
	"workload_arn":                        "description.Workload.WorkloadArn",
	"workload_id":                         "description.Workload.WorkloadId",
	"workload_name":                       "description.Workload.WorkloadName",
}

func ListWellArchitectedWorkload(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedWorkload")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkload NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkload NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkload GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkload GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkload GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedWorkloadPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedWorkloadFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkload NewWellArchitectedWorkloadPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedWorkload paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedWorkloadFilters = map[string]string{
	"account_ids":                         "description.Workload.AccountIds",
	"architectural_design":                "description.Workload.ArchitecturalDesign",
	"aws_regions":                         "description.Workload.AwsRegions",
	"description":                         "description.Workload.Description",
	"environment":                         "description.Workload.Environment",
	"improvement_status":                  "description.Workload.ImprovementStatus",
	"industry":                            "description.Workload.Industry",
	"industry_type":                       "description.Workload.IndustryType",
	"is_review_owner_update_acknowledged": "description.Workload.IsReviewOwnerUpdateAcknowledged",
	"og_account_id":                       "metadata.SourceID",
	"lenses":                              "description.Workload.Lenses",
	"non_aws_regions":                     "description.Workload.NonAwsRegions",
	"notes":                               "description.Workload.Notes",
	"owner":                               "description.Workload.Owner",
	"pillar_priorities":                   "description.Workload.PillarPriorities",
	"review_owner":                        "description.Workload.ReviewOwner",
	"review_restriction_date":             "description.Workload.ReviewRestrictionDate",
	"risk_counts":                         "description.Workload.RiskCounts",
	"share_invitation_id":                 "description.Workload.ShareInvitationId",
	"tags":                                "description.Workload.Tags",
	"title":                               "description.Workload.WorkloadName",
	"updated_at":                          "description.Workload.UpdatedAt",
	"workload_arn":                        "description.Workload.WorkloadArn",
	"workload_id":                         "description.Workload.WorkloadId",
	"workload_name":                       "description.Workload.WorkloadName",
}

func GetWellArchitectedWorkload(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedWorkload")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedWorkloadPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedWorkloadFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedWorkload =============================

// ==========================  START: WellArchitectedAnswer =============================

type WellArchitectedAnswer struct {
	Description   aws.WellArchitectedAnswerDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type WellArchitectedAnswerHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  WellArchitectedAnswer `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type WellArchitectedAnswerHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []WellArchitectedAnswerHit `json:"hits"`
}

type WellArchitectedAnswerSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  WellArchitectedAnswerHits `json:"hits"`
}

type WellArchitectedAnswerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedAnswerPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedAnswerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_answer", filters, limit)
	if err != nil {
		return WellArchitectedAnswerPaginator{}, err
	}

	p := WellArchitectedAnswerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedAnswerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedAnswerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedAnswerPaginator) NextPage(ctx context.Context) ([]WellArchitectedAnswer, error) {
	var response WellArchitectedAnswerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedAnswer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedAnswerFilters = map[string]string{
	"choice_answers":                "description.Answer.ChoiceAnswers",
	"choices":                       "description.Answer.Choices",
	"helpful_resource_display_text": "description.Answer.HelpfulResourceDisplayText",
	"helpful_resource_url":          "description.Answer.HelpfulResourceUrl",
	"improvement_plan_url":          "description.Answer.ImprovementPlanUrl",
	"is_applicable":                 "description.Answer.IsApplicable",
	"og_account_id":                 "metadata.SourceID",
	"lens_alias":                    "description.LensAlias",
	"lens_arn":                      "description.LensArn",
	"milestone_number":              "description.MilestoneNumber",
	"notes":                         "description.Answer.Notes",
	"pillar_id":                     "description.Answer.PillarId",
	"question_description":          "description.Answer.QuestionDescription",
	"question_id":                   "description.Answer.QuestionId",
	"question_title":                "description.Answer.QuestionTitle",
	"reason":                        "description.Answer.Reason",
	"risk":                          "description.Answer.Risk",
	"selected_choices":              "description.Answer.SelectedChoices",
	"title":                         "description.Answer.QuestionTitle",
	"workload_id":                   "description.WorkloadId",
}

func ListWellArchitectedAnswer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedAnswer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedAnswer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedAnswer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedAnswer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedAnswer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedAnswer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedAnswerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedAnswerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedAnswer NewWellArchitectedAnswerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedAnswer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedAnswerFilters = map[string]string{
	"choice_answers":                "description.Answer.ChoiceAnswers",
	"choices":                       "description.Answer.Choices",
	"helpful_resource_display_text": "description.Answer.HelpfulResourceDisplayText",
	"helpful_resource_url":          "description.Answer.HelpfulResourceUrl",
	"improvement_plan_url":          "description.Answer.ImprovementPlanUrl",
	"is_applicable":                 "description.Answer.IsApplicable",
	"og_account_id":                 "metadata.SourceID",
	"lens_alias":                    "description.LensAlias",
	"lens_arn":                      "description.LensArn",
	"milestone_number":              "description.MilestoneNumber",
	"notes":                         "description.Answer.Notes",
	"pillar_id":                     "description.Answer.PillarId",
	"question_description":          "description.Answer.QuestionDescription",
	"question_id":                   "description.Answer.QuestionId",
	"question_title":                "description.Answer.QuestionTitle",
	"reason":                        "description.Answer.Reason",
	"risk":                          "description.Answer.Risk",
	"selected_choices":              "description.Answer.SelectedChoices",
	"title":                         "description.Answer.QuestionTitle",
	"workload_id":                   "description.WorkloadId",
}

func GetWellArchitectedAnswer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedAnswer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedAnswerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedAnswerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedAnswer =============================

// ==========================  START: WellArchitectedCheckDetail =============================

type WellArchitectedCheckDetail struct {
	Description   aws.WellArchitectedCheckDetailDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type WellArchitectedCheckDetailHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  WellArchitectedCheckDetail `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type WellArchitectedCheckDetailHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []WellArchitectedCheckDetailHit `json:"hits"`
}

type WellArchitectedCheckDetailSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  WellArchitectedCheckDetailHits `json:"hits"`
}

type WellArchitectedCheckDetailPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedCheckDetailPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedCheckDetailPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_checkdetail", filters, limit)
	if err != nil {
		return WellArchitectedCheckDetailPaginator{}, err
	}

	p := WellArchitectedCheckDetailPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedCheckDetailPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedCheckDetailPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedCheckDetailPaginator) NextPage(ctx context.Context) ([]WellArchitectedCheckDetail, error) {
	var response WellArchitectedCheckDetailSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedCheckDetail
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedCheckDetailFilters = map[string]string{
	"choice_id":         "description.CheckDetail.ChoiceId",
	"description":       "description.CheckDetail.Description",
	"flagged_resources": "description.CheckDetail.FlaggedResources",
	"id":                "description.CheckDetail.Id",
	"og_account_id":     "metadata.SourceID",
	"lens_arn":          "description.CheckDetail.LensArn",
	"name":              "description.CheckDetail.Name",
	"owner_account_id":  "description.CheckDetail.AccountId",
	"pillar_id":         "description.CheckDetail.PillarId",
	"provider":          "description.CheckDetail.Provider",
	"question_id":       "description.CheckDetail.QuestionId",
	"reason":            "description.CheckDetail.Reason",
	"status":            "description.CheckDetail.Status",
	"title":             "description.CheckDetail.Name",
	"updated_at":        "description.CheckDetail.UpdatedAt",
	"workload_id":       "description.WorkloadId",
}

func ListWellArchitectedCheckDetail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedCheckDetail")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckDetail NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckDetail NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckDetail GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckDetail GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckDetail GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedCheckDetailPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedCheckDetailFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckDetail NewWellArchitectedCheckDetailPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedCheckDetail paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedCheckDetailFilters = map[string]string{
	"choice_id":         "description.CheckDetail.ChoiceId",
	"description":       "description.CheckDetail.Description",
	"flagged_resources": "description.CheckDetail.FlaggedResources",
	"id":                "description.CheckDetail.Id",
	"og_account_id":     "metadata.SourceID",
	"lens_arn":          "description.CheckDetail.LensArn",
	"name":              "description.CheckDetail.Name",
	"owner_account_id":  "description.CheckDetail.AccountId",
	"pillar_id":         "description.CheckDetail.PillarId",
	"provider":          "description.CheckDetail.Provider",
	"question_id":       "description.CheckDetail.QuestionId",
	"reason":            "description.CheckDetail.Reason",
	"status":            "description.CheckDetail.Status",
	"title":             "description.CheckDetail.Name",
	"updated_at":        "description.CheckDetail.UpdatedAt",
	"workload_id":       "description.WorkloadId",
}

func GetWellArchitectedCheckDetail(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedCheckDetail")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedCheckDetailPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedCheckDetailFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedCheckDetail =============================

// ==========================  START: WellArchitectedCheckSummary =============================

type WellArchitectedCheckSummary struct {
	Description   aws.WellArchitectedCheckSummaryDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type WellArchitectedCheckSummaryHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  WellArchitectedCheckSummary `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type WellArchitectedCheckSummaryHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []WellArchitectedCheckSummaryHit `json:"hits"`
}

type WellArchitectedCheckSummarySearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  WellArchitectedCheckSummaryHits `json:"hits"`
}

type WellArchitectedCheckSummaryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedCheckSummaryPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedCheckSummaryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_checksummary", filters, limit)
	if err != nil {
		return WellArchitectedCheckSummaryPaginator{}, err
	}

	p := WellArchitectedCheckSummaryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedCheckSummaryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedCheckSummaryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedCheckSummaryPaginator) NextPage(ctx context.Context) ([]WellArchitectedCheckSummary, error) {
	var response WellArchitectedCheckSummarySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedCheckSummary
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedCheckSummaryFilters = map[string]string{
	"account_summary": "description.CheckSummary.AccountSummary",
	"choice_id":       "description.CheckSummary.ChoiceId",
	"description":     "description.CheckSummary.Description",
	"id":              "description.CheckSummary.ChoiceId",
	"og_account_id":   "metadata.SourceID",
	"lens_arn":        "description.CheckSummary.LensArn",
	"name":            "description.CheckSummary.Name",
	"pillar_id":       "description.CheckSummary.PillarId",
	"provider":        "description.CheckSummary.Provider",
	"question_id":     "description.CheckSummary.QuestionId",
	"status":          "description.CheckSummary.Status",
	"title":           "name",
	"updated_at":      "description.CheckSummary.UpdatedAt",
	"workload_id":     "description.WorkloadId",
}

func ListWellArchitectedCheckSummary(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedCheckSummary")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckSummary NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckSummary NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckSummary GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckSummary GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckSummary GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedCheckSummaryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedCheckSummaryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckSummary NewWellArchitectedCheckSummaryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedCheckSummary paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedCheckSummaryFilters = map[string]string{
	"account_summary": "description.CheckSummary.AccountSummary",
	"choice_id":       "description.CheckSummary.ChoiceId",
	"description":     "description.CheckSummary.Description",
	"id":              "description.CheckSummary.ChoiceId",
	"og_account_id":   "metadata.SourceID",
	"lens_arn":        "description.CheckSummary.LensArn",
	"name":            "description.CheckSummary.Name",
	"pillar_id":       "description.CheckSummary.PillarId",
	"provider":        "description.CheckSummary.Provider",
	"question_id":     "description.CheckSummary.QuestionId",
	"status":          "description.CheckSummary.Status",
	"title":           "name",
	"updated_at":      "description.CheckSummary.UpdatedAt",
	"workload_id":     "description.WorkloadId",
}

func GetWellArchitectedCheckSummary(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedCheckSummary")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedCheckSummaryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedCheckSummaryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedCheckSummary =============================

// ==========================  START: WellArchitectedCheckConsolidatedReport =============================

type WellArchitectedCheckConsolidatedReport struct {
	Description   aws.WellArchitectedCheckConsolidatedReportDescription `json:"description"`
	Metadata      aws.Metadata                                          `json:"metadata"`
	ResourceJobID int                                                   `json:"resource_job_id"`
	SourceJobID   int                                                   `json:"source_job_id"`
	ResourceType  string                                                `json:"resource_type"`
	SourceType    string                                                `json:"source_type"`
	ID            string                                                `json:"id"`
	ARN           string                                                `json:"arn"`
	SourceID      string                                                `json:"source_id"`
}

type WellArchitectedCheckConsolidatedReportHit struct {
	ID      string                                 `json:"_id"`
	Score   float64                                `json:"_score"`
	Index   string                                 `json:"_index"`
	Type    string                                 `json:"_type"`
	Version int64                                  `json:"_version,omitempty"`
	Source  WellArchitectedCheckConsolidatedReport `json:"_source"`
	Sort    []interface{}                          `json:"sort"`
}

type WellArchitectedCheckConsolidatedReportHits struct {
	Total essdk.SearchTotal                           `json:"total"`
	Hits  []WellArchitectedCheckConsolidatedReportHit `json:"hits"`
}

type WellArchitectedCheckConsolidatedReportSearchResponse struct {
	PitID string                                     `json:"pit_id"`
	Hits  WellArchitectedCheckConsolidatedReportHits `json:"hits"`
}

type WellArchitectedCheckConsolidatedReportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedCheckConsolidatedReportPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedCheckConsolidatedReportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_consolidatedreport", filters, limit)
	if err != nil {
		return WellArchitectedCheckConsolidatedReportPaginator{}, err
	}

	p := WellArchitectedCheckConsolidatedReportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedCheckConsolidatedReportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedCheckConsolidatedReportPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedCheckConsolidatedReportPaginator) NextPage(ctx context.Context) ([]WellArchitectedCheckConsolidatedReport, error) {
	var response WellArchitectedCheckConsolidatedReportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedCheckConsolidatedReport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedCheckConsolidatedReportFilters = map[string]string{
	"base64_string":            "description.Base64",
	"include_shared_resources": "description.ConsolidateReport.WorkloadId",
	"og_account_id":            "metadata.SourceID",
	"lenses":                   "description.ConsolidateReport.Lenses",
	"lenses_applied_count":     "description.ConsolidateReport.LensesAppliedCount",
	"metric_type":              "description.ConsolidateReport.MetricType",
	"risk_counts":              "description.ConsolidateReport.RiskCounts",
	"updated_at":               "description.ConsolidateReport.UpdatedAt",
	"workload_arn":             "description.ConsolidateReport.WorkloadArn",
	"workload_id":              "description.ConsolidateReport.WorkloadId",
	"workload_name":            "description.ConsolidateReport.WorkloadName",
}

func ListWellArchitectedCheckConsolidatedReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedCheckConsolidatedReport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckConsolidatedReport NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckConsolidatedReport NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckConsolidatedReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckConsolidatedReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckConsolidatedReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedCheckConsolidatedReportPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedCheckConsolidatedReportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedCheckConsolidatedReport NewWellArchitectedCheckConsolidatedReportPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedCheckConsolidatedReport paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedCheckConsolidatedReportFilters = map[string]string{
	"base64_string":            "description.Base64",
	"include_shared_resources": "description.ConsolidateReport.WorkloadId",
	"og_account_id":            "metadata.SourceID",
	"lenses":                   "description.ConsolidateReport.Lenses",
	"lenses_applied_count":     "description.ConsolidateReport.LensesAppliedCount",
	"metric_type":              "description.ConsolidateReport.MetricType",
	"risk_counts":              "description.ConsolidateReport.RiskCounts",
	"updated_at":               "description.ConsolidateReport.UpdatedAt",
	"workload_arn":             "description.ConsolidateReport.WorkloadArn",
	"workload_id":              "description.ConsolidateReport.WorkloadId",
	"workload_name":            "description.ConsolidateReport.WorkloadName",
}

func GetWellArchitectedCheckConsolidatedReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedCheckConsolidatedReport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedCheckConsolidatedReportPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedCheckConsolidatedReportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedCheckConsolidatedReport =============================

// ==========================  START: WellArchitectedLens =============================

type WellArchitectedLens struct {
	Description   aws.WellArchitectedLensDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type WellArchitectedLensHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  WellArchitectedLens `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type WellArchitectedLensHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []WellArchitectedLensHit `json:"hits"`
}

type WellArchitectedLensSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  WellArchitectedLensHits `json:"hits"`
}

type WellArchitectedLensPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedLensPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedLensPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_lens", filters, limit)
	if err != nil {
		return WellArchitectedLensPaginator{}, err
	}

	p := WellArchitectedLensPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedLensPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedLensPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedLensPaginator) NextPage(ctx context.Context) ([]WellArchitectedLens, error) {
	var response WellArchitectedLensSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedLens
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedLensFilters = map[string]string{
	"arn":                 "description.LensSummary.LensArn",
	"created_at":          "description.LensSummary.CreatedAt",
	"description":         "description.LensSummary.Description",
	"og_account_id":       "metadata.SourceID",
	"lens_alias":          "description.LensSummary.LensAlias",
	"lens_name":           "description.LensSummary.LensName",
	"lens_status":         "description.LensSummary.LensStatus",
	"lens_version":        "description.LensSummary.LensVersion",
	"owner":               "description.LensSummary.Owner",
	"share_invitation_id": "description.Lens.ShareInvitationId",
	"tags":                "description.Lens.Tags",
	"title":               "description.Lens.Name",
	"updated_at":          "description.LensSummary.UpdatedAt",
}

func ListWellArchitectedLens(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedLens")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLens NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLens NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLens GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLens GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLens GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedLensPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedLensFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLens NewWellArchitectedLensPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedLens paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedLensFilters = map[string]string{
	"arn":                 "description.LensSummary.LensArn",
	"created_at":          "description.LensSummary.CreatedAt",
	"description":         "description.LensSummary.Description",
	"og_account_id":       "metadata.SourceID",
	"lens_alias":          "description.LensSummary.LensAlias",
	"lens_name":           "description.LensSummary.LensName",
	"lens_status":         "description.LensSummary.LensStatus",
	"lens_version":        "description.LensSummary.LensVersion",
	"owner":               "description.LensSummary.Owner",
	"share_invitation_id": "description.Lens.ShareInvitationId",
	"tags":                "description.Lens.Tags",
	"title":               "description.Lens.Name",
	"updated_at":          "description.LensSummary.UpdatedAt",
}

func GetWellArchitectedLens(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedLens")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedLensPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedLensFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedLens =============================

// ==========================  START: WellArchitectedLensReview =============================

type WellArchitectedLensReview struct {
	Description   aws.WellArchitectedLensReviewDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type WellArchitectedLensReviewHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  WellArchitectedLensReview `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type WellArchitectedLensReviewHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []WellArchitectedLensReviewHit `json:"hits"`
}

type WellArchitectedLensReviewSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  WellArchitectedLensReviewHits `json:"hits"`
}

type WellArchitectedLensReviewPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedLensReviewPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedLensReviewPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_lensreview", filters, limit)
	if err != nil {
		return WellArchitectedLensReviewPaginator{}, err
	}

	p := WellArchitectedLensReviewPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedLensReviewPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedLensReviewPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedLensReviewPaginator) NextPage(ctx context.Context) ([]WellArchitectedLensReview, error) {
	var response WellArchitectedLensReviewSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedLensReview
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedLensReviewFilters = map[string]string{
	"og_account_id":           "metadata.SourceID",
	"lens_alias":              "description.LensReview.LensAlias",
	"lens_arn":                "description.LensReview.LensArn",
	"lens_name":               "description.LensReview.LensName",
	"lens_status":             "description.LensReview.LensStatus",
	"lens_version":            "description.LensReview.LensVersion",
	"notes":                   "description.LensReview.Notes",
	"pillar_review_summaries": "description.LensReview.PillarReviewSummaries",
	"risk_counts":             "description.LensReview.RiskCounts",
	"title":                   "description.LensReview.LensName",
	"updated_at":              "description.LensReview.UpdatedAt",
}

func ListWellArchitectedLensReview(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedLensReview")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReview NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReview NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReview GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReview GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReview GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedLensReviewPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedLensReviewFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReview NewWellArchitectedLensReviewPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedLensReview paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedLensReviewFilters = map[string]string{
	"og_account_id":           "metadata.SourceID",
	"lens_alias":              "description.LensReview.LensAlias",
	"lens_arn":                "description.LensReview.LensArn",
	"lens_name":               "description.LensReview.LensName",
	"lens_status":             "description.LensReview.LensStatus",
	"lens_version":            "description.LensReview.LensVersion",
	"notes":                   "description.LensReview.Notes",
	"pillar_review_summaries": "description.LensReview.PillarReviewSummaries",
	"risk_counts":             "description.LensReview.RiskCounts",
	"title":                   "description.LensReview.LensName",
	"updated_at":              "description.LensReview.UpdatedAt",
}

func GetWellArchitectedLensReview(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedLensReview")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedLensReviewPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedLensReviewFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedLensReview =============================

// ==========================  START: WellArchitectedLensReviewImprovement =============================

type WellArchitectedLensReviewImprovement struct {
	Description   aws.WellArchitectedLensReviewImprovementDescription `json:"description"`
	Metadata      aws.Metadata                                        `json:"metadata"`
	ResourceJobID int                                                 `json:"resource_job_id"`
	SourceJobID   int                                                 `json:"source_job_id"`
	ResourceType  string                                              `json:"resource_type"`
	SourceType    string                                              `json:"source_type"`
	ID            string                                              `json:"id"`
	ARN           string                                              `json:"arn"`
	SourceID      string                                              `json:"source_id"`
}

type WellArchitectedLensReviewImprovementHit struct {
	ID      string                               `json:"_id"`
	Score   float64                              `json:"_score"`
	Index   string                               `json:"_index"`
	Type    string                               `json:"_type"`
	Version int64                                `json:"_version,omitempty"`
	Source  WellArchitectedLensReviewImprovement `json:"_source"`
	Sort    []interface{}                        `json:"sort"`
}

type WellArchitectedLensReviewImprovementHits struct {
	Total essdk.SearchTotal                         `json:"total"`
	Hits  []WellArchitectedLensReviewImprovementHit `json:"hits"`
}

type WellArchitectedLensReviewImprovementSearchResponse struct {
	PitID string                                   `json:"pit_id"`
	Hits  WellArchitectedLensReviewImprovementHits `json:"hits"`
}

type WellArchitectedLensReviewImprovementPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedLensReviewImprovementPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedLensReviewImprovementPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_lensreviewimprovement", filters, limit)
	if err != nil {
		return WellArchitectedLensReviewImprovementPaginator{}, err
	}

	p := WellArchitectedLensReviewImprovementPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedLensReviewImprovementPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedLensReviewImprovementPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedLensReviewImprovementPaginator) NextPage(ctx context.Context) ([]WellArchitectedLensReviewImprovement, error) {
	var response WellArchitectedLensReviewImprovementSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedLensReviewImprovement
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedLensReviewImprovementFilters = map[string]string{
	"improvement_plan_url": "description.ImprovementSummary.ImprovementPlanUrl",
	"improvement_plans":    "description.ImprovementSummary.ImprovementPlans",
	"og_account_id":        "metadata.SourceID",
	"lens_alias":           "description.LensAlias",
	"lens_arn":             "description.LensArn",
	"milestone_number":     "description.MilestoneNumber",
	"pillar_id":            "description.ImprovementSummary.PillarId",
	"question_id":          "description.ImprovementSummary.QuestionId",
	"question_title":       "description.ImprovementSummary.QuestionTitle",
	"risk":                 "description.ImprovementSummary.Risk",
	"title":                "description.ImprovementSummary.QuestionTitle",
	"workload_id":          "description.WorkloadId",
}

func ListWellArchitectedLensReviewImprovement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedLensReviewImprovement")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewImprovement NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewImprovement NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewImprovement GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewImprovement GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewImprovement GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedLensReviewImprovementPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedLensReviewImprovementFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewImprovement NewWellArchitectedLensReviewImprovementPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedLensReviewImprovement paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedLensReviewImprovementFilters = map[string]string{
	"improvement_plan_url": "description.ImprovementSummary.ImprovementPlanUrl",
	"improvement_plans":    "description.ImprovementSummary.ImprovementPlans",
	"og_account_id":        "metadata.SourceID",
	"lens_alias":           "description.LensAlias",
	"lens_arn":             "description.LensArn",
	"milestone_number":     "description.MilestoneNumber",
	"pillar_id":            "description.ImprovementSummary.PillarId",
	"question_id":          "description.ImprovementSummary.QuestionId",
	"question_title":       "description.ImprovementSummary.QuestionTitle",
	"risk":                 "description.ImprovementSummary.Risk",
	"title":                "description.ImprovementSummary.QuestionTitle",
	"workload_id":          "description.WorkloadId",
}

func GetWellArchitectedLensReviewImprovement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedLensReviewImprovement")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedLensReviewImprovementPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedLensReviewImprovementFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedLensReviewImprovement =============================

// ==========================  START: WellArchitectedLensReviewReport =============================

type WellArchitectedLensReviewReport struct {
	Description   aws.WellArchitectedLensReviewReportDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type WellArchitectedLensReviewReportHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  WellArchitectedLensReviewReport `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type WellArchitectedLensReviewReportHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []WellArchitectedLensReviewReportHit `json:"hits"`
}

type WellArchitectedLensReviewReportSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  WellArchitectedLensReviewReportHits `json:"hits"`
}

type WellArchitectedLensReviewReportPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedLensReviewReportPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedLensReviewReportPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_lensreviewreport", filters, limit)
	if err != nil {
		return WellArchitectedLensReviewReportPaginator{}, err
	}

	p := WellArchitectedLensReviewReportPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedLensReviewReportPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedLensReviewReportPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedLensReviewReportPaginator) NextPage(ctx context.Context) ([]WellArchitectedLensReviewReport, error) {
	var response WellArchitectedLensReviewReportSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedLensReviewReport
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedLensReviewReportFilters = map[string]string{
	"base64_string":    "description.Report.Base64String",
	"og_account_id":    "metadata.SourceID",
	"lens_alias":       "description.Report.LensAlias",
	"lens_arn":         "description.Report.LensArn",
	"milestone_number": "description.MilestoneNumber",
	"workload_id":      "description.WorkloadId",
}

func ListWellArchitectedLensReviewReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedLensReviewReport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewReport NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewReport NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewReport GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedLensReviewReportPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedLensReviewReportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensReviewReport NewWellArchitectedLensReviewReportPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedLensReviewReport paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedLensReviewReportFilters = map[string]string{
	"base64_string":    "description.Report.Base64String",
	"og_account_id":    "metadata.SourceID",
	"lens_alias":       "description.Report.LensAlias",
	"lens_arn":         "description.Report.LensArn",
	"milestone_number": "description.MilestoneNumber",
	"workload_id":      "description.WorkloadId",
}

func GetWellArchitectedLensReviewReport(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedLensReviewReport")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedLensReviewReportPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedLensReviewReportFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedLensReviewReport =============================

// ==========================  START: WellArchitectedLensShare =============================

type WellArchitectedLensShare struct {
	Description   aws.WellArchitectedLensShareDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type WellArchitectedLensShareHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  WellArchitectedLensShare `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type WellArchitectedLensShareHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []WellArchitectedLensShareHit `json:"hits"`
}

type WellArchitectedLensShareSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  WellArchitectedLensShareHits `json:"hits"`
}

type WellArchitectedLensSharePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedLensSharePaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedLensSharePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_lensshare", filters, limit)
	if err != nil {
		return WellArchitectedLensSharePaginator{}, err
	}

	p := WellArchitectedLensSharePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedLensSharePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedLensSharePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedLensSharePaginator) NextPage(ctx context.Context) ([]WellArchitectedLensShare, error) {
	var response WellArchitectedLensShareSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedLensShare
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedLensShareFilters = map[string]string{
	"og_account_id":  "metadata.SourceID",
	"lens_alias":     "description.Lens.LensAlias",
	"lens_arn":       "description.Lens.LensArn",
	"lens_name":      "description.Lens.Name",
	"share_id":       "description.Share.ShareId",
	"shared_with":    "description.Share.SharedWith",
	"status":         "description.Share.Status",
	"status_message": "description.Share.StatusMessage",
	"title":          "description.Share.ShareId",
}

func ListWellArchitectedLensShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedLensShare")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensShare NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensShare NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedLensSharePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedLensShareFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedLensShare NewWellArchitectedLensSharePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedLensShare paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedLensShareFilters = map[string]string{
	"og_account_id":  "metadata.SourceID",
	"lens_alias":     "description.Lens.LensAlias",
	"lens_arn":       "description.Lens.LensArn",
	"lens_name":      "description.Lens.Name",
	"share_id":       "description.Share.ShareId",
	"shared_with":    "description.Share.SharedWith",
	"status":         "description.Share.Status",
	"status_message": "description.Share.StatusMessage",
	"title":          "description.Share.ShareId",
}

func GetWellArchitectedLensShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedLensShare")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedLensSharePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedLensShareFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedLensShare =============================

// ==========================  START: WellArchitectedMilestone =============================

type WellArchitectedMilestone struct {
	Description   aws.WellArchitectedMilestoneDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type WellArchitectedMilestoneHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  WellArchitectedMilestone `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type WellArchitectedMilestoneHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []WellArchitectedMilestoneHit `json:"hits"`
}

type WellArchitectedMilestoneSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  WellArchitectedMilestoneHits `json:"hits"`
}

type WellArchitectedMilestonePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedMilestonePaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedMilestonePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_milestone", filters, limit)
	if err != nil {
		return WellArchitectedMilestonePaginator{}, err
	}

	p := WellArchitectedMilestonePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedMilestonePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedMilestonePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedMilestonePaginator) NextPage(ctx context.Context) ([]WellArchitectedMilestone, error) {
	var response WellArchitectedMilestoneSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedMilestone
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedMilestoneFilters = map[string]string{
	"og_account_id":    "metadata.SourceID",
	"milestone_name":   "description.Milestone.MilestoneName",
	"milestone_number": "description.Milestone.MilestoneNumber",
	"recorded_at":      "description.Milestone.RecordedAt",
	"workload":         "description.Milestone.Workload",
	"workload_id":      "description.Milestone.Workload.WorkloadId",
}

func ListWellArchitectedMilestone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedMilestone")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedMilestone NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedMilestone NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedMilestone GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedMilestone GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedMilestone GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedMilestonePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedMilestoneFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedMilestone NewWellArchitectedMilestonePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedMilestone paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedMilestoneFilters = map[string]string{
	"og_account_id":    "metadata.SourceID",
	"milestone_name":   "description.Milestone.MilestoneName",
	"milestone_number": "description.Milestone.MilestoneNumber",
	"recorded_at":      "description.Milestone.RecordedAt",
	"workload":         "description.Milestone.Workload",
	"workload_id":      "description.Milestone.Workload.WorkloadId",
}

func GetWellArchitectedMilestone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedMilestone")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedMilestonePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedMilestoneFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedMilestone =============================

// ==========================  START: WellArchitectedNotification =============================

type WellArchitectedNotification struct {
	Description   aws.WellArchitectedNotificationDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type WellArchitectedNotificationHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  WellArchitectedNotification `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type WellArchitectedNotificationHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []WellArchitectedNotificationHit `json:"hits"`
}

type WellArchitectedNotificationSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  WellArchitectedNotificationHits `json:"hits"`
}

type WellArchitectedNotificationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedNotificationPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedNotificationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_notification", filters, limit)
	if err != nil {
		return WellArchitectedNotificationPaginator{}, err
	}

	p := WellArchitectedNotificationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedNotificationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedNotificationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedNotificationPaginator) NextPage(ctx context.Context) ([]WellArchitectedNotification, error) {
	var response WellArchitectedNotificationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedNotification
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedNotificationFilters = map[string]string{
	"current_lens_version": "description.Notification.LensUpgradeSummary.CurrentLensVersion",
	"og_account_id":        "metadata.SourceID",
	"latest_lens_version":  "description.Notification.LensUpgradeSummary.LatestLensVersion",
	"lens_alias":           "description.Notification.LensUpgradeSummary.LensAlias",
	"lens_arn":             "description.Notification.LensUpgradeSummary.LensArn",
	"type":                 "description.Notification.Type",
	"workload_id":          "description.Notification.LensUpgradeSummary.WorkloadId",
	"workload_name":        "description.Notification.LensUpgradeSummary.WorkloadName",
}

func ListWellArchitectedNotification(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedNotification")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedNotification NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedNotification NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedNotification GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedNotification GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedNotification GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedNotificationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedNotificationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedNotification NewWellArchitectedNotificationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedNotification paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedNotificationFilters = map[string]string{
	"current_lens_version": "description.Notification.LensUpgradeSummary.CurrentLensVersion",
	"og_account_id":        "metadata.SourceID",
	"latest_lens_version":  "description.Notification.LensUpgradeSummary.LatestLensVersion",
	"lens_alias":           "description.Notification.LensUpgradeSummary.LensAlias",
	"lens_arn":             "description.Notification.LensUpgradeSummary.LensArn",
	"type":                 "description.Notification.Type",
	"workload_id":          "description.Notification.LensUpgradeSummary.WorkloadId",
	"workload_name":        "description.Notification.LensUpgradeSummary.WorkloadName",
}

func GetWellArchitectedNotification(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedNotification")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedNotificationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedNotificationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedNotification =============================

// ==========================  START: WellArchitectedShareInvitation =============================

type WellArchitectedShareInvitation struct {
	Description   aws.WellArchitectedShareInvitationDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type WellArchitectedShareInvitationHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  WellArchitectedShareInvitation `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type WellArchitectedShareInvitationHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []WellArchitectedShareInvitationHit `json:"hits"`
}

type WellArchitectedShareInvitationSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  WellArchitectedShareInvitationHits `json:"hits"`
}

type WellArchitectedShareInvitationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedShareInvitationPaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedShareInvitationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_shareinvitation", filters, limit)
	if err != nil {
		return WellArchitectedShareInvitationPaginator{}, err
	}

	p := WellArchitectedShareInvitationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedShareInvitationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedShareInvitationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedShareInvitationPaginator) NextPage(ctx context.Context) ([]WellArchitectedShareInvitation, error) {
	var response WellArchitectedShareInvitationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedShareInvitation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedShareInvitationFilters = map[string]string{
	"og_account_id":       "metadata.SourceID",
	"lens_arn":            "description.ShareInvitation.LensArn",
	"lens_name":           "description.ShareInvitation.LensName",
	"permission_type":     "description.ShareInvitation.PermissionType",
	"share_invitation_id": "description.ShareInvitation.ShareInvitationId",
	"shared_by":           "description.ShareInvitation.SharedBy",
	"shared_with":         "description.ShareInvitation.SharedWith",
	"title":               "description.ShareInvitation.ShareInvitationId",
	"workload_id":         "description.ShareInvitation.WorkloadId",
	"workload_name":       "description.ShareInvitation.WorkloadName",
}

func ListWellArchitectedShareInvitation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedShareInvitation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedShareInvitation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedShareInvitation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedShareInvitation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedShareInvitation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedShareInvitation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedShareInvitationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedShareInvitationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedShareInvitation NewWellArchitectedShareInvitationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedShareInvitation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedShareInvitationFilters = map[string]string{
	"og_account_id":       "metadata.SourceID",
	"lens_arn":            "description.ShareInvitation.LensArn",
	"lens_name":           "description.ShareInvitation.LensName",
	"permission_type":     "description.ShareInvitation.PermissionType",
	"share_invitation_id": "description.ShareInvitation.ShareInvitationId",
	"shared_by":           "description.ShareInvitation.SharedBy",
	"shared_with":         "description.ShareInvitation.SharedWith",
	"title":               "description.ShareInvitation.ShareInvitationId",
	"workload_id":         "description.ShareInvitation.WorkloadId",
	"workload_name":       "description.ShareInvitation.WorkloadName",
}

func GetWellArchitectedShareInvitation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedShareInvitation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedShareInvitationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedShareInvitationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedShareInvitation =============================

// ==========================  START: WellArchitectedWorkloadShare =============================

type WellArchitectedWorkloadShare struct {
	Description   aws.WellArchitectedWorkloadShareDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type WellArchitectedWorkloadShareHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  WellArchitectedWorkloadShare `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type WellArchitectedWorkloadShareHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []WellArchitectedWorkloadShareHit `json:"hits"`
}

type WellArchitectedWorkloadShareSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  WellArchitectedWorkloadShareHits `json:"hits"`
}

type WellArchitectedWorkloadSharePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWellArchitectedWorkloadSharePaginator(filters []essdk.BoolFilter, limit *int64) (WellArchitectedWorkloadSharePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wellarchitected_workloadshare", filters, limit)
	if err != nil {
		return WellArchitectedWorkloadSharePaginator{}, err
	}

	p := WellArchitectedWorkloadSharePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WellArchitectedWorkloadSharePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WellArchitectedWorkloadSharePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WellArchitectedWorkloadSharePaginator) NextPage(ctx context.Context) ([]WellArchitectedWorkloadShare, error) {
	var response WellArchitectedWorkloadShareSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WellArchitectedWorkloadShare
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWellArchitectedWorkloadShareFilters = map[string]string{
	"akas":            "description.Arn",
	"og_account_id":   "metadata.SourceID",
	"permission_type": "description.Share.PermissionType",
	"share_id":        "description.Share.ShareId",
	"shared_with":     "description.Share.SharedWith",
	"status":          "description.Share.Status",
	"status_message":  "description.Share.StatusMessage",
	"title":           "description.Share.ShareId",
	"workload_id":     "description.WorkloadId",
}

func ListWellArchitectedWorkloadShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWellArchitectedWorkloadShare")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkloadShare NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkloadShare NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkloadShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkloadShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkloadShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWellArchitectedWorkloadSharePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWellArchitectedWorkloadShareFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWellArchitectedWorkloadShare NewWellArchitectedWorkloadSharePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWellArchitectedWorkloadShare paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWellArchitectedWorkloadShareFilters = map[string]string{
	"akas":            "description.Arn",
	"og_account_id":   "metadata.SourceID",
	"permission_type": "description.Share.PermissionType",
	"share_id":        "description.Share.ShareId",
	"shared_with":     "description.Share.SharedWith",
	"status":          "description.Share.Status",
	"status_message":  "description.Share.StatusMessage",
	"title":           "description.Share.ShareId",
	"workload_id":     "description.WorkloadId",
}

func GetWellArchitectedWorkloadShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWellArchitectedWorkloadShare")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWellArchitectedWorkloadSharePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWellArchitectedWorkloadShareFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WellArchitectedWorkloadShare =============================

// ==========================  START: WAFRegionalWebAcl =============================

type WAFRegionalWebAcl struct {
	Description   aws.WAFRegionalWebAclDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type WAFRegionalWebAclHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  WAFRegionalWebAcl `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type WAFRegionalWebAclHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []WAFRegionalWebAclHit `json:"hits"`
}

type WAFRegionalWebAclSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  WAFRegionalWebAclHits `json:"hits"`
}

type WAFRegionalWebAclPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRegionalWebAclPaginator(filters []essdk.BoolFilter, limit *int64) (WAFRegionalWebAclPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafregional_webacl", filters, limit)
	if err != nil {
		return WAFRegionalWebAclPaginator{}, err
	}

	p := WAFRegionalWebAclPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRegionalWebAclPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRegionalWebAclPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFRegionalWebAclPaginator) NextPage(ctx context.Context) ([]WAFRegionalWebAcl, error) {
	var response WAFRegionalWebAclSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRegionalWebAcl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRegionalWebAclFilters = map[string]string{
	"arn":                   "description.WebACL.WebACLArn",
	"default_action":        "description.WebACL.DefaultAction",
	"og_account_id":         "metadata.SourceID",
	"logging_configuration": "description.LoggingConfiguration",
	"metric_name":           "description.WebACL.MetricName",
	"name":                  "description.WebACL.Name",
	"resources":             "description.AssociatedResources",
	"rules":                 "description.WebACL.Rules",
	"tags":                  "description.Tags",
	"tags_src":              "description.Tags",
	"title":                 "description.WebACL.Name",
	"web_acl_id":            "description.WebACL.WebACLId",
}

func ListWAFRegionalWebAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRegionalWebAcl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalWebAcl NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalWebAcl NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalWebAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalWebAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalWebAcl GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFRegionalWebAclPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFRegionalWebAclFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalWebAcl NewWAFRegionalWebAclPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFRegionalWebAcl paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFRegionalWebAclFilters = map[string]string{
	"arn":                   "description.WebACL.WebACLArn",
	"default_action":        "description.WebACL.DefaultAction",
	"og_account_id":         "metadata.SourceID",
	"logging_configuration": "description.LoggingConfiguration",
	"metric_name":           "description.WebACL.MetricName",
	"name":                  "description.WebACL.Name",
	"resources":             "description.AssociatedResources",
	"rules":                 "description.WebACL.Rules",
	"tags":                  "description.Tags",
	"tags_src":              "description.Tags",
	"title":                 "description.WebACL.Name",
	"web_acl_id":            "description.WebACL.WebACLId",
}

func GetWAFRegionalWebAcl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRegionalWebAcl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFRegionalWebAclPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFRegionalWebAclFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFRegionalWebAcl =============================

// ==========================  START: WAFRegionalRuleGroup =============================

type WAFRegionalRuleGroup struct {
	Description   aws.WAFRegionalRuleGroupDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type WAFRegionalRuleGroupHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  WAFRegionalRuleGroup `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type WAFRegionalRuleGroupHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []WAFRegionalRuleGroupHit `json:"hits"`
}

type WAFRegionalRuleGroupSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  WAFRegionalRuleGroupHits `json:"hits"`
}

type WAFRegionalRuleGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWAFRegionalRuleGroupPaginator(filters []essdk.BoolFilter, limit *int64) (WAFRegionalRuleGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_wafregional_rulegroup", filters, limit)
	if err != nil {
		return WAFRegionalRuleGroupPaginator{}, err
	}

	p := WAFRegionalRuleGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WAFRegionalRuleGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WAFRegionalRuleGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WAFRegionalRuleGroupPaginator) NextPage(ctx context.Context) ([]WAFRegionalRuleGroup, error) {
	var response WAFRegionalRuleGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WAFRegionalRuleGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWAFRegionalRuleGroupFilters = map[string]string{
	"activated_rules": "description.ActivatedRules",
	"akas":            "description.ARN",
	"arn":             "description.ARN",
	"og_account_id":   "metadata.SourceID",
	"metric_name":     "description.RuleGroup.MetricName",
	"name":            "description.RuleGroup.Name",
	"rule_group_id":   "description.RuleGroup.RuleGroupId",
	"tags":            "description.Tags",
	"tags_src":        "description.Tags",
	"title":           "description.RuleGroup.Name",
}

func ListWAFRegionalRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWAFRegionalRuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRuleGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRuleGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWAFRegionalRuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWAFRegionalRuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWAFRegionalRuleGroup NewWAFRegionalRuleGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWAFRegionalRuleGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWAFRegionalRuleGroupFilters = map[string]string{
	"activated_rules": "description.ActivatedRules",
	"akas":            "description.ARN",
	"arn":             "description.ARN",
	"og_account_id":   "metadata.SourceID",
	"metric_name":     "description.RuleGroup.MetricName",
	"name":            "description.RuleGroup.Name",
	"rule_group_id":   "description.Rule.RuleId",
	"tags":            "description.Tags",
	"tags_src":        "description.Tags",
	"title":           "description.RuleGroup.Name",
}

func GetWAFRegionalRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWAFRegionalRuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWAFRegionalRuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWAFRegionalRuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WAFRegionalRuleGroup =============================

// ==========================  START: Route53HostedZone =============================

type Route53HostedZone struct {
	Description   aws.Route53HostedZoneDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type Route53HostedZoneHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  Route53HostedZone `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type Route53HostedZoneHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []Route53HostedZoneHit `json:"hits"`
}

type Route53HostedZoneSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  Route53HostedZoneHits `json:"hits"`
}

type Route53HostedZonePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53HostedZonePaginator(filters []essdk.BoolFilter, limit *int64) (Route53HostedZonePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_hostedzone", filters, limit)
	if err != nil {
		return Route53HostedZonePaginator{}, err
	}

	p := Route53HostedZonePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53HostedZonePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53HostedZonePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53HostedZonePaginator) NextPage(ctx context.Context) ([]Route53HostedZone, error) {
	var response Route53HostedZoneSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53HostedZone
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53HostedZoneFilters = map[string]string{
	"caller_reference":           "description.HostedZone.CallerReference",
	"comment":                    "description.HostedZone.Config.Comment",
	"dnssec_key_signing_keys":    "description.DNSSec.KeySigningKeys",
	"dnssec_status":              "description.DNSSec.Status",
	"id":                         "description.ID",
	"og_account_id":              "metadata.SourceID",
	"linked_service_description": "description.HostedZone.LinkedService.Description",
	"linked_service_principal":   "description.HostedZone.LinkedService.ServicePrincipal",
	"name":                       "description.HostedZone.Name",
	"private_zone":               "description.HostedZone.Config.PrivateZone",
	"query_logging_configs":      "description.QueryLoggingConfigs",
	"resource_record_set_count":  "description.HostedZone.ResourceRecordSetCount",
	"resource_record_set_limit":  "description.Limit.Value",
	"tags_src":                   "description.Tags",
	"title":                      "description.HostedZone.Name",
	"vpcs":                       "vpcs",
}

func ListRoute53HostedZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53HostedZone")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HostedZone NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HostedZone NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HostedZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HostedZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HostedZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53HostedZonePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53HostedZoneFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HostedZone NewRoute53HostedZonePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53HostedZone paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53HostedZoneFilters = map[string]string{
	"caller_reference":           "description.HostedZone.CallerReference",
	"comment":                    "description.HostedZone.Config.Comment",
	"dnssec_key_signing_keys":    "description.DNSSec.KeySigningKeys",
	"dnssec_status":              "description.DNSSec.Status",
	"id":                         "description.ID",
	"og_account_id":              "metadata.SourceID",
	"linked_service_description": "description.HostedZone.LinkedService.Description",
	"linked_service_principal":   "description.HostedZone.LinkedService.ServicePrincipal",
	"name":                       "description.HostedZone.Name",
	"private_zone":               "description.HostedZone.Config.PrivateZone",
	"query_logging_configs":      "description.QueryLoggingConfigs",
	"resource_record_set_count":  "description.HostedZone.ResourceRecordSetCount",
	"resource_record_set_limit":  "description.Limit.Value",
	"tags_src":                   "description.Tags",
	"title":                      "description.HostedZone.Name",
	"vpcs":                       "vpcs",
}

func GetRoute53HostedZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53HostedZone")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53HostedZonePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53HostedZoneFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53HostedZone =============================

// ==========================  START: Route53HealthCheck =============================

type Route53HealthCheck struct {
	Description   aws.Route53HealthCheckDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type Route53HealthCheckHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  Route53HealthCheck `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type Route53HealthCheckHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []Route53HealthCheckHit `json:"hits"`
}

type Route53HealthCheckSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  Route53HealthCheckHits `json:"hits"`
}

type Route53HealthCheckPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53HealthCheckPaginator(filters []essdk.BoolFilter, limit *int64) (Route53HealthCheckPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_healthcheck", filters, limit)
	if err != nil {
		return Route53HealthCheckPaginator{}, err
	}

	p := Route53HealthCheckPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53HealthCheckPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53HealthCheckPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53HealthCheckPaginator) NextPage(ctx context.Context) ([]Route53HealthCheck, error) {
	var response Route53HealthCheckSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53HealthCheck
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53HealthCheckFilters = map[string]string{
	"caller_reference":                "description.HealthCheck.CallerReference",
	"cloud_watch_alarm_configuration": "description.HealthCheck.CloudWatchAlarmConfiguration",
	"health_check_config":             "description.HealthCheck.HealthCheckConfig",
	"health_check_status":             "description.Status.HealthCheckObservations",
	"health_check_version":            "description.HealthCheck.HealthCheckVersion",
	"id":                              "description.HealthCheck.Id",
	"og_account_id":                   "metadata.SourceID",
	"linked_service_description":      "description.HealthCheck.LinkedService.Description",
	"linked_service_principal":        "description.HealthCheck.LinkedService.ServicePrincipal",
	"tags_src":                        "description.Tags.ResourceTagSet.Tags",
	"title":                           "description.HealthCheck.Id",
}

func ListRoute53HealthCheck(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53HealthCheck")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HealthCheck NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HealthCheck NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HealthCheck GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HealthCheck GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HealthCheck GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53HealthCheckPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53HealthCheckFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53HealthCheck NewRoute53HealthCheckPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53HealthCheck paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53HealthCheckFilters = map[string]string{
	"caller_reference":                "description.HealthCheck.CallerReference",
	"cloud_watch_alarm_configuration": "description.HealthCheck.CloudWatchAlarmConfiguration",
	"health_check_config":             "description.HealthCheck.HealthCheckConfig",
	"health_check_status":             "description.Status.HealthCheckObservations",
	"health_check_version":            "description.HealthCheck.HealthCheckVersion",
	"id":                              "description.HealthCheck.Id",
	"og_account_id":                   "metadata.SourceID",
	"linked_service_description":      "description.HealthCheck.LinkedService.Description",
	"linked_service_principal":        "description.HealthCheck.LinkedService.ServicePrincipal",
	"tags_src":                        "description.Tags.ResourceTagSet.Tags",
	"title":                           "description.HealthCheck.Id",
}

func GetRoute53HealthCheck(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53HealthCheck")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53HealthCheckPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53HealthCheckFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53HealthCheck =============================

// ==========================  START: Route53ResolverResolverRule =============================

type Route53ResolverResolverRule struct {
	Description   aws.Route53ResolverResolverRuleDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type Route53ResolverResolverRuleHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  Route53ResolverResolverRule `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type Route53ResolverResolverRuleHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []Route53ResolverResolverRuleHit `json:"hits"`
}

type Route53ResolverResolverRuleSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  Route53ResolverResolverRuleHits `json:"hits"`
}

type Route53ResolverResolverRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53ResolverResolverRulePaginator(filters []essdk.BoolFilter, limit *int64) (Route53ResolverResolverRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53resolver_resolverrule", filters, limit)
	if err != nil {
		return Route53ResolverResolverRulePaginator{}, err
	}

	p := Route53ResolverResolverRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53ResolverResolverRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53ResolverResolverRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53ResolverResolverRulePaginator) NextPage(ctx context.Context) ([]Route53ResolverResolverRule, error) {
	var response Route53ResolverResolverRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53ResolverResolverRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53ResolverResolverRuleFilters = map[string]string{
	"akas":                       "description.ResolverRole.Arn",
	"arn":                        "description.ResolverRole.Arn",
	"creation_time":              "description.ResolverRole.CreationTime",
	"creator_request_id":         "description.ResolverRole.CreatorRequestId",
	"domain_name":                "description.ResolverRole.DomainName",
	"id":                         "description.ResolverRole.Id",
	"og_account_id":              "metadata.SourceID",
	"modification_time":          "description.ResolverRole.ModificationTime",
	"name":                       "description.ResolverRole.Name",
	"owner_id":                   "description.ResolverRole.OwnerId",
	"resolver_endpoint_id":       "description.ResolverRole.ResolverEndpointId",
	"resolver_rule_associations": "description.RuleAssociations.ResolverRuleAssociations",
	"rule_type":                  "description.ResolverRole.RuleType",
	"share_status":               "description.ResolverRole.ShareStatus",
	"status":                     "description.ResolverRole.Status",
	"status_message":             "description.ResolverRole.StatusMessage",
	"tags_src":                   "description.Tags",
	"target_ips":                 "description.ResolverRole.TargetIps",
	"title":                      "description.ResolverRole.Name",
}

func ListRoute53ResolverResolverRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53ResolverResolverRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverResolverRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverResolverRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverResolverRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverResolverRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverResolverRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53ResolverResolverRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53ResolverResolverRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverResolverRule NewRoute53ResolverResolverRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53ResolverResolverRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53ResolverResolverRuleFilters = map[string]string{
	"akas":                       "description.ResolverRole.Arn",
	"arn":                        "description.ResolverRole.Arn",
	"creation_time":              "description.ResolverRole.CreationTime",
	"creator_request_id":         "description.ResolverRole.CreatorRequestId",
	"domain_name":                "description.ResolverRole.DomainName",
	"id":                         "description.ResolverRole.Id",
	"og_account_id":              "metadata.SourceID",
	"modification_time":          "description.ResolverRole.ModificationTime",
	"name":                       "description.ResolverRole.Name",
	"owner_id":                   "description.ResolverRole.OwnerId",
	"resolver_endpoint_id":       "description.ResolverRole.ResolverEndpointId",
	"resolver_rule_associations": "description.RuleAssociations.ResolverRuleAssociations",
	"rule_type":                  "description.ResolverRole.RuleType",
	"share_status":               "description.ResolverRole.ShareStatus",
	"status":                     "description.ResolverRole.Status",
	"status_message":             "description.ResolverRole.StatusMessage",
	"tags_src":                   "description.Tags",
	"target_ips":                 "description.ResolverRole.TargetIps",
	"title":                      "description.ResolverRole.Name",
}

func GetRoute53ResolverResolverRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53ResolverResolverRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53ResolverResolverRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53ResolverResolverRuleFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53ResolverResolverRule =============================

// ==========================  START: Route53ResolverEndpoint =============================

type Route53ResolverEndpoint struct {
	Description   aws.Route53ResolverEndpointDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type Route53ResolverEndpointHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  Route53ResolverEndpoint `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type Route53ResolverEndpointHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []Route53ResolverEndpointHit `json:"hits"`
}

type Route53ResolverEndpointSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  Route53ResolverEndpointHits `json:"hits"`
}

type Route53ResolverEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53ResolverEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (Route53ResolverEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53resolver_resolverendpoint", filters, limit)
	if err != nil {
		return Route53ResolverEndpointPaginator{}, err
	}

	p := Route53ResolverEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53ResolverEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53ResolverEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53ResolverEndpointPaginator) NextPage(ctx context.Context) ([]Route53ResolverEndpoint, error) {
	var response Route53ResolverEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53ResolverEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53ResolverEndpointFilters = map[string]string{
	"arn":                "description.ResolverEndpoint.Arn",
	"creation_time":      "description.ResolverEndpoint.CreationTime",
	"creator_request_id": "description.ResolverEndpoint.CreatorRequestId",
	"direction":          "description.ResolverEndpoint.Direction",
	"host_vpc_id":        "description.ResolverEndpoint.HostVPCId",
	"id":                 "description.ResolverEndpoint.Id",
	"ip_address_count":   "description.ResolverEndpoint.IpAddressCount",
	"ip_addresses":       "description.IpAddresses",
	"og_account_id":      "metadata.SourceID",
	"modification_time":  "description.ResolverEndpoint.ModificationTime",
	"name":               "description.ResolverEndpoint.Name",
	"security_group_ids": "description.ResolverEndpoint.SecurityGroupIds",
	"status":             "description.ResolverEndpoint.Status",
	"status_message":     "description.ResolverEndpoint.StatusMessage",
	"tags_src":           "description.Tags",
	"title":              "description.ResolverEndpoint.Name",
}

func ListRoute53ResolverEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53ResolverEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53ResolverEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53ResolverEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverEndpoint NewRoute53ResolverEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53ResolverEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53ResolverEndpointFilters = map[string]string{
	"arn":                "description.ResolverEndpoint.Arn",
	"creation_time":      "description.ResolverEndpoint.CreationTime",
	"creator_request_id": "description.ResolverEndpoint.CreatorRequestId",
	"direction":          "description.ResolverEndpoint.Direction",
	"host_vpc_id":        "description.ResolverEndpoint.HostVPCId",
	"id":                 "description.ResolverEndpoint.Id",
	"ip_address_count":   "description.ResolverEndpoint.IpAddressCount",
	"ip_addresses":       "description.IpAddresses",
	"og_account_id":      "metadata.SourceID",
	"modification_time":  "description.ResolverEndpoint.ModificationTime",
	"name":               "description.ResolverEndpoint.Name",
	"security_group_ids": "description.ResolverEndpoint.SecurityGroupIds",
	"status":             "description.ResolverEndpoint.Status",
	"status_message":     "description.ResolverEndpoint.StatusMessage",
	"tags_src":           "description.Tags",
	"title":              "description.ResolverEndpoint.Name",
}

func GetRoute53ResolverEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53ResolverEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53ResolverEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53ResolverEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53ResolverEndpoint =============================

// ==========================  START: Route53Domain =============================

type Route53Domain struct {
	Description   aws.Route53DomainDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type Route53DomainHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Route53Domain `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type Route53DomainHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []Route53DomainHit `json:"hits"`
}

type Route53DomainSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  Route53DomainHits `json:"hits"`
}

type Route53DomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53DomainPaginator(filters []essdk.BoolFilter, limit *int64) (Route53DomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53domains_domain", filters, limit)
	if err != nil {
		return Route53DomainPaginator{}, err
	}

	p := Route53DomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53DomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53DomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53DomainPaginator) NextPage(ctx context.Context) ([]Route53Domain, error) {
	var response Route53DomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53Domain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53DomainFilters = map[string]string{
	"abuse_contact_email": "description.Domain.AbuseContactEmail",
	"abuse_contact_phone": "description.Domain.AbuseContactPhone",
	"admin_contact":       "description.Domain.AdminContact",
	"admin_privacy":       "description.Domain.AdminPrivacy",
	"arn":                 "arn",
	"auto_renew":          "description.Domain.AutoRenew",
	"creation_date":       "description.Domain.CreationDate",
	"domain_name":         "description.Domain.DomainName",
	"expiration_date":     "description.Domain.ExpirationDate",
	"og_account_id":       "metadata.SourceID",
	"nameservers":         "description.Domain.Nameservers",
	"registrant_contact":  "description.Domain.RegistrantContact",
	"registrant_privacy":  "description.Domain.RegistrantPrivacy",
	"registrar_name":      "description.Domain.RegistrarName",
	"registrar_url":       "description.Domain.RegistrarUrl",
	"registry_domain_id":  "description.Domain.RegistryDomainId",
	"reseller":            "description.Domain.Reseller",
	"status_list":         "description.Domain.StatusList",
	"tags_src":            "description.Tags",
	"tech_contact":        "description.Domain.TechContact",
	"tech_privacy":        "description.Domain.TechPrivacy",
	"title":               "description.Domain.DomainName",
	"transfer_lock":       "description.DomainSummary.TransferLock",
	"updated_date":        "description.Domain.UpdatedDate",
	"who_is_server":       "description.Domain.WhoIsServer",
}

func ListRoute53Domain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53Domain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Domain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Domain NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Domain GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Domain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Domain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53DomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53DomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Domain NewRoute53DomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53Domain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53DomainFilters = map[string]string{
	"abuse_contact_email": "description.Domain.AbuseContactEmail",
	"abuse_contact_phone": "description.Domain.AbuseContactPhone",
	"admin_contact":       "description.Domain.AdminContact",
	"admin_privacy":       "description.Domain.AdminPrivacy",
	"arn":                 "arn",
	"auto_renew":          "description.Domain.AutoRenew",
	"creation_date":       "description.Domain.CreationDate",
	"domain_name":         "description.Domain.DomainName",
	"expiration_date":     "description.Domain.ExpirationDate",
	"og_account_id":       "metadata.SourceID",
	"nameservers":         "description.Domain.Nameservers",
	"registrant_contact":  "description.Domain.RegistrantContact",
	"registrant_privacy":  "description.Domain.RegistrantPrivacy",
	"registrar_name":      "description.Domain.RegistrarName",
	"registrar_url":       "description.Domain.RegistrarUrl",
	"registry_domain_id":  "description.Domain.RegistryDomainId",
	"reseller":            "description.Domain.Reseller",
	"status_list":         "description.Domain.StatusList",
	"tags_src":            "description.Tags",
	"tech_contact":        "description.Domain.TechContact",
	"tech_privacy":        "description.Domain.TechPrivacy",
	"title":               "description.Domain.DomainName",
	"transfer_lock":       "description.DomainSummary.TransferLock",
	"updated_date":        "description.Domain.UpdatedDate",
	"who_is_server":       "description.Domain.WhoIsServer",
}

func GetRoute53Domain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53Domain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53DomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53DomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53Domain =============================

// ==========================  START: Route53Record =============================

type Route53Record struct {
	Description   aws.Route53RecordDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type Route53RecordHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Route53Record `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type Route53RecordHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []Route53RecordHit `json:"hits"`
}

type Route53RecordSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  Route53RecordHits `json:"hits"`
}

type Route53RecordPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53RecordPaginator(filters []essdk.BoolFilter, limit *int64) (Route53RecordPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_record", filters, limit)
	if err != nil {
		return Route53RecordPaginator{}, err
	}

	p := Route53RecordPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53RecordPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53RecordPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53RecordPaginator) NextPage(ctx context.Context) ([]Route53Record, error) {
	var response Route53RecordSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53Record
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53RecordFilters = map[string]string{
	"alias_target":               "description.Record.AliasTarget",
	"failover":                   "description.Record.Failover",
	"geo_location":               "description.Record.GeoLocation",
	"health_check_id":            "description.Record.HealthCheckId",
	"og_account_id":              "metadata.SourceID",
	"latency_region":             "description.Record.Region",
	"multi_value_answer":         "description.Record.MultiValueAnswer",
	"name":                       "description.Record.Name",
	"set_identifier":             "description.Record.SetIdentifier",
	"title":                      "description.Record.Name",
	"traffic_policy_instance_id": "description.Record.TrafficPolicyInstanceId",
	"ttl":                        "record.TTL",
	"type":                       "description.Record.Type",
	"weight":                     "description.Record.Weight",
	"zone_id":                    "description.ZoneId",
}

func ListRoute53Record(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53Record")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Record NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Record NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Record GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Record GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Record GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53RecordPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53RecordFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53Record NewRoute53RecordPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53Record paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53RecordFilters = map[string]string{
	"alias_target":               "description.Record.AliasTarget",
	"failover":                   "description.Record.Failover",
	"geo_location":               "description.Record.GeoLocation",
	"health_check_id":            "description.Record.HealthCheckId",
	"og_account_id":              "metadata.SourceID",
	"latency_region":             "description.Record.Region",
	"multi_value_answer":         "description.Record.MultiValueAnswer",
	"name":                       "description.Record.Name",
	"set_identifier":             "description.Record.SetIdentifier",
	"title":                      "description.Record.Name",
	"traffic_policy_instance_id": "description.Record.TrafficPolicyInstanceId",
	"ttl":                        "record.TTL",
	"type":                       "description.Record.Type",
	"weight":                     "description.Record.Weight",
	"zone_id":                    "description.ZoneID",
}

func GetRoute53Record(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53Record")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53RecordPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53RecordFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53Record =============================

// ==========================  START: Route53TrafficPolicy =============================

type Route53TrafficPolicy struct {
	Description   aws.Route53TrafficPolicyDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type Route53TrafficPolicyHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  Route53TrafficPolicy `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type Route53TrafficPolicyHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []Route53TrafficPolicyHit `json:"hits"`
}

type Route53TrafficPolicySearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  Route53TrafficPolicyHits `json:"hits"`
}

type Route53TrafficPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53TrafficPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (Route53TrafficPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_trafficpolicy", filters, limit)
	if err != nil {
		return Route53TrafficPolicyPaginator{}, err
	}

	p := Route53TrafficPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53TrafficPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53TrafficPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53TrafficPolicyPaginator) NextPage(ctx context.Context) ([]Route53TrafficPolicy, error) {
	var response Route53TrafficPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53TrafficPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53TrafficPolicyFilters = map[string]string{
	"comment":       "description.TrafficPolicy.Comment",
	"document":      "description.TrafficPolicy.Document",
	"id":            "description.TrafficPolicy.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.TrafficPolicy.Name",
	"title":         "description.TrafficPolicy.Name",
	"type":          "description.TrafficPolicy.Type",
	"version":       "description.TrafficPolicy.Version",
}

func ListRoute53TrafficPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53TrafficPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53TrafficPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53TrafficPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicy NewRoute53TrafficPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53TrafficPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53TrafficPolicyFilters = map[string]string{
	"comment":       "description.TrafficPolicy.Comment",
	"document":      "description.TrafficPolicy.Document",
	"id":            "description.TrafficPolicy.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.TrafficPolicy.Name",
	"title":         "description.TrafficPolicy.Name",
	"type":          "description.TrafficPolicy.Type",
	"version":       "description.TrafficPolicy.Version",
}

func GetRoute53TrafficPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53TrafficPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53TrafficPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53TrafficPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53TrafficPolicy =============================

// ==========================  START: Route53TrafficPolicyInstance =============================

type Route53TrafficPolicyInstance struct {
	Description   aws.Route53TrafficPolicyInstanceDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type Route53TrafficPolicyInstanceHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  Route53TrafficPolicyInstance `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type Route53TrafficPolicyInstanceHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []Route53TrafficPolicyInstanceHit `json:"hits"`
}

type Route53TrafficPolicyInstanceSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  Route53TrafficPolicyInstanceHits `json:"hits"`
}

type Route53TrafficPolicyInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53TrafficPolicyInstancePaginator(filters []essdk.BoolFilter, limit *int64) (Route53TrafficPolicyInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_trafficpolicyinstance", filters, limit)
	if err != nil {
		return Route53TrafficPolicyInstancePaginator{}, err
	}

	p := Route53TrafficPolicyInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53TrafficPolicyInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53TrafficPolicyInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53TrafficPolicyInstancePaginator) NextPage(ctx context.Context) ([]Route53TrafficPolicyInstance, error) {
	var response Route53TrafficPolicyInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53TrafficPolicyInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53TrafficPolicyInstanceFilters = map[string]string{
	"hosted_zone_id":         "description.TrafficPolicyInstance.HostedZoneId",
	"id":                     "description.TrafficPolicyInstance.Id",
	"og_account_id":          "metadata.SourceID",
	"message":                "description.TrafficPolicyInstance.Message",
	"name":                   "description.TrafficPolicyInstance.Name",
	"state":                  "description.TrafficPolicyInstance.State",
	"title":                  "description.TrafficPolicyInstance.Name",
	"traffic_policy_id":      "description.TrafficPolicyInstance.TrafficPolicyId",
	"traffic_policy_type":    "description.TrafficPolicyInstance.TrafficPolicyType",
	"traffic_policy_version": "description.TrafficPolicyInstance.TrafficPolicyVersion",
	"ttl":                    "ttl",
}

func ListRoute53TrafficPolicyInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53TrafficPolicyInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicyInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicyInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicyInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicyInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicyInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53TrafficPolicyInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53TrafficPolicyInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53TrafficPolicyInstance NewRoute53TrafficPolicyInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53TrafficPolicyInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53TrafficPolicyInstanceFilters = map[string]string{
	"hosted_zone_id":         "description.TrafficPolicyInstance.HostedZoneId",
	"id":                     "description.TrafficPolicyInstance.Id",
	"og_account_id":          "metadata.SourceID",
	"message":                "description.TrafficPolicyInstance.Message",
	"name":                   "description.TrafficPolicyInstance.Name",
	"state":                  "description.TrafficPolicyInstance.State",
	"title":                  "description.TrafficPolicyInstance.Name",
	"traffic_policy_id":      "description.TrafficPolicyInstance.TrafficPolicyId",
	"traffic_policy_type":    "description.TrafficPolicyInstance.TrafficPolicyType",
	"traffic_policy_version": "description.TrafficPolicyInstance.TrafficPolicyVersion",
	"ttl":                    "ttl",
}

func GetRoute53TrafficPolicyInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53TrafficPolicyInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53TrafficPolicyInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53TrafficPolicyInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53TrafficPolicyInstance =============================

// ==========================  START: Route53QueryLog =============================

type Route53QueryLog struct {
	Description   aws.Route53QueryLogDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type Route53QueryLogHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  Route53QueryLog `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type Route53QueryLogHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []Route53QueryLogHit `json:"hits"`
}

type Route53QueryLogSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  Route53QueryLogHits `json:"hits"`
}

type Route53QueryLogPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53QueryLogPaginator(filters []essdk.BoolFilter, limit *int64) (Route53QueryLogPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53_querylog", filters, limit)
	if err != nil {
		return Route53QueryLogPaginator{}, err
	}

	p := Route53QueryLogPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53QueryLogPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53QueryLogPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53QueryLogPaginator) NextPage(ctx context.Context) ([]Route53QueryLog, error) {
	var response Route53QueryLogSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53QueryLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53QueryLogFilters = map[string]string{
	"cloud_watch_logs_log_group_arn": "description.QueryConfig.CloudWatchLogsLogGroupArn",
	"hosted_zone_id":                 "description.QueryConfig.HostedZoneId",
	"id":                             "description.QueryConfig.Id",
	"og_account_id":                  "metadata.SourceID",
	"title":                          "description.QueryConfig.Id",
}

func ListRoute53QueryLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53QueryLog")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53QueryLog NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53QueryLog NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53QueryLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53QueryLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53QueryLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53QueryLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53QueryLogFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53QueryLog NewRoute53QueryLogPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53QueryLog paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53QueryLogFilters = map[string]string{
	"cloud_watch_logs_log_group_arn": "description.QueryConfig.CloudWatchLogsLogGroupArn",
	"hosted_zone_id":                 "description.QueryConfig.HostedZoneId",
	"id":                             "description.TrafficPolicyInstance.Id",
	"og_account_id":                  "metadata.SourceID",
	"title":                          "description.QueryConfig.Id",
}

func GetRoute53QueryLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53QueryLog")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53QueryLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53QueryLogFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53QueryLog =============================

// ==========================  START: Route53ResolverQueryLogConfig =============================

type Route53ResolverQueryLogConfig struct {
	Description   aws.Route53ResolverQueryLogConfigDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type Route53ResolverQueryLogConfigHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  Route53ResolverQueryLogConfig `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type Route53ResolverQueryLogConfigHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []Route53ResolverQueryLogConfigHit `json:"hits"`
}

type Route53ResolverQueryLogConfigSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  Route53ResolverQueryLogConfigHits `json:"hits"`
}

type Route53ResolverQueryLogConfigPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoute53ResolverQueryLogConfigPaginator(filters []essdk.BoolFilter, limit *int64) (Route53ResolverQueryLogConfigPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_route53resolver_querylogconfig", filters, limit)
	if err != nil {
		return Route53ResolverQueryLogConfigPaginator{}, err
	}

	p := Route53ResolverQueryLogConfigPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Route53ResolverQueryLogConfigPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Route53ResolverQueryLogConfigPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Route53ResolverQueryLogConfigPaginator) NextPage(ctx context.Context) ([]Route53ResolverQueryLogConfig, error) {
	var response Route53ResolverQueryLogConfigSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route53ResolverQueryLogConfig
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoute53ResolverQueryLogConfigFilters = map[string]string{
	"arn":                "description.QueryConfig.Arn",
	"association_count":  "description.QueryConfig.AssociationCount",
	"creation_time":      "description.QueryConfig.CreationTime",
	"creator_request_id": "description.QueryConfig.CreatorRequestId",
	"destination_arn":    "description.QueryConfig.DestinationArn",
	"id":                 "description.QueryConfig.Id",
	"og_account_id":      "metadata.SourceID",
	"name":               "description.QueryConfig.Name",
	"owner_id":           "description.QueryConfig.OwnerId",
	"share_status":       "description.QueryConfig.ShareStatus",
	"status":             "description.QueryConfig.Status",
	"title":              "description.QueryConfig.Name",
}

func ListRoute53ResolverQueryLogConfig(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute53ResolverQueryLogConfig")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverQueryLogConfig NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverQueryLogConfig NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverQueryLogConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverQueryLogConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverQueryLogConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoute53ResolverQueryLogConfigPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoute53ResolverQueryLogConfigFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute53ResolverQueryLogConfig NewRoute53ResolverQueryLogConfigPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute53ResolverQueryLogConfig paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoute53ResolverQueryLogConfigFilters = map[string]string{
	"arn":                "description.QueryConfig.Arn",
	"association_count":  "description.QueryConfig.AssociationCount",
	"creation_time":      "description.QueryConfig.CreationTime",
	"creator_request_id": "description.QueryConfig.CreatorRequestId",
	"destination_arn":    "description.QueryConfig.DestinationArn",
	"id":                 "description.TrafficPolicyInstance.Id",
	"og_account_id":      "metadata.SourceID",
	"name":               "description.QueryConfig.Name",
	"owner_id":           "description.QueryConfig.OwnerId",
	"share_status":       "description.QueryConfig.ShareStatus",
	"status":             "description.QueryConfig.Status",
	"title":              "description.QueryConfig.Name",
}

func GetRoute53ResolverQueryLogConfig(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute53ResolverQueryLogConfig")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoute53ResolverQueryLogConfigPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoute53ResolverQueryLogConfigFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route53ResolverQueryLogConfig =============================

// ==========================  START: BatchComputeEnvironment =============================

type BatchComputeEnvironment struct {
	Description   aws.BatchComputeEnvironmentDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type BatchComputeEnvironmentHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  BatchComputeEnvironment `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type BatchComputeEnvironmentHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []BatchComputeEnvironmentHit `json:"hits"`
}

type BatchComputeEnvironmentSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  BatchComputeEnvironmentHits `json:"hits"`
}

type BatchComputeEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchComputeEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (BatchComputeEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_batch_computeenvironment", filters, limit)
	if err != nil {
		return BatchComputeEnvironmentPaginator{}, err
	}

	p := BatchComputeEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchComputeEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchComputeEnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BatchComputeEnvironmentPaginator) NextPage(ctx context.Context) ([]BatchComputeEnvironment, error) {
	var response BatchComputeEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchComputeEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchComputeEnvironmentFilters = map[string]string{
	"arn":                      "description.ComputeEnvironment.ComputeEnvironmentArn",
	"compute_environment_name": "description.ComputeEnvironment.ComputeEnvironmentName",
	"id":                       "description.ComputeEnvironment.Uuid",
	"og_account_id":            "metadata.SourceID",
	"tags":                     "description.ComputeEnvironment.Tags",
	"title":                    "description.ComputeEnvironment.ComputeEnvironmentName",
}

func ListBatchComputeEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchComputeEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchComputeEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchComputeEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchComputeEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchComputeEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchComputeEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBatchComputeEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBatchComputeEnvironmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchComputeEnvironment NewBatchComputeEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBatchComputeEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBatchComputeEnvironmentFilters = map[string]string{
	"arn":                      "description.ComputeEnvironment.ComputeEnvironmentArn",
	"compute_environment_name": "description.ComputeEnvironment.ComputeEnvironmentName",
	"id":                       "description.ComputeEnvironment.Uuid",
	"og_account_id":            "metadata.SourceID",
	"tags":                     "description.ComputeEnvironment.Tags",
	"title":                    "description.ComputeEnvironment.ComputeEnvironmentName",
}

func GetBatchComputeEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchComputeEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBatchComputeEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBatchComputeEnvironmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BatchComputeEnvironment =============================

// ==========================  START: BatchJob =============================

type BatchJob struct {
	Description   aws.BatchJobDescription `json:"description"`
	Metadata      aws.Metadata            `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type BatchJobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BatchJob      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BatchJobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BatchJobHit     `json:"hits"`
}

type BatchJobSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  BatchJobHits `json:"hits"`
}

type BatchJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchJobPaginator(filters []essdk.BoolFilter, limit *int64) (BatchJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_batch_job", filters, limit)
	if err != nil {
		return BatchJobPaginator{}, err
	}

	p := BatchJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchJobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BatchJobPaginator) NextPage(ctx context.Context) ([]BatchJob, error) {
	var response BatchJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchJobFilters = map[string]string{
	"arn":           "description.Job.JobArn",
	"id":            "description.Job.JobId",
	"job_name":      "description.Job.JobName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Job.JobName",
}

func ListBatchJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJob NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBatchJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBatchJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJob NewBatchJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBatchJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBatchJobFilters = map[string]string{
	"arn":           "description.Job.JobArn",
	"id":            "description.Job.JobId",
	"job_name":      "description.Job.JobName",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Job.JobName",
}

func GetBatchJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBatchJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBatchJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BatchJob =============================

// ==========================  START: BatchJobQueue =============================

type BatchJobQueue struct {
	Description   aws.BatchJobQueueDescription `json:"description"`
	Metadata      aws.Metadata                 `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type BatchJobQueueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BatchJobQueue `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BatchJobQueueHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []BatchJobQueueHit `json:"hits"`
}

type BatchJobQueueSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  BatchJobQueueHits `json:"hits"`
}

type BatchJobQueuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchJobQueuePaginator(filters []essdk.BoolFilter, limit *int64) (BatchJobQueuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_batch_jobqueue", filters, limit)
	if err != nil {
		return BatchJobQueuePaginator{}, err
	}

	p := BatchJobQueuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchJobQueuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchJobQueuePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BatchJobQueuePaginator) NextPage(ctx context.Context) ([]BatchJobQueue, error) {
	var response BatchJobQueueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchJobQueue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchJobQueueFilters = map[string]string{
	"arn":           "description.Queue.ARN",
	"id":            "description.Queue.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Queue.Name",
	"tags":          "description.Queue.Tags",
	"title":         "description.Queue.Name",
}

func ListBatchJobQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchJobQueue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJobQueue NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJobQueue NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJobQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJobQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJobQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBatchJobQueuePaginator(essdk.BuildFilter(ctx, d.QueryContext, listBatchJobQueueFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchJobQueue NewBatchJobQueuePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBatchJobQueue paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBatchJobQueueFilters = map[string]string{
	"arn":            "description.Queue.ARN",
	"id":             "description.Queue.Id",
	"job_queue_name": "description.JobQueue.JobQueueName",
	"og_account_id":  "metadata.SourceID",
	"name":           "description.Queue.Name",
	"tags":           "description.Queue.Tags",
	"title":          "description.Queue.Name",
}

func GetBatchJobQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchJobQueue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBatchJobQueuePaginator(essdk.BuildFilter(ctx, d.QueryContext, getBatchJobQueueFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BatchJobQueue =============================

// ==========================  START: CodeArtifactRepository =============================

type CodeArtifactRepository struct {
	Description   aws.CodeArtifactRepositoryDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type CodeArtifactRepositoryHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  CodeArtifactRepository `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type CodeArtifactRepositoryHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []CodeArtifactRepositoryHit `json:"hits"`
}

type CodeArtifactRepositorySearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  CodeArtifactRepositoryHits `json:"hits"`
}

type CodeArtifactRepositoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeArtifactRepositoryPaginator(filters []essdk.BoolFilter, limit *int64) (CodeArtifactRepositoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codeartifact_repository", filters, limit)
	if err != nil {
		return CodeArtifactRepositoryPaginator{}, err
	}

	p := CodeArtifactRepositoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeArtifactRepositoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeArtifactRepositoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeArtifactRepositoryPaginator) NextPage(ctx context.Context) ([]CodeArtifactRepository, error) {
	var response CodeArtifactRepositorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeArtifactRepository
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeArtifactRepositoryFilters = map[string]string{
	"administrator_account": "description.Repository.AdministratorAccount",
	"arn":                   "description.Repository.Arn",
	"description":           "description.Repository.Description",
	"domain_name":           "description.Repository.DomainName",
	"domain_owner":          "description.Repository.DomainOwner",
	"external_connections":  "description.Description.ExternalConnections",
	"og_account_id":         "metadata.SourceID",
	"name":                  "description.Repository.Name",
	"policy":                "description.Policy.ResourceArn",
	"policy_std":            "description.Policy",
	"repository_endpoint":   "description.Endpoints",
	"tags_src":              "description.Tags",
	"title":                 "description.Repository.Name",
	"upstreams":             "description.Description.Upstreams",
}

func ListCodeArtifactRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeArtifactRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactRepository NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactRepository NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactRepository GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeArtifactRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeArtifactRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactRepository NewCodeArtifactRepositoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeArtifactRepository paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeArtifactRepositoryFilters = map[string]string{
	"administrator_account": "description.Repository.AdministratorAccount",
	"arn":                   "description.Repository.Arn",
	"description":           "description.Repository.Description",
	"domain_name":           "description.Repository.DomainName",
	"domain_owner":          "description.Repository.DomainOwner",
	"external_connections":  "description.Description.ExternalConnections",
	"og_account_id":         "metadata.SourceID",
	"name":                  "description.Repository.Name",
	"policy":                "description.Policy.ResourceArn",
	"policy_std":            "description.Policy",
	"repository_endpoint":   "description.Endpoints",
	"tags_src":              "description.Tags",
	"title":                 "description.Repository.Name",
	"upstreams":             "description.Description.Upstreams",
}

func GetCodeArtifactRepository(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeArtifactRepository")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeArtifactRepositoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeArtifactRepositoryFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeArtifactRepository =============================

// ==========================  START: CodeArtifactDomain =============================

type CodeArtifactDomain struct {
	Description   aws.CodeArtifactDomainDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type CodeArtifactDomainHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  CodeArtifactDomain `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type CodeArtifactDomainHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []CodeArtifactDomainHit `json:"hits"`
}

type CodeArtifactDomainSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  CodeArtifactDomainHits `json:"hits"`
}

type CodeArtifactDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeArtifactDomainPaginator(filters []essdk.BoolFilter, limit *int64) (CodeArtifactDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codeartifact_domain", filters, limit)
	if err != nil {
		return CodeArtifactDomainPaginator{}, err
	}

	p := CodeArtifactDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeArtifactDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeArtifactDomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeArtifactDomainPaginator) NextPage(ctx context.Context) ([]CodeArtifactDomain, error) {
	var response CodeArtifactDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeArtifactDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeArtifactDomainFilters = map[string]string{
	"arn":              "description.Domain.Arn",
	"asset_size_bytes": "description.Domain.AssetSizeBytes",
	"created_time":     "description.Domain.CreatedTime",
	"encryption_key":   "description.Domain.EncryptionKey",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Domain.Name",
	"owner":            "description.Domain.Owner",
	"policy":           "description.Policy",
	"repository_count": "description.Domain.RepositoryCount",
	"s3_bucket_arn":    "description.Domain.S3BucketArn",
	"status":           "description.Domain.Status",
	"tags_src":         "description.Tags",
	"title":            "description.Domain.Name",
}

func ListCodeArtifactDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeArtifactDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeArtifactDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeArtifactDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeArtifactDomain NewCodeArtifactDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeArtifactDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeArtifactDomainFilters = map[string]string{
	"arn":              "description.Domain.Arn",
	"asset_size_bytes": "description.Domain.AssetSizeBytes",
	"created_time":     "description.Domain.CreatedTime",
	"encryption_key":   "description.Domain.EncryptionKey",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Domain.Owner",
	"owner":            "description.Domain.Owner",
	"policy":           "description.Policy",
	"repository_count": "description.Domain.RepositoryCount",
	"s3_bucket_arn":    "description.Domain.S3BucketArn",
	"status":           "description.Domain.Status",
	"tags_src":         "description.Tags",
	"title":            "description.Domain.Name",
}

func GetCodeArtifactDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeArtifactDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeArtifactDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeArtifactDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeArtifactDomain =============================

// ==========================  START: CodeDeployDeploymentGroup =============================

type CodeDeployDeploymentGroup struct {
	Description   aws.CodeDeployDeploymentGroupDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type CodeDeployDeploymentGroupHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  CodeDeployDeploymentGroup `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type CodeDeployDeploymentGroupHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []CodeDeployDeploymentGroupHit `json:"hits"`
}

type CodeDeployDeploymentGroupSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  CodeDeployDeploymentGroupHits `json:"hits"`
}

type CodeDeployDeploymentGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeDeployDeploymentGroupPaginator(filters []essdk.BoolFilter, limit *int64) (CodeDeployDeploymentGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codedeploy_deploymentgroup", filters, limit)
	if err != nil {
		return CodeDeployDeploymentGroupPaginator{}, err
	}

	p := CodeDeployDeploymentGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeDeployDeploymentGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeDeployDeploymentGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeDeployDeploymentGroupPaginator) NextPage(ctx context.Context) ([]CodeDeployDeploymentGroup, error) {
	var response CodeDeployDeploymentGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeDeployDeploymentGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeDeployDeploymentGroupFilters = map[string]string{
	"alarm_configuration":                 "description.DeploymentGroup.AlarmConfiguration",
	"application_name":                    "description.DeploymentGroup.ApplicationName",
	"arn":                                 "arn",
	"auto_rollback_configuration":         "description.DeploymentGroup.AutoRollbackConfiguration",
	"auto_scaling_groups":                 "description.DeploymentGroup.AutoScalingGroups",
	"blue_green_deployment_configuration": "description.DeploymentGroup.BlueGreenDeploymentConfiguration",
	"compute_platform":                    "description.DeploymentGroup.ComputePlatform",
	"deployment_config_name":              "description.DeploymentGroup.DeploymentConfigName",
	"deployment_group_id":                 "description.DeploymentGroup.DeploymentGroupId",
	"deployment_group_name":               "description.DeploymentGroup.DeploymentGroupName",
	"deployment_style":                    "description.DeploymentGroup.DeploymentStyle",
	"ec2_tag_filters":                     "description.DeploymentGroup.Ec2TagFilters",
	"ec2_tag_set":                         "description.DeploymentGroup.Ec2TagSet",
	"ecs_services":                        "description.DeploymentGroup.EcsServices",
	"og_account_id":                       "metadata.SourceID",
	"last_attempted_deployment":           "description.DeploymentGroup.LastAttemptedDeployment",
	"last_successful_deployment":          "description.DeploymentGroup.LastSuccessfulDeployment",
	"load_balancer_info":                  "description.DeploymentGroup.LoadBalancerInfo",
	"on_premises_instance_tag_filters":    "description.DeploymentGroup.OnPremisesInstanceTagFilters",
	"on_premises_tag_set":                 "description.DeploymentGroup.OnPremisesTagSet",
	"outdated_instances_strategy":         "description.DeploymentGroup.OutdatedInstancesStrategy",
	"service_role_arn":                    "description.DeploymentGroup.ServiceRoleArn",
	"tags_src":                            "description.Tags",
	"target_revision":                     "description.DeploymentGroup.TargetRevision",
	"title":                               "description.DeploymentGroup.DeploymentGroupName",
	"trigger_configurations":              "description.DeploymentGroup.TriggerConfigurations",
}

func ListCodeDeployDeploymentGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeDeployDeploymentGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeDeployDeploymentGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeDeployDeploymentGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentGroup NewCodeDeployDeploymentGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeDeployDeploymentGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeDeployDeploymentGroupFilters = map[string]string{
	"alarm_configuration":                 "description.DeploymentGroup.AlarmConfiguration",
	"application_name":                    "description.DeploymentGroup.ApplicationName",
	"arn":                                 "arn",
	"auto_rollback_configuration":         "description.DeploymentGroup.AutoRollbackConfiguration",
	"auto_scaling_groups":                 "description.DeploymentGroup.AutoScalingGroups",
	"blue_green_deployment_configuration": "description.DeploymentGroup.BlueGreenDeploymentConfiguration",
	"compute_platform":                    "description.DeploymentGroup.ComputePlatform",
	"deployment_config_name":              "description.DeploymentGroup.DeploymentConfigName",
	"deployment_group_id":                 "description.DeploymentGroup.DeploymentGroupId",
	"deployment_group_name":               "description.DeploymentGroup.DeploymentGroupName",
	"deployment_style":                    "description.DeploymentGroup.DeploymentStyle",
	"ec2_tag_filters":                     "description.DeploymentGroup.Ec2TagFilters",
	"ec2_tag_set":                         "description.DeploymentGroup.Ec2TagSet",
	"ecs_services":                        "description.DeploymentGroup.EcsServices",
	"og_account_id":                       "metadata.SourceID",
	"last_attempted_deployment":           "description.DeploymentGroup.LastAttemptedDeployment",
	"last_successful_deployment":          "description.DeploymentGroup.LastSuccessfulDeployment",
	"load_balancer_info":                  "description.DeploymentGroup.LoadBalancerInfo",
	"on_premises_instance_tag_filters":    "description.DeploymentGroup.OnPremisesInstanceTagFilters",
	"on_premises_tag_set":                 "description.DeploymentGroup.OnPremisesTagSet",
	"outdated_instances_strategy":         "description.DeploymentGroup.OutdatedInstancesStrategy",
	"service_role_arn":                    "description.DeploymentGroup.ServiceRoleArn",
	"tags_src":                            "description.Tags",
	"target_revision":                     "description.DeploymentGroup.TargetRevision",
	"title":                               "description.DeploymentGroup.DeploymentGroupName",
	"trigger_configurations":              "description.DeploymentGroup.TriggerConfigurations",
}

func GetCodeDeployDeploymentGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeDeployDeploymentGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeDeployDeploymentGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeDeployDeploymentGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeDeployDeploymentGroup =============================

// ==========================  START: CodeDeployApplication =============================

type CodeDeployApplication struct {
	Description   aws.CodeDeployApplicationDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type CodeDeployApplicationHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  CodeDeployApplication `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type CodeDeployApplicationHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []CodeDeployApplicationHit `json:"hits"`
}

type CodeDeployApplicationSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  CodeDeployApplicationHits `json:"hits"`
}

type CodeDeployApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeDeployApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (CodeDeployApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codedeploy_application", filters, limit)
	if err != nil {
		return CodeDeployApplicationPaginator{}, err
	}

	p := CodeDeployApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeDeployApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeDeployApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeDeployApplicationPaginator) NextPage(ctx context.Context) ([]CodeDeployApplication, error) {
	var response CodeDeployApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeDeployApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeDeployApplicationFilters = map[string]string{
	"application_id":      "description.Application.ApplicationId",
	"application_name":    "description.Application.ApplicationName",
	"arn":                 "arn",
	"compute_platform":    "description.Application.ComputePlatform",
	"create_time":         "description.Application.CreateTime",
	"github_account_name": "description.Application.GitHubAccountName",
	"og_account_id":       "metadata.SourceID",
	"linked_to_github":    "description.Application.LinkedToGitHub",
	"tags_src":            "description.Tags",
	"title":               "description.Application.ApplicationName",
}

func ListCodeDeployApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeDeployApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeDeployApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeDeployApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployApplication NewCodeDeployApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeDeployApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeDeployApplicationFilters = map[string]string{
	"application_id":      "description.Application.ApplicationId",
	"application_name":    "description.Application.ApplicationName",
	"arn":                 "arn",
	"compute_platform":    "description.Application.ComputePlatform",
	"create_time":         "description.Application.CreateTime",
	"github_account_name": "description.Application.GitHubAccountName",
	"og_account_id":       "metadata.SourceID",
	"linked_to_github":    "description.Application.LinkedToGitHub",
	"tags_src":            "description.Tags",
	"title":               "description.Application.ApplicationName",
}

func GetCodeDeployApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeDeployApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeDeployApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeDeployApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeDeployApplication =============================

// ==========================  START: CodeDeployDeploymentConfig =============================

type CodeDeployDeploymentConfig struct {
	Description   aws.CodeDeployDeploymentConfigDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type CodeDeployDeploymentConfigHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  CodeDeployDeploymentConfig `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type CodeDeployDeploymentConfigHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []CodeDeployDeploymentConfigHit `json:"hits"`
}

type CodeDeployDeploymentConfigSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  CodeDeployDeploymentConfigHits `json:"hits"`
}

type CodeDeployDeploymentConfigPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeDeployDeploymentConfigPaginator(filters []essdk.BoolFilter, limit *int64) (CodeDeployDeploymentConfigPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codedeploy_deploymentconfig", filters, limit)
	if err != nil {
		return CodeDeployDeploymentConfigPaginator{}, err
	}

	p := CodeDeployDeploymentConfigPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeDeployDeploymentConfigPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeDeployDeploymentConfigPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeDeployDeploymentConfigPaginator) NextPage(ctx context.Context) ([]CodeDeployDeploymentConfig, error) {
	var response CodeDeployDeploymentConfigSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeDeployDeploymentConfig
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeDeployDeploymentConfigFilters = map[string]string{
	"compute_platform":       "description.Config.ComputePlatform",
	"create_time":            "description.Config.CreateTime",
	"deployment_config_id":   "description.Config.DeploymentConfigId",
	"deployment_config_name": "description.Config.DeploymentConfigName",
	"og_account_id":          "metadata.SourceID",
	"minimum_healthy_hosts":  "description.Config.MinimumHealthyHosts",
	"title":                  "description.Config.DeploymentConfigName",
	"traffic_routing_config": "description.Config.TrafficRoutingConfig",
}

func ListCodeDeployDeploymentConfig(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeDeployDeploymentConfig")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentConfig NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentConfig NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentConfig GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeDeployDeploymentConfigPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeDeployDeploymentConfigFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeDeployDeploymentConfig NewCodeDeployDeploymentConfigPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeDeployDeploymentConfig paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeDeployDeploymentConfigFilters = map[string]string{
	"application_name":       "description.Application.ApplicationName",
	"compute_platform":       "description.Config.ComputePlatform",
	"create_time":            "description.Config.CreateTime",
	"deployment_config_id":   "description.Config.DeploymentConfigId",
	"deployment_config_name": "description.Config.DeploymentConfigName",
	"og_account_id":          "metadata.SourceID",
	"minimum_healthy_hosts":  "description.Config.MinimumHealthyHosts",
	"title":                  "description.Config.DeploymentConfigName",
	"traffic_routing_config": "description.Config.TrafficRoutingConfig",
}

func GetCodeDeployDeploymentConfig(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeDeployDeploymentConfig")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeDeployDeploymentConfigPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeDeployDeploymentConfigFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeDeployDeploymentConfig =============================

// ==========================  START: CodeStarProject =============================

type CodeStarProject struct {
	Description   aws.CodeStarProjectDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type CodeStarProjectHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CodeStarProject `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CodeStarProjectHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CodeStarProjectHit `json:"hits"`
}

type CodeStarProjectSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CodeStarProjectHits `json:"hits"`
}

type CodeStarProjectPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCodeStarProjectPaginator(filters []essdk.BoolFilter, limit *int64) (CodeStarProjectPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_codestar_project", filters, limit)
	if err != nil {
		return CodeStarProjectPaginator{}, err
	}

	p := CodeStarProjectPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CodeStarProjectPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CodeStarProjectPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CodeStarProjectPaginator) NextPage(ctx context.Context) ([]CodeStarProject, error) {
	var response CodeStarProjectSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CodeStarProject
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCodeStarProjectFilters = map[string]string{
	"arn":           "description.Project.Arn",
	"id":            "description.Project.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Project.Name",
	"tags":          "description.Tags",
	"title":         "description.Project.Name",
}

func ListCodeStarProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCodeStarProject")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeStarProject NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeStarProject NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeStarProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeStarProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeStarProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCodeStarProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCodeStarProjectFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCodeStarProject NewCodeStarProjectPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCodeStarProject paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCodeStarProjectFilters = map[string]string{
	"arn":           "description.Project.Arn",
	"id":            "description.Project.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Project.Name",
	"tags":          "description.Tags",
	"title":         "description.Project.Name",
}

func GetCodeStarProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCodeStarProject")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCodeStarProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCodeStarProjectFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CodeStarProject =============================

// ==========================  START: DirectConnectConnection =============================

type DirectConnectConnection struct {
	Description   aws.DirectConnectConnectionDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type DirectConnectConnectionHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  DirectConnectConnection `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type DirectConnectConnectionHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []DirectConnectConnectionHit `json:"hits"`
}

type DirectConnectConnectionSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  DirectConnectConnectionHits `json:"hits"`
}

type DirectConnectConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectConnectConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (DirectConnectConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directconnect_connection", filters, limit)
	if err != nil {
		return DirectConnectConnectionPaginator{}, err
	}

	p := DirectConnectConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectConnectConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectConnectConnectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DirectConnectConnectionPaginator) NextPage(ctx context.Context) ([]DirectConnectConnection, error) {
	var response DirectConnectConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectConnectConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectConnectConnectionFilters = map[string]string{
	"arn":           "arn",
	"connection_id": "description.Connection.ConnectionId",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Connection.ConnectionName",
	"title":         "description.Connection.ConnectionName",
}

func ListDirectConnectConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectConnectConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectConnection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectConnection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDirectConnectConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDirectConnectConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectConnection NewDirectConnectConnectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDirectConnectConnection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDirectConnectConnectionFilters = map[string]string{
	"arn":           "arn",
	"connection_id": "description.Connection.ConnectionId",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Connection.ConnectionName",
	"title":         "description.Connection.ConnectionName",
}

func GetDirectConnectConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectConnectConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDirectConnectConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDirectConnectConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DirectConnectConnection =============================

// ==========================  START: DirectConnectGateway =============================

type DirectConnectGateway struct {
	Description   aws.DirectConnectGatewayDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type DirectConnectGatewayHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  DirectConnectGateway `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type DirectConnectGatewayHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []DirectConnectGatewayHit `json:"hits"`
}

type DirectConnectGatewaySearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  DirectConnectGatewayHits `json:"hits"`
}

type DirectConnectGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDirectConnectGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (DirectConnectGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_directconnect_gateway", filters, limit)
	if err != nil {
		return DirectConnectGatewayPaginator{}, err
	}

	p := DirectConnectGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DirectConnectGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DirectConnectGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DirectConnectGatewayPaginator) NextPage(ctx context.Context) ([]DirectConnectGateway, error) {
	var response DirectConnectGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DirectConnectGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDirectConnectGatewayFilters = map[string]string{
	"arn":                       "arn",
	"direct_connect_gateway_id": "description.Gateway.DirectConnectGatewayId",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.Gateway.DirectConnectGatewayName",
	"title":                     "description.Gateway.DirectConnectGatewayName",
}

func ListDirectConnectGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDirectConnectGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDirectConnectGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDirectConnectGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDirectConnectGateway NewDirectConnectGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDirectConnectGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDirectConnectGatewayFilters = map[string]string{
	"arn":                       "arn",
	"direct_connect_gateway_id": "description.Gateway.DirectConnectGatewayId",
	"og_account_id":             "metadata.SourceID",
	"name":                      "description.Gateway.DirectConnectGatewayName",
	"title":                     "description.Gateway.DirectConnectGatewayName",
}

func GetDirectConnectGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDirectConnectGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDirectConnectGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDirectConnectGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DirectConnectGateway =============================

// ==========================  START: NetworkFirewallFirewall =============================

type NetworkFirewallFirewall struct {
	Description   aws.NetworkFirewallFirewallDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type NetworkFirewallFirewallHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  NetworkFirewallFirewall `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type NetworkFirewallFirewallHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []NetworkFirewallFirewallHit `json:"hits"`
}

type NetworkFirewallFirewallSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  NetworkFirewallFirewallHits `json:"hits"`
}

type NetworkFirewallFirewallPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkFirewallFirewallPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkFirewallFirewallPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_networkfirewall_firewall", filters, limit)
	if err != nil {
		return NetworkFirewallFirewallPaginator{}, err
	}

	p := NetworkFirewallFirewallPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkFirewallFirewallPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkFirewallFirewallPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkFirewallFirewallPaginator) NextPage(ctx context.Context) ([]NetworkFirewallFirewall, error) {
	var response NetworkFirewallFirewallSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkFirewallFirewall
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkFirewallFirewallFilters = map[string]string{
	"arn":                      "description.Firewall.FirewallArn",
	"delete_protection":        "description.Firewall.DeleteProtection",
	"description":              "description.Firewall.Description",
	"encryption_configuration": "description.Firewall.EncryptionConfiguration",
	"firewall_status":          "description.FirewallStatus",
	"id":                       "description.Firewall.FirewallId",
	"og_account_id":            "metadata.SourceID",
	"logging_configuration":    "description.LoggingConfiguration",
	"name":                     "description.Firewall.FirewallName",
	"policy_arn":               "description.Firewall.FirewallPolicyArn",
	"policy_change_protection": "description.Firewall.FirewallPolicyChangeProtection",
	"subnet_change_protection": "description.Firewall.SubnetChangeProtection",
	"subnet_mappings":          "description.Firewall.SubnetMappings",
	"tags_src":                 "description.Firewall.Tags",
	"title":                    "description.Firewall.FirewallName",
	"vpc_id":                   "description.Firewall.VpcId",
}

func ListNetworkFirewallFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkFirewallFirewall")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewall NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewall NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkFirewallFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkFirewallFirewallFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewall NewNetworkFirewallFirewallPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkFirewallFirewall paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkFirewallFirewallFilters = map[string]string{
	"arn":                      "description.Firewall.FirewallArn",
	"delete_protection":        "description.Firewall.DeleteProtection",
	"description":              "description.Firewall.Description",
	"encryption_configuration": "description.Firewall.EncryptionConfiguration",
	"firewall_name":            "description.Firewall.FirewallName",
	"firewall_status":          "description.FirewallStatus",
	"id":                       "description.Firewall.FirewallId",
	"og_account_id":            "metadata.SourceID",
	"logging_configuration":    "description.LoggingConfiguration",
	"name":                     "description.Firewall.FirewallName",
	"policy_arn":               "description.Firewall.FirewallPolicyArn",
	"policy_change_protection": "description.Firewall.FirewallPolicyChangeProtection",
	"subnet_change_protection": "description.Firewall.SubnetChangeProtection",
	"subnet_mappings":          "description.Firewall.SubnetMappings",
	"tags_src":                 "description.Firewall.Tags",
	"title":                    "description.Firewall.FirewallName",
	"vpc_id":                   "description.Firewall.VpcId",
}

func GetNetworkFirewallFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkFirewallFirewall")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkFirewallFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkFirewallFirewallFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkFirewallFirewall =============================

// ==========================  START: NetworkFirewallFirewallPolicy =============================

type NetworkFirewallFirewallPolicy struct {
	Description   aws.NetworkFirewallFirewallPolicyDescription `json:"description"`
	Metadata      aws.Metadata                                 `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type NetworkFirewallFirewallPolicyHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  NetworkFirewallFirewallPolicy `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type NetworkFirewallFirewallPolicyHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []NetworkFirewallFirewallPolicyHit `json:"hits"`
}

type NetworkFirewallFirewallPolicySearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  NetworkFirewallFirewallPolicyHits `json:"hits"`
}

type NetworkFirewallFirewallPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkFirewallFirewallPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkFirewallFirewallPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_networkfirewall_firewallpolicy", filters, limit)
	if err != nil {
		return NetworkFirewallFirewallPolicyPaginator{}, err
	}

	p := NetworkFirewallFirewallPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkFirewallFirewallPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkFirewallFirewallPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkFirewallFirewallPolicyPaginator) NextPage(ctx context.Context) ([]NetworkFirewallFirewallPolicy, error) {
	var response NetworkFirewallFirewallPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkFirewallFirewallPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkFirewallFirewallPolicyFilters = map[string]string{
	"arn":                              "arn",
	"consumed_stateful_rule_capacity":  "description.FirewallPolicyResponse.ConsumedStatefulRuleCapacity",
	"consumed_stateless_rule_capacity": "description.FirewallPolicyResponse.ConsumedStatelessRuleCapacity",
	"description":                      "description.FirewallPolicyResponse.Description",
	"encryption_configuration":         "description.FirewallPolicyResponse.EncryptionConfiguration",
	"firewall_policy":                  "description.FirewallPolicy",
	"firewall_policy_id":               "description.FirewallPolicyResponse.FirewallPolicyId",
	"firewall_policy_status":           "description.FirewallPolicyResponse.FirewallPolicyStatus",
	"og_account_id":                    "metadata.SourceID",
	"last_modified_time":               "description.FirewallPolicyResponse.LastModifiedTime",
	"name":                             "description.FirewallPolicyResponse.FirewallPolicyName",
	"number_of_associations":           "description.FirewallPolicyResponse.NumberOfAssociations",
	"tags_src":                         "description.FirewallPolicyResponse.Tags",
	"title":                            "description.FirewallPolicyResponse.FirewallPolicyName",
}

func ListNetworkFirewallFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkFirewallFirewallPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewallPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewallPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewallPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewallPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewallPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkFirewallFirewallPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkFirewallFirewallPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallFirewallPolicy NewNetworkFirewallFirewallPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkFirewallFirewallPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkFirewallFirewallPolicyFilters = map[string]string{
	"arn":                              "description.FirewallPolicyResponse.FirewallPolicyArn",
	"consumed_stateful_rule_capacity":  "description.FirewallPolicyResponse.ConsumedStatefulRuleCapacity",
	"consumed_stateless_rule_capacity": "description.FirewallPolicyResponse.ConsumedStatelessRuleCapacity",
	"description":                      "description.FirewallPolicyResponse.Description",
	"encryption_configuration":         "description.FirewallPolicyResponse.EncryptionConfiguration",
	"firewall_policy":                  "description.FirewallPolicy",
	"firewall_policy_id":               "description.FirewallPolicyResponse.FirewallPolicyId",
	"firewall_policy_status":           "description.FirewallPolicyResponse.FirewallPolicyStatus",
	"og_account_id":                    "metadata.SourceID",
	"last_modified_time":               "description.FirewallPolicyResponse.LastModifiedTime",
	"name":                             "description.FirewallPolicyResponse.FirewallPolicyName",
	"number_of_associations":           "description.FirewallPolicyResponse.NumberOfAssociations",
	"tags_src":                         "description.FirewallPolicyResponse.Tags",
	"title":                            "description.FirewallPolicyResponse.FirewallPolicyName",
}

func GetNetworkFirewallFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkFirewallFirewallPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkFirewallFirewallPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkFirewallFirewallPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkFirewallFirewallPolicy =============================

// ==========================  START: NetworkFirewallRuleGroup =============================

type NetworkFirewallRuleGroup struct {
	Description   aws.NetworkFirewallRuleGroupDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type NetworkFirewallRuleGroupHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  NetworkFirewallRuleGroup `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type NetworkFirewallRuleGroupHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []NetworkFirewallRuleGroupHit `json:"hits"`
}

type NetworkFirewallRuleGroupSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  NetworkFirewallRuleGroupHits `json:"hits"`
}

type NetworkFirewallRuleGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkFirewallRuleGroupPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkFirewallRuleGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_networkfirewall_rulegroup", filters, limit)
	if err != nil {
		return NetworkFirewallRuleGroupPaginator{}, err
	}

	p := NetworkFirewallRuleGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkFirewallRuleGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkFirewallRuleGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkFirewallRuleGroupPaginator) NextPage(ctx context.Context) ([]NetworkFirewallRuleGroup, error) {
	var response NetworkFirewallRuleGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkFirewallRuleGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkFirewallRuleGroupFilters = map[string]string{
	"arn":                    "description.RuleGroupResponse.RuleGroupArn",
	"capacity":               "description.RuleGroupResponse.Capacity",
	"consumed_capacity":      "description.RuleGroupResponse.ConsumedCapacity",
	"description":            "description.RuleGroupResponse.Description",
	"og_account_id":          "metadata.SourceID",
	"number_of_associations": "description.RuleGroupResponse.NumberOfAssociations",
	"rule_group_id":          "description.RuleGroupResponse.RuleGroupId",
	"rule_group_name":        "description.RuleGroupResponse.RuleGroupName",
	"rule_group_status":      "description.RuleGroupResponse.RuleGroupStatus",
	"rule_variables":         "description.RuleGroup.RuleVariables",
	"rules_source":           "description.RuleGroup.RulesSource",
	"stateful_rule_options":  "description.RuleGroup.StatefulRuleOptions",
	"tags_src":               "description.RuleGroupResponse.Tags",
	"title":                  "description.RuleGroupResponse.RuleGroupName",
	"type":                   "description.RuleGroupResponse.Type",
}

func ListNetworkFirewallRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkFirewallRuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallRuleGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallRuleGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallRuleGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkFirewallRuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkFirewallRuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkFirewallRuleGroup NewNetworkFirewallRuleGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkFirewallRuleGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkFirewallRuleGroupFilters = map[string]string{
	"arn":                    "description.RuleGroupResponse.RuleGroupArn",
	"capacity":               "description.RuleGroupResponse.Capacity",
	"consumed_capacity":      "description.RuleGroupResponse.ConsumedCapacity",
	"description":            "description.RuleGroupResponse.Description",
	"og_account_id":          "metadata.SourceID",
	"number_of_associations": "description.RuleGroupResponse.NumberOfAssociations",
	"rule_group_id":          "description.RuleGroupResponse.RuleGroupId",
	"rule_group_name":        "description.RuleGroupResponse.RuleGroupName",
	"rule_group_status":      "description.RuleGroupResponse.RuleGroupStatus",
	"rule_variables":         "description.RuleGroup.RuleVariables",
	"rules_source":           "description.RuleGroup.RulesSource",
	"stateful_rule_options":  "description.RuleGroup.StatefulRuleOptions",
	"tags_src":               "description.RuleGroupResponse.Tags",
	"title":                  "description.RuleGroupResponse.RuleGroupName",
	"type":                   "description.RuleGroupResponse.Type",
}

func GetNetworkFirewallRuleGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkFirewallRuleGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkFirewallRuleGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkFirewallRuleGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkFirewallRuleGroup =============================

// ==========================  START: OpsWorksCMServer =============================

type OpsWorksCMServer struct {
	Description   aws.OpsWorksCMServerDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type OpsWorksCMServerHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  OpsWorksCMServer `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type OpsWorksCMServerHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []OpsWorksCMServerHit `json:"hits"`
}

type OpsWorksCMServerSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  OpsWorksCMServerHits `json:"hits"`
}

type OpsWorksCMServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOpsWorksCMServerPaginator(filters []essdk.BoolFilter, limit *int64) (OpsWorksCMServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_opsworkscm_server", filters, limit)
	if err != nil {
		return OpsWorksCMServerPaginator{}, err
	}

	p := OpsWorksCMServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OpsWorksCMServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OpsWorksCMServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OpsWorksCMServerPaginator) NextPage(ctx context.Context) ([]OpsWorksCMServer, error) {
	var response OpsWorksCMServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OpsWorksCMServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOpsWorksCMServerFilters = map[string]string{
	"arn":           "description.Server.ServerArn",
	"og_account_id": "metadata.SourceID",
	"server_name":   "description.Server.ServerName",
	"title":         "description.Server.ServerName",
}

func ListOpsWorksCMServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOpsWorksCMServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpsWorksCMServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpsWorksCMServer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpsWorksCMServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpsWorksCMServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpsWorksCMServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOpsWorksCMServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOpsWorksCMServerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpsWorksCMServer NewOpsWorksCMServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOpsWorksCMServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOpsWorksCMServerFilters = map[string]string{
	"arn":           "description.Server.ServerArn",
	"og_account_id": "metadata.SourceID",
	"server_name":   "description.Server.ServerName",
	"title":         "description.Server.ServerName",
}

func GetOpsWorksCMServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOpsWorksCMServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOpsWorksCMServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOpsWorksCMServerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OpsWorksCMServer =============================

// ==========================  START: OrganizationsOrganization =============================

type OrganizationsOrganization struct {
	Description   aws.OrganizationsOrganizationDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type OrganizationsOrganizationHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  OrganizationsOrganization `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type OrganizationsOrganizationHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []OrganizationsOrganizationHit `json:"hits"`
}

type OrganizationsOrganizationSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  OrganizationsOrganizationHits `json:"hits"`
}

type OrganizationsOrganizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsOrganizationPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsOrganizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_organization", filters, limit)
	if err != nil {
		return OrganizationsOrganizationPaginator{}, err
	}

	p := OrganizationsOrganizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsOrganizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsOrganizationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationsOrganizationPaginator) NextPage(ctx context.Context) ([]OrganizationsOrganization, error) {
	var response OrganizationsOrganizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsOrganization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsOrganizationFilters = map[string]string{
	"arn":           "description.Organization.Arn",
	"id":            "description.Organization.Id",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Organization.Id",
}

func ListOrganizationsOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsOrganization")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganization NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganization NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganization GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationsOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationsOrganizationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganization NewOrganizationsOrganizationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganizationsOrganization paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationsOrganizationFilters = map[string]string{
	"arn":           "description.Organization.Arn",
	"id":            "description.Organization.Id",
	"og_account_id": "metadata.SourceID",
	"title":         "description.Organization.Id",
}

func GetOrganizationsOrganization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsOrganization")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationsOrganizationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationsOrganizationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrganizationsOrganization =============================

// ==========================  START: OrganizationsAccount =============================

type OrganizationsAccount struct {
	Description   aws.OrganizationsAccountDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type OrganizationsAccountHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  OrganizationsAccount `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type OrganizationsAccountHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []OrganizationsAccountHit `json:"hits"`
}

type OrganizationsAccountSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  OrganizationsAccountHits `json:"hits"`
}

type OrganizationsAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsAccountPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_account", filters, limit)
	if err != nil {
		return OrganizationsAccountPaginator{}, err
	}

	p := OrganizationsAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationsAccountPaginator) NextPage(ctx context.Context) ([]OrganizationsAccount, error) {
	var response OrganizationsAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsAccountFilters = map[string]string{
	"arn":              "description.Account.Arn",
	"email":            "description.Account.Email",
	"id":               "description.Account.Id",
	"joined_method":    "description.Account.JoinedMethod",
	"joined_timestamp": "description.Account.JoinedTimestamp",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Account.Name",
	"parent_id":        "description.ParentID",
	"status":           "description.Account.Status",
	"tags_src":         "description.Tags",
	"title":            "description.Account.Name",
}

func ListOrganizationsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationsAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationsAccountFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsAccount NewOrganizationsAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganizationsAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationsAccountFilters = map[string]string{
	"arn":              "description.Account.Arn",
	"email":            "description.Account.Email",
	"id":               "description.Account.Id",
	"joined_method":    "description.Account.JoinedMethod",
	"joined_timestamp": "description.Account.JoinedTimestamp",
	"og_account_id":    "metadata.SourceID",
	"name":             "description.Account.Name",
	"parent_id":        "description.ParentID",
	"status":           "description.Account.Status",
	"tags_src":         "description.Tags",
	"title":            "description.Account.Name",
}

func GetOrganizationsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationsAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationsAccountFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrganizationsAccount =============================

// ==========================  START: OrganizationsPolicy =============================

type OrganizationsPolicy struct {
	Description   aws.OrganizationsPolicyDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type OrganizationsPolicyHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  OrganizationsPolicy `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type OrganizationsPolicyHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []OrganizationsPolicyHit `json:"hits"`
}

type OrganizationsPolicySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  OrganizationsPolicyHits `json:"hits"`
}

type OrganizationsPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_policy", filters, limit)
	if err != nil {
		return OrganizationsPolicyPaginator{}, err
	}

	p := OrganizationsPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationsPolicyPaginator) NextPage(ctx context.Context) ([]OrganizationsPolicy, error) {
	var response OrganizationsPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsPolicyFilters = map[string]string{
	"arn":           "description.Policy.PolicySummary.Arn",
	"aws_managed":   "description.Policy.PolicySummary.AwsManaged",
	"content":       "description.Policy.Content",
	"description":   "description.Policy.PolicySummary.Description",
	"id":            "description.Policy.PolicySummary.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Policy.PolicySummary.Name",
	"title":         "description.Policy.PolicySummary.Name",
	"type":          "description.Policy.PolicySummary.Type",
}

func ListOrganizationsPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationsPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationsPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicy NewOrganizationsPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganizationsPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationsPolicyFilters = map[string]string{
	"arn":           "description.Policy.PolicySummary.Arn",
	"aws_managed":   "description.Policy.PolicySummary.AwsManaged",
	"content":       "description.Policy.Content",
	"description":   "description.Policy.PolicySummary.Description",
	"id":            "description.Policy.PolicySummary.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Policy.PolicySummary.Name",
	"title":         "description.Policy.PolicySummary.Name",
	"type":          "description.Policy.PolicySummary.Type",
}

func GetOrganizationsPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationsPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationsPolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrganizationsPolicy =============================

// ==========================  START: OrganizationsRoot =============================

type OrganizationsRoot struct {
	Description   aws.OrganizationsRootDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type OrganizationsRootHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  OrganizationsRoot `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type OrganizationsRootHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []OrganizationsRootHit `json:"hits"`
}

type OrganizationsRootSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  OrganizationsRootHits `json:"hits"`
}

type OrganizationsRootPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsRootPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsRootPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_root", filters, limit)
	if err != nil {
		return OrganizationsRootPaginator{}, err
	}

	p := OrganizationsRootPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsRootPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsRootPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationsRootPaginator) NextPage(ctx context.Context) ([]OrganizationsRoot, error) {
	var response OrganizationsRootSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsRoot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsRootFilters = map[string]string{
	"arn":          "description.Root.Arn",
	"id":           "description.Root.Id",
	"name":         "description.Root.Name",
	"policy_types": "description.Root.PolicyTypes",
	"title":        "description.Root.Name",
}

func ListOrganizationsRoot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsRoot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsRoot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsRoot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsRoot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsRoot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsRoot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationsRootPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationsRootFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsRoot NewOrganizationsRootPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganizationsRoot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationsRootFilters = map[string]string{
	"arn":          "description.Root.Arn",
	"id":           "description.Root.Id",
	"name":         "description.Root.Name",
	"policy_types": "description.Root.PolicyTypes",
	"title":        "description.Root.Name",
}

func GetOrganizationsRoot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsRoot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationsRootPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationsRootFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrganizationsRoot =============================

// ==========================  START: OrganizationsOrganizationalUnit =============================

type OrganizationsOrganizationalUnit struct {
	Description   aws.OrganizationsOrganizationalUnitDescription `json:"description"`
	Metadata      aws.Metadata                                   `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type OrganizationsOrganizationalUnitHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  OrganizationsOrganizationalUnit `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type OrganizationsOrganizationalUnitHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []OrganizationsOrganizationalUnitHit `json:"hits"`
}

type OrganizationsOrganizationalUnitSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  OrganizationsOrganizationalUnitHits `json:"hits"`
}

type OrganizationsOrganizationalUnitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsOrganizationalUnitPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsOrganizationalUnitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_organizationalunit", filters, limit)
	if err != nil {
		return OrganizationsOrganizationalUnitPaginator{}, err
	}

	p := OrganizationsOrganizationalUnitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsOrganizationalUnitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsOrganizationalUnitPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationsOrganizationalUnitPaginator) NextPage(ctx context.Context) ([]OrganizationsOrganizationalUnit, error) {
	var response OrganizationsOrganizationalUnitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsOrganizationalUnit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsOrganizationalUnitFilters = map[string]string{
	"arn":       "description.Unit.Arn",
	"id":        "description.Unit.Id",
	"name":      "description.Unit.Name",
	"parent_id": "description.ParentId",
	"path":      "description.Path",
	"tags":      "description.Tags",
	"title":     "description.Unit.Name",
}

func ListOrganizationsOrganizationalUnit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsOrganizationalUnit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganizationalUnit NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganizationalUnit NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganizationalUnit GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganizationalUnit GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganizationalUnit GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationsOrganizationalUnitPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationsOrganizationalUnitFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsOrganizationalUnit NewOrganizationsOrganizationalUnitPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganizationsOrganizationalUnit paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationsOrganizationalUnitFilters = map[string]string{
	"arn":       "description.Unit.Arn",
	"id":        "description.Unit.Id",
	"name":      "description.Unit.Name",
	"parent_id": "description.ParentId",
	"path":      "description.Path",
	"tags":      "description.Tags",
	"title":     "description.Unit.Name",
}

func GetOrganizationsOrganizationalUnit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsOrganizationalUnit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationsOrganizationalUnitPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationsOrganizationalUnitFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrganizationsOrganizationalUnit =============================

// ==========================  START: OrganizationsPolicyTarget =============================

type OrganizationsPolicyTarget struct {
	Description   aws.OrganizationsPolicyTargetDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type OrganizationsPolicyTargetHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  OrganizationsPolicyTarget `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type OrganizationsPolicyTargetHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []OrganizationsPolicyTargetHit `json:"hits"`
}

type OrganizationsPolicyTargetSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  OrganizationsPolicyTargetHits `json:"hits"`
}

type OrganizationsPolicyTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOrganizationsPolicyTargetPaginator(filters []essdk.BoolFilter, limit *int64) (OrganizationsPolicyTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_organizations_policytarget", filters, limit)
	if err != nil {
		return OrganizationsPolicyTargetPaginator{}, err
	}

	p := OrganizationsPolicyTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OrganizationsPolicyTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OrganizationsPolicyTargetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OrganizationsPolicyTargetPaginator) NextPage(ctx context.Context) ([]OrganizationsPolicyTarget, error) {
	var response OrganizationsPolicyTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OrganizationsPolicyTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOrganizationsPolicyTargetFilters = map[string]string{
	"arn":         "description.PolicySummary.Arn",
	"aws_managed": "description.PolicySummary.AwsManaged",
	"content":     "description.PolicyContent",
	"description": "description.PolicySummary.Description",
	"id":          "description.PolicySummary.Id",
	"name":        "description.PolicySummary.Name",
	"target_id":   "description.TargetId",
	"title":       "description.PolicySummary.Name",
	"type":        "description.PolicySummary.Type",
}

func ListOrganizationsPolicyTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOrganizationsPolicyTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicyTarget NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicyTarget NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicyTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicyTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicyTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOrganizationsPolicyTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOrganizationsPolicyTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOrganizationsPolicyTarget NewOrganizationsPolicyTargetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOrganizationsPolicyTarget paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOrganizationsPolicyTargetFilters = map[string]string{
	"arn":         "description.PolicySummary.Arn",
	"aws_managed": "description.PolicySummary.AwsManaged",
	"content":     "description.PolicyContent",
	"description": "description.PolicySummary.Description",
	"id":          "description.PolicySummary.Id",
	"name":        "description.PolicySummary.Name",
	"target_id":   "description.TargetId",
	"title":       "description.PolicySummary.Name",
	"type":        "description.PolicySummary.Type",
}

func GetOrganizationsPolicyTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOrganizationsPolicyTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOrganizationsPolicyTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOrganizationsPolicyTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OrganizationsPolicyTarget =============================

// ==========================  START: PinPointApp =============================

type PinPointApp struct {
	Description   aws.PinPointAppDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type PinPointAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PinPointApp   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PinPointAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PinPointAppHit  `json:"hits"`
}

type PinPointAppSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  PinPointAppHits `json:"hits"`
}

type PinPointAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPinPointAppPaginator(filters []essdk.BoolFilter, limit *int64) (PinPointAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_pinpoint_app", filters, limit)
	if err != nil {
		return PinPointAppPaginator{}, err
	}

	p := PinPointAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PinPointAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PinPointAppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PinPointAppPaginator) NextPage(ctx context.Context) ([]PinPointApp, error) {
	var response PinPointAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PinPointApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPinPointAppFilters = map[string]string{
	"arn":                "description.App.Arn",
	"campaign_hook":      "description.Settings.CampaignHook",
	"id":                 "description.App.Id",
	"og_account_id":      "metadata.SourceID",
	"last_modified_date": "description.Settings.LastModifiedDate",
	"limits":             "description.Settings.Limits",
	"name":               "description.App.Name",
	"quiet_time":         "description.Settings.QuietTime",
	"tags":               "description.App.Tags",
	"title":              "description.App.Name",
}

func ListPinPointApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPinPointApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPinPointApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPinPointApp NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPinPointApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPinPointApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPinPointApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPinPointAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPinPointAppFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPinPointApp NewPinPointAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPinPointApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPinPointAppFilters = map[string]string{
	"arn":                "description.App.Arn",
	"campaign_hook":      "description.Settings.CampaignHook",
	"id":                 "description.App.Id",
	"og_account_id":      "metadata.SourceID",
	"last_modified_date": "description.Settings.LastModifiedDate",
	"limits":             "description.Settings.Limits",
	"name":               "description.App.Name",
	"quiet_time":         "description.Settings.QuietTime",
	"tags":               "description.App.Tags",
	"title":              "description.App.Name",
}

func GetPinPointApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPinPointApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPinPointAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPinPointAppFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PinPointApp =============================

// ==========================  START: PipesPipe =============================

type PipesPipe struct {
	Description   aws.PipesPipeDescription `json:"description"`
	Metadata      aws.Metadata             `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type PipesPipeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PipesPipe     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PipesPipeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PipesPipeHit    `json:"hits"`
}

type PipesPipeSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  PipesPipeHits `json:"hits"`
}

type PipesPipePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPipesPipePaginator(filters []essdk.BoolFilter, limit *int64) (PipesPipePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_pipes_pipe", filters, limit)
	if err != nil {
		return PipesPipePaginator{}, err
	}

	p := PipesPipePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PipesPipePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PipesPipePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PipesPipePaginator) NextPage(ctx context.Context) ([]PipesPipe, error) {
	var response PipesPipeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PipesPipe
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPipesPipeFilters = map[string]string{
	"arn":                   "description.Pipe.Arn",
	"creation_time":         "description.Pipe.CreationTime",
	"current_state":         "description.PipeOutput.CurrentState",
	"description":           "description.PipeOutput.Description",
	"desired_state":         "description.PipeOutput.DesiredState",
	"enrichment":            "description.Pipe.Enrichment",
	"enrichment_parameters": "description.PipeOutput.EnrichmentParameters",
	"og_account_id":         "metadata.SourceID",
	"last_modified_time":    "description.Pipe.LastModifiedTime",
	"name":                  "description.Pipe.Name",
	"role_arn":              "description.PipeOutput.RoleArn",
	"source":                "description.Pipe.Source",
	"state_reason":          "description.Pipe.StateReason",
	"tags":                  "description.PipeOutput.Tags",
	"target":                "description.Pipe.Target",
	"target_parameters":     "description.PipeOutput.TargetParameters",
	"title":                 "description.Pipe.Name",
}

func ListPipesPipe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPipesPipe")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPipesPipe NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPipesPipe NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPipesPipe GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPipesPipe GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPipesPipe GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPipesPipePaginator(essdk.BuildFilter(ctx, d.QueryContext, listPipesPipeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPipesPipe NewPipesPipePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPipesPipe paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPipesPipeFilters = map[string]string{
	"arn":                   "description.Pipe.Arn",
	"creation_time":         "description.Pipe.CreationTime",
	"current_state":         "description.Pipe.CurrentState",
	"description":           "description.PipeOutput.Description",
	"desired_state":         "description.Pipe.DesiredState",
	"enrichment":            "description.Pipe.Enrichment",
	"enrichment_parameters": "description.PipeOutput.EnrichmentParameters",
	"og_account_id":         "metadata.SourceID",
	"last_modified_time":    "description.Pipe.LastModifiedTime",
	"name":                  "description.PipeOutput.Name",
	"role_arn":              "description.PipeOutput.RoleArn",
	"source":                "description.Pipe.Source",
	"state_reason":          "description.Pipe.StateReason",
	"tags":                  "description.PipeOutput.Tags",
	"target":                "description.Pipe.Target",
	"target_parameters":     "description.PipeOutput.TargetParameters",
	"title":                 "description.Pipe.Name",
}

func GetPipesPipe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPipesPipe")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPipesPipePaginator(essdk.BuildFilter(ctx, d.QueryContext, getPipesPipeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PipesPipe =============================

// ==========================  START: ResourceGroupsGroup =============================

type ResourceGroupsGroup struct {
	Description   aws.ResourceGroupsGroupDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type ResourceGroupsGroupHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ResourceGroupsGroup `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ResourceGroupsGroupHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ResourceGroupsGroupHit `json:"hits"`
}

type ResourceGroupsGroupSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ResourceGroupsGroupHits `json:"hits"`
}

type ResourceGroupsGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceGroupsGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceGroupsGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_resourcegroups_groups", filters, limit)
	if err != nil {
		return ResourceGroupsGroupPaginator{}, err
	}

	p := ResourceGroupsGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceGroupsGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceGroupsGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ResourceGroupsGroupPaginator) NextPage(ctx context.Context) ([]ResourceGroupsGroup, error) {
	var response ResourceGroupsGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceGroupsGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceGroupsGroupFilters = map[string]string{
	"arn":           "description.GroupIdentifier.GroupArn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.GroupIdentifier.GroupName",
	"title":         "description.GroupIdentifier.GroupName",
}

func ListResourceGroupsGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceGroupsGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroupsGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroupsGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroupsGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroupsGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroupsGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewResourceGroupsGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listResourceGroupsGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroupsGroup NewResourceGroupsGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListResourceGroupsGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getResourceGroupsGroupFilters = map[string]string{
	"arn":           "description.GroupIdentifier.GroupArn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.GroupIdentifier.GroupName",
	"title":         "description.GroupIdentifier.GroupName",
}

func GetResourceGroupsGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceGroupsGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewResourceGroupsGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getResourceGroupsGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ResourceGroupsGroup =============================

// ==========================  START: OpenSearchServerlessCollection =============================

type OpenSearchServerlessCollection struct {
	Description   aws.OpenSearchServerlessCollectionDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type OpenSearchServerlessCollectionHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  OpenSearchServerlessCollection `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type OpenSearchServerlessCollectionHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []OpenSearchServerlessCollectionHit `json:"hits"`
}

type OpenSearchServerlessCollectionSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  OpenSearchServerlessCollectionHits `json:"hits"`
}

type OpenSearchServerlessCollectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOpenSearchServerlessCollectionPaginator(filters []essdk.BoolFilter, limit *int64) (OpenSearchServerlessCollectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_opensearchserverless_collection", filters, limit)
	if err != nil {
		return OpenSearchServerlessCollectionPaginator{}, err
	}

	p := OpenSearchServerlessCollectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OpenSearchServerlessCollectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OpenSearchServerlessCollectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OpenSearchServerlessCollectionPaginator) NextPage(ctx context.Context) ([]OpenSearchServerlessCollection, error) {
	var response OpenSearchServerlessCollectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OpenSearchServerlessCollection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOpenSearchServerlessCollectionFilters = map[string]string{
	"arn":           "description.CollectionSummary.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Collection.Name",
	"tags":          "description.Collection.Tags",
	"title":         "description.CollectionSummary.Name",
}

func ListOpenSearchServerlessCollection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOpenSearchServerlessCollection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchServerlessCollection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchServerlessCollection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchServerlessCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchServerlessCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchServerlessCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOpenSearchServerlessCollectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOpenSearchServerlessCollectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOpenSearchServerlessCollection NewOpenSearchServerlessCollectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOpenSearchServerlessCollection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOpenSearchServerlessCollectionFilters = map[string]string{
	"arn":           "description.CollectionSummary.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.CollectionSummary.Name",
	"tags":          "description.Collection.Tags",
	"title":         "description.CollectionSummary.Name",
}

func GetOpenSearchServerlessCollection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOpenSearchServerlessCollection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOpenSearchServerlessCollectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOpenSearchServerlessCollectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OpenSearchServerlessCollection =============================

// ==========================  START: TimestreamDatabase =============================

type TimestreamDatabase struct {
	Description   aws.TimestreamDatabaseDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type TimestreamDatabaseHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  TimestreamDatabase `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type TimestreamDatabaseHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []TimestreamDatabaseHit `json:"hits"`
}

type TimestreamDatabaseSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  TimestreamDatabaseHits `json:"hits"`
}

type TimestreamDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTimestreamDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (TimestreamDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_timestream_database", filters, limit)
	if err != nil {
		return TimestreamDatabasePaginator{}, err
	}

	p := TimestreamDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TimestreamDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TimestreamDatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TimestreamDatabasePaginator) NextPage(ctx context.Context) ([]TimestreamDatabase, error) {
	var response TimestreamDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TimestreamDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTimestreamDatabaseFilters = map[string]string{
	"arn":           "description.Database.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Database.DatabaseName",
	"tags":          "description.Tags",
	"title":         "description.Database.DatabaseName",
}

func ListTimestreamDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTimestreamDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTimestreamDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTimestreamDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTimestreamDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTimestreamDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTimestreamDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTimestreamDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listTimestreamDatabaseFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTimestreamDatabase NewTimestreamDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTimestreamDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTimestreamDatabaseFilters = map[string]string{
	"arn":           "description.Database.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Database.DatabaseName",
	"tags":          "description.Tags",
	"title":         "description.Database.DatabaseName",
}

func GetTimestreamDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTimestreamDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTimestreamDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getTimestreamDatabaseFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TimestreamDatabase =============================

// ==========================  START: ResourceExplorer2Index =============================

type ResourceExplorer2Index struct {
	Description   aws.ResourceExplorer2IndexDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ResourceExplorer2IndexHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ResourceExplorer2Index `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ResourceExplorer2IndexHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ResourceExplorer2IndexHit `json:"hits"`
}

type ResourceExplorer2IndexSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ResourceExplorer2IndexHits `json:"hits"`
}

type ResourceExplorer2IndexPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceExplorer2IndexPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceExplorer2IndexPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_resourceexplorer2_index", filters, limit)
	if err != nil {
		return ResourceExplorer2IndexPaginator{}, err
	}

	p := ResourceExplorer2IndexPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceExplorer2IndexPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceExplorer2IndexPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ResourceExplorer2IndexPaginator) NextPage(ctx context.Context) ([]ResourceExplorer2Index, error) {
	var response ResourceExplorer2IndexSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceExplorer2Index
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceExplorer2IndexFilters = map[string]string{
	"arn":           "description.Index.Arn",
	"og_account_id": "metadata.SourceID",
	"region":        "description.Index.Region",
	"type":          "description.Index.Type",
}

func ListResourceExplorer2Index(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceExplorer2Index")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2Index NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2Index NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2Index GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2Index GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2Index GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewResourceExplorer2IndexPaginator(essdk.BuildFilter(ctx, d.QueryContext, listResourceExplorer2IndexFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2Index NewResourceExplorer2IndexPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListResourceExplorer2Index paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getResourceExplorer2IndexFilters = map[string]string{
	"arn":           "description.Index.Arn",
	"og_account_id": "metadata.SourceID",
	"region":        "description.Index.Region",
	"type":          "description.Index.Type",
}

func GetResourceExplorer2Index(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceExplorer2Index")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewResourceExplorer2IndexPaginator(essdk.BuildFilter(ctx, d.QueryContext, getResourceExplorer2IndexFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ResourceExplorer2Index =============================

// ==========================  START: ResourceExplorer2SupportedResourceType =============================

type ResourceExplorer2SupportedResourceType struct {
	Description   aws.ResourceExplorer2SupportedResourceTypeDescription `json:"description"`
	Metadata      aws.Metadata                                          `json:"metadata"`
	ResourceJobID int                                                   `json:"resource_job_id"`
	SourceJobID   int                                                   `json:"source_job_id"`
	ResourceType  string                                                `json:"resource_type"`
	SourceType    string                                                `json:"source_type"`
	ID            string                                                `json:"id"`
	ARN           string                                                `json:"arn"`
	SourceID      string                                                `json:"source_id"`
}

type ResourceExplorer2SupportedResourceTypeHit struct {
	ID      string                                 `json:"_id"`
	Score   float64                                `json:"_score"`
	Index   string                                 `json:"_index"`
	Type    string                                 `json:"_type"`
	Version int64                                  `json:"_version,omitempty"`
	Source  ResourceExplorer2SupportedResourceType `json:"_source"`
	Sort    []interface{}                          `json:"sort"`
}

type ResourceExplorer2SupportedResourceTypeHits struct {
	Total essdk.SearchTotal                           `json:"total"`
	Hits  []ResourceExplorer2SupportedResourceTypeHit `json:"hits"`
}

type ResourceExplorer2SupportedResourceTypeSearchResponse struct {
	PitID string                                     `json:"pit_id"`
	Hits  ResourceExplorer2SupportedResourceTypeHits `json:"hits"`
}

type ResourceExplorer2SupportedResourceTypePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceExplorer2SupportedResourceTypePaginator(filters []essdk.BoolFilter, limit *int64) (ResourceExplorer2SupportedResourceTypePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_resourceexplorer2_supportedresourcetype", filters, limit)
	if err != nil {
		return ResourceExplorer2SupportedResourceTypePaginator{}, err
	}

	p := ResourceExplorer2SupportedResourceTypePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceExplorer2SupportedResourceTypePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceExplorer2SupportedResourceTypePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ResourceExplorer2SupportedResourceTypePaginator) NextPage(ctx context.Context) ([]ResourceExplorer2SupportedResourceType, error) {
	var response ResourceExplorer2SupportedResourceTypeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceExplorer2SupportedResourceType
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceExplorer2SupportedResourceTypeFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"resource_type": "description.SupportedResourceType.ResourceType",
	"service":       "description.SupportedResourceType.Service",
}

func ListResourceExplorer2SupportedResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceExplorer2SupportedResourceType")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2SupportedResourceType NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2SupportedResourceType NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2SupportedResourceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2SupportedResourceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2SupportedResourceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewResourceExplorer2SupportedResourceTypePaginator(essdk.BuildFilter(ctx, d.QueryContext, listResourceExplorer2SupportedResourceTypeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceExplorer2SupportedResourceType NewResourceExplorer2SupportedResourceTypePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListResourceExplorer2SupportedResourceType paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getResourceExplorer2SupportedResourceTypeFilters = map[string]string{
	"og_account_id": "metadata.SourceID",
	"resource_type": "description.SupportedResourceType.ResourceType",
	"service":       "description.SupportedResourceType.Service",
}

func GetResourceExplorer2SupportedResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceExplorer2SupportedResourceType")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewResourceExplorer2SupportedResourceTypePaginator(essdk.BuildFilter(ctx, d.QueryContext, getResourceExplorer2SupportedResourceTypeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ResourceExplorer2SupportedResourceType =============================

// ==========================  START: StepFunctionsStateMachine =============================

type StepFunctionsStateMachine struct {
	Description   aws.StepFunctionsStateMachineDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type StepFunctionsStateMachineHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  StepFunctionsStateMachine `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type StepFunctionsStateMachineHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []StepFunctionsStateMachineHit `json:"hits"`
}

type StepFunctionsStateMachineSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  StepFunctionsStateMachineHits `json:"hits"`
}

type StepFunctionsStateMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStepFunctionsStateMachinePaginator(filters []essdk.BoolFilter, limit *int64) (StepFunctionsStateMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_stepfunctions_statemachine", filters, limit)
	if err != nil {
		return StepFunctionsStateMachinePaginator{}, err
	}

	p := StepFunctionsStateMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StepFunctionsStateMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StepFunctionsStateMachinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StepFunctionsStateMachinePaginator) NextPage(ctx context.Context) ([]StepFunctionsStateMachine, error) {
	var response StepFunctionsStateMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StepFunctionsStateMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStepFunctionsStateMachineFilters = map[string]string{
	"arn":                   "description.StateMachine.StateMachineArn",
	"creation_date":         "description.StateMachine.CreationDate",
	"definition":            "description.StateMachine.Definition",
	"og_account_id":         "metadata.SourceID",
	"logging_configuration": "description.StateMachine.LoggingConfiguration",
	"name":                  "description.StateMachine.Name",
	"role_arn":              "description.StateMachine.RoleArn",
	"status":                "description.StateMachine.Status",
	"tags_src":              "description.Tags",
	"title":                 "description.StateMachine.Name",
	"tracing_configuration": "description.StateMachine.TracingConfiguration",
	"type":                  "description.StateMachine.Type",
}

func ListStepFunctionsStateMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStepFunctionsStateMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachine NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachine NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStepFunctionsStateMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listStepFunctionsStateMachineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachine NewStepFunctionsStateMachinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStepFunctionsStateMachine paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStepFunctionsStateMachineFilters = map[string]string{
	"arn":                   "description.StateMachineItem.StateMachineArn",
	"creation_date":         "description.StateMachine.CreationDate",
	"definition":            "description.StateMachine.Definition",
	"og_account_id":         "metadata.SourceID",
	"logging_configuration": "description.StateMachine.LoggingConfiguration",
	"name":                  "description.StateMachine.Name",
	"role_arn":              "description.StateMachine.RoleArn",
	"status":                "description.StateMachine.Status",
	"tags_src":              "description.Tags",
	"title":                 "description.StateMachine.Name",
	"tracing_configuration": "description.StateMachine.TracingConfiguration",
	"type":                  "description.StateMachine.Type",
}

func GetStepFunctionsStateMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStepFunctionsStateMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStepFunctionsStateMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getStepFunctionsStateMachineFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StepFunctionsStateMachine =============================

// ==========================  START: StepFunctionsStateMachineExecutionHistories =============================

type StepFunctionsStateMachineExecutionHistories struct {
	Description   aws.StepFunctionsStateMachineExecutionHistoriesDescription `json:"description"`
	Metadata      aws.Metadata                                               `json:"metadata"`
	ResourceJobID int                                                        `json:"resource_job_id"`
	SourceJobID   int                                                        `json:"source_job_id"`
	ResourceType  string                                                     `json:"resource_type"`
	SourceType    string                                                     `json:"source_type"`
	ID            string                                                     `json:"id"`
	ARN           string                                                     `json:"arn"`
	SourceID      string                                                     `json:"source_id"`
}

type StepFunctionsStateMachineExecutionHistoriesHit struct {
	ID      string                                      `json:"_id"`
	Score   float64                                     `json:"_score"`
	Index   string                                      `json:"_index"`
	Type    string                                      `json:"_type"`
	Version int64                                       `json:"_version,omitempty"`
	Source  StepFunctionsStateMachineExecutionHistories `json:"_source"`
	Sort    []interface{}                               `json:"sort"`
}

type StepFunctionsStateMachineExecutionHistoriesHits struct {
	Total essdk.SearchTotal                                `json:"total"`
	Hits  []StepFunctionsStateMachineExecutionHistoriesHit `json:"hits"`
}

type StepFunctionsStateMachineExecutionHistoriesSearchResponse struct {
	PitID string                                          `json:"pit_id"`
	Hits  StepFunctionsStateMachineExecutionHistoriesHits `json:"hits"`
}

type StepFunctionsStateMachineExecutionHistoriesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStepFunctionsStateMachineExecutionHistoriesPaginator(filters []essdk.BoolFilter, limit *int64) (StepFunctionsStateMachineExecutionHistoriesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_stepfunctions_statemachineexecutionhistories", filters, limit)
	if err != nil {
		return StepFunctionsStateMachineExecutionHistoriesPaginator{}, err
	}

	p := StepFunctionsStateMachineExecutionHistoriesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StepFunctionsStateMachineExecutionHistoriesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StepFunctionsStateMachineExecutionHistoriesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StepFunctionsStateMachineExecutionHistoriesPaginator) NextPage(ctx context.Context) ([]StepFunctionsStateMachineExecutionHistories, error) {
	var response StepFunctionsStateMachineExecutionHistoriesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StepFunctionsStateMachineExecutionHistories
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStepFunctionsStateMachineExecutionHistoriesFilters = map[string]string{
	"activity_failed_event_details":                 "description.ExecutionHistory.ActivityFailedEventDetails",
	"activity_schedule_failed_event_details":        "description.ExecutionHistory.ActivityScheduleFailedEventDetails",
	"activity_scheduled_event_details":              "description.ExecutionHistory.ActivityScheduledEventDetails",
	"activity_started_event_details":                "description.ExecutionHistory.ActivityStartedEventDetails",
	"activity_succeeded_event_details":              "description.ExecutionHistory.ActivitySucceededEventDetails",
	"activity_timed_out_event_details":              "description.ExecutionHistory.ActivityTimedOutEventDetails",
	"akas":                                          "description.ARN",
	"execution_aborted_event_details":               "description.ExecutionHistory.ExecutionAbortedEventDetails",
	"execution_arn":                                 "description.ARN",
	"execution_failed_event_details":                "description.ExecutionHistory.ExecutionFailedEventDetails",
	"execution_started_event_details":               "description.ExecutionHistory.ExecutionStartedEventDetails",
	"execution_succeeded_event_details":             "description.ExecutionHistory.ExecutionSucceededEventDetails",
	"execution_timed_out_event_details":             "description.ExecutionHistory.ExecutionTimedOutEventDetails",
	"id":                                            "description.ExecutionHistory.Id",
	"og_account_id":                                 "metadata.SourceID",
	"lambda_function_failed_event_details":          "description.ExecutionHistory.LambdaFunctionFailedEventDetails",
	"lambda_function_schedule_failed_event_details": "description.ExecutionHistory.LambdaFunctionScheduleFailedEventDetails",
	"lambda_function_scheduled_event_details":       "description.ExecutionHistory.LambdaFunctionScheduledEventDetails",
	"lambda_function_start_failed_event_details":    "description.ExecutionHistory.LambdaFunctionStartFailedEventDetails",
	"lambda_function_succeeded_event_details":       "description.ExecutionHistory.LambdaFunctionSucceededEventDetails",
	"lambda_function_timed_out_event_details":       "description.ExecutionHistory.LambdaFunctionTimedOutEventDetails",
	"map_iteration_aborted_event_details":           "description.ExecutionHistory.MapIterationAbortedEventDetails",
	"map_iteration_failed_event_details":            "description.ExecutionHistory.MapIterationFailedEventDetails",
	"map_iteration_started_event_details":           "description.ExecutionHistory.MapIterationStartedEventDetails",
	"map_iteration_succeeded_event_details":         "description.ExecutionHistory.MapIterationSucceededEventDetails",
	"map_state_started_event_details":               "description.ExecutionHistory.MapStateStartedEventDetails",
	"previous_event_id":                             "description.ExecutionHistory.PreviousEventId",
	"state_entered_event_details":                   "description.ExecutionHistory.StateEnteredEventDetails",
	"state_exited_event_details":                    "description.ExecutionHistory.StateExitedEventDetails",
	"task_failed_event_details":                     "description.ExecutionHistory.TaskFailedEventDetails",
	"task_scheduled_event_details":                  "description.ExecutionHistory.TaskScheduledEventDetails",
	"task_start_failed_event_details":               "description.ExecutionHistory.TaskStartFailedEventDetails",
	"task_started_event_details":                    "description.ExecutionHistory.TaskStartedEventDetails",
	"task_submit_failed_event_details":              "description.ExecutionHistory.TaskSubmitFailedEventDetails",
	"task_submitted_event_details":                  "description.ExecutionHistory.TaskSubmittedEventDetails",
	"task_succeeded_event_details":                  "description.ExecutionHistory.TaskSucceededEventDetails",
	"task_timed_out_event_details":                  "description.ExecutionHistory.TaskTimedOutEventDetails",
	"timestamp":                                     "description.ExecutionHistory.Timestamp",
	"title":                                         "description.ExecutionHistory.Id",
	"type":                                          "description.ExecutionHistory.Type",
}

func ListStepFunctionsStateMachineExecutionHistories(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStepFunctionsStateMachineExecutionHistories")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecutionHistories NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecutionHistories NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecutionHistories GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecutionHistories GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecutionHistories GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStepFunctionsStateMachineExecutionHistoriesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStepFunctionsStateMachineExecutionHistoriesFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecutionHistories NewStepFunctionsStateMachineExecutionHistoriesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecutionHistories paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStepFunctionsStateMachineExecutionHistoriesFilters = map[string]string{
	"activity_failed_event_details":                 "description.ExecutionHistory.ActivityFailedEventDetails",
	"activity_schedule_failed_event_details":        "description.ExecutionHistory.ActivityScheduleFailedEventDetails",
	"activity_scheduled_event_details":              "description.ExecutionHistory.ActivityScheduledEventDetails",
	"activity_started_event_details":                "description.ExecutionHistory.ActivityStartedEventDetails",
	"activity_succeeded_event_details":              "description.ExecutionHistory.ActivitySucceededEventDetails",
	"activity_timed_out_event_details":              "description.ExecutionHistory.ActivityTimedOutEventDetails",
	"akas":                                          "description.ARN",
	"execution_aborted_event_details":               "description.ExecutionHistory.ExecutionAbortedEventDetails",
	"execution_arn":                                 "description.ARN",
	"execution_failed_event_details":                "description.ExecutionHistory.ExecutionFailedEventDetails",
	"execution_started_event_details":               "description.ExecutionHistory.ExecutionStartedEventDetails",
	"execution_succeeded_event_details":             "description.ExecutionHistory.ExecutionSucceededEventDetails",
	"execution_timed_out_event_details":             "description.ExecutionHistory.ExecutionTimedOutEventDetails",
	"id":                                            "description.ExecutionHistory.Id",
	"og_account_id":                                 "metadata.SourceID",
	"lambda_function_failed_event_details":          "description.ExecutionHistory.LambdaFunctionFailedEventDetails",
	"lambda_function_schedule_failed_event_details": "description.ExecutionHistory.LambdaFunctionScheduleFailedEventDetails",
	"lambda_function_scheduled_event_details":       "description.ExecutionHistory.LambdaFunctionScheduledEventDetails",
	"lambda_function_start_failed_event_details":    "description.ExecutionHistory.LambdaFunctionStartFailedEventDetails",
	"lambda_function_succeeded_event_details":       "description.ExecutionHistory.LambdaFunctionSucceededEventDetails",
	"lambda_function_timed_out_event_details":       "description.ExecutionHistory.LambdaFunctionTimedOutEventDetails",
	"map_iteration_aborted_event_details":           "description.ExecutionHistory.MapIterationAbortedEventDetails",
	"map_iteration_failed_event_details":            "description.ExecutionHistory.MapIterationFailedEventDetails",
	"map_iteration_started_event_details":           "description.ExecutionHistory.MapIterationStartedEventDetails",
	"map_iteration_succeeded_event_details":         "description.ExecutionHistory.MapIterationSucceededEventDetails",
	"map_state_started_event_details":               "description.ExecutionHistory.MapStateStartedEventDetails",
	"previous_event_id":                             "description.ExecutionHistory.PreviousEventId",
	"state_entered_event_details":                   "description.ExecutionHistory.StateEnteredEventDetails",
	"state_exited_event_details":                    "description.ExecutionHistory.StateExitedEventDetails",
	"task_failed_event_details":                     "description.ExecutionHistory.TaskFailedEventDetails",
	"task_scheduled_event_details":                  "description.ExecutionHistory.TaskScheduledEventDetails",
	"task_start_failed_event_details":               "description.ExecutionHistory.TaskStartFailedEventDetails",
	"task_started_event_details":                    "description.ExecutionHistory.TaskStartedEventDetails",
	"task_submit_failed_event_details":              "description.ExecutionHistory.TaskSubmitFailedEventDetails",
	"task_submitted_event_details":                  "description.ExecutionHistory.TaskSubmittedEventDetails",
	"task_succeeded_event_details":                  "description.ExecutionHistory.TaskSucceededEventDetails",
	"task_timed_out_event_details":                  "description.ExecutionHistory.TaskTimedOutEventDetails",
	"timestamp":                                     "description.ExecutionHistory.Timestamp",
	"title":                                         "description.ExecutionHistory.Id",
	"type":                                          "description.ExecutionHistory.Type",
}

func GetStepFunctionsStateMachineExecutionHistories(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStepFunctionsStateMachineExecutionHistories")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStepFunctionsStateMachineExecutionHistoriesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStepFunctionsStateMachineExecutionHistoriesFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StepFunctionsStateMachineExecutionHistories =============================

// ==========================  START: StepFunctionsStateMachineExecution =============================

type StepFunctionsStateMachineExecution struct {
	Description   aws.StepFunctionsStateMachineExecutionDescription `json:"description"`
	Metadata      aws.Metadata                                      `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type StepFunctionsStateMachineExecutionHit struct {
	ID      string                             `json:"_id"`
	Score   float64                            `json:"_score"`
	Index   string                             `json:"_index"`
	Type    string                             `json:"_type"`
	Version int64                              `json:"_version,omitempty"`
	Source  StepFunctionsStateMachineExecution `json:"_source"`
	Sort    []interface{}                      `json:"sort"`
}

type StepFunctionsStateMachineExecutionHits struct {
	Total essdk.SearchTotal                       `json:"total"`
	Hits  []StepFunctionsStateMachineExecutionHit `json:"hits"`
}

type StepFunctionsStateMachineExecutionSearchResponse struct {
	PitID string                                 `json:"pit_id"`
	Hits  StepFunctionsStateMachineExecutionHits `json:"hits"`
}

type StepFunctionsStateMachineExecutionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStepFunctionsStateMachineExecutionPaginator(filters []essdk.BoolFilter, limit *int64) (StepFunctionsStateMachineExecutionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_stepfunctions_statemachineexecution", filters, limit)
	if err != nil {
		return StepFunctionsStateMachineExecutionPaginator{}, err
	}

	p := StepFunctionsStateMachineExecutionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StepFunctionsStateMachineExecutionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StepFunctionsStateMachineExecutionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StepFunctionsStateMachineExecutionPaginator) NextPage(ctx context.Context) ([]StepFunctionsStateMachineExecution, error) {
	var response StepFunctionsStateMachineExecutionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StepFunctionsStateMachineExecution
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStepFunctionsStateMachineExecutionFilters = map[string]string{
	"execution_arn":     "description.Execution.ExecutionArn",
	"input":             "description.Execution.Input",
	"input_details":     "description.Execution.InputDetails",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.Execution.Name",
	"output":            "description.Execution.Output",
	"output_details":    "description.Execution.OutputDetails",
	"start_date":        "description.Execution.StartDate",
	"state_machine_arn": "description.ExecutionItem.StateMachineArn",
	"status":            "description.ExecutionItem.Status",
	"stop_date":         "description.Execution.StopDate",
	"title":             "description.Execution.Name",
	"trace_header":      "description.Execution.TraceHeader",
}

func ListStepFunctionsStateMachineExecution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStepFunctionsStateMachineExecution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecution NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecution NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecution GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecution GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecution GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStepFunctionsStateMachineExecutionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStepFunctionsStateMachineExecutionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecution NewStepFunctionsStateMachineExecutionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStepFunctionsStateMachineExecution paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStepFunctionsStateMachineExecutionFilters = map[string]string{
	"execution_arn":     "description.ExecutionItem.ExecutionArn",
	"input":             "description.Execution.Input",
	"input_details":     "description.Execution.InputDetails",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.Execution.Name",
	"output":            "description.Execution.Output",
	"output_details":    "description.Execution.OutputDetails",
	"start_date":        "description.Execution.StartDate",
	"state_machine_arn": "description.Execution.StateMachineArn",
	"status":            "description.Execution.Status",
	"stop_date":         "description.Execution.StopDate",
	"title":             "description.Execution.Name",
	"trace_header":      "description.Execution.TraceHeader",
}

func GetStepFunctionsStateMachineExecution(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStepFunctionsStateMachineExecution")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStepFunctionsStateMachineExecutionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStepFunctionsStateMachineExecutionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StepFunctionsStateMachineExecution =============================

// ==========================  START: SimSpaceWeaverSimulation =============================

type SimSpaceWeaverSimulation struct {
	Description   aws.SimSpaceWeaverSimulationDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type SimSpaceWeaverSimulationHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  SimSpaceWeaverSimulation `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type SimSpaceWeaverSimulationHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []SimSpaceWeaverSimulationHit `json:"hits"`
}

type SimSpaceWeaverSimulationSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  SimSpaceWeaverSimulationHits `json:"hits"`
}

type SimSpaceWeaverSimulationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSimSpaceWeaverSimulationPaginator(filters []essdk.BoolFilter, limit *int64) (SimSpaceWeaverSimulationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_simspaceweaver_simulation", filters, limit)
	if err != nil {
		return SimSpaceWeaverSimulationPaginator{}, err
	}

	p := SimSpaceWeaverSimulationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SimSpaceWeaverSimulationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SimSpaceWeaverSimulationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SimSpaceWeaverSimulationPaginator) NextPage(ctx context.Context) ([]SimSpaceWeaverSimulation, error) {
	var response SimSpaceWeaverSimulationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SimSpaceWeaverSimulation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSimSpaceWeaverSimulationFilters = map[string]string{
	"arn":                   "description.Simulation.Arn",
	"creation_time":         "description.Simulation.CreationTime",
	"execution_id":          "description.SimulationItem.ExecutionId",
	"og_account_id":         "metadata.SourceID",
	"live_simulation_state": "description.SimulationItem.LiveSimulationState",
	"logging_configuration": "description.SimulationItem.LoggingConfiguration",
	"maximum_duration":      "description.SimulationItem.MaximumDuration",
	"name":                  "description.Simulation.Name",
	"role_arn":              "description.SimulationItem.RoleArn",
	"schema_error":          "description.SimulationItem.SchemaError",
	"schema_s3_location":    "description.SimulationItem.SchemaS3Location",
	"status":                "description.Simulation.Status",
	"tags":                  "description.Tags",
	"target_status":         "description.Simulation.TargetStatus",
}

func ListSimSpaceWeaverSimulation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSimSpaceWeaverSimulation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSimSpaceWeaverSimulation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSimSpaceWeaverSimulation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSimSpaceWeaverSimulation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSimSpaceWeaverSimulation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSimSpaceWeaverSimulation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSimSpaceWeaverSimulationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSimSpaceWeaverSimulationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSimSpaceWeaverSimulation NewSimSpaceWeaverSimulationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSimSpaceWeaverSimulation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSimSpaceWeaverSimulationFilters = map[string]string{
	"arn":                   "description.Simulation.Arn",
	"creation_time":         "description.Simulation.CreationTime",
	"execution_id":          "description.SimulationItem.ExecutionId",
	"og_account_id":         "metadata.SourceID",
	"live_simulation_state": "description.SimulationItem.LiveSimulationState",
	"logging_configuration": "description.SimulationItem.LoggingConfiguration",
	"maximum_duration":      "description.SimulationItem.MaximumDuration",
	"name":                  "description.Simulation.Name",
	"role_arn":              "description.SimulationItem.RoleArn",
	"schema_error":          "description.SimulationItem.SchemaError",
	"schema_s3_location":    "description.SimulationItem.SchemaS3Location",
	"status":                "description.Simulation.Status",
	"tags":                  "description.Tags",
	"target_status":         "description.Simulation.TargetStatus",
}

func GetSimSpaceWeaverSimulation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSimSpaceWeaverSimulation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSimSpaceWeaverSimulationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSimSpaceWeaverSimulationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SimSpaceWeaverSimulation =============================

// ==========================  START: ACMPCACertificateAuthority =============================

type ACMPCACertificateAuthority struct {
	Description   aws.ACMPCACertificateAuthorityDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type ACMPCACertificateAuthorityHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  ACMPCACertificateAuthority `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type ACMPCACertificateAuthorityHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []ACMPCACertificateAuthorityHit `json:"hits"`
}

type ACMPCACertificateAuthoritySearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  ACMPCACertificateAuthorityHits `json:"hits"`
}

type ACMPCACertificateAuthorityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewACMPCACertificateAuthorityPaginator(filters []essdk.BoolFilter, limit *int64) (ACMPCACertificateAuthorityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_acmpca_certificateauthority", filters, limit)
	if err != nil {
		return ACMPCACertificateAuthorityPaginator{}, err
	}

	p := ACMPCACertificateAuthorityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ACMPCACertificateAuthorityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ACMPCACertificateAuthorityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ACMPCACertificateAuthorityPaginator) NextPage(ctx context.Context) ([]ACMPCACertificateAuthority, error) {
	var response ACMPCACertificateAuthoritySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ACMPCACertificateAuthority
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listACMPCACertificateAuthorityFilters = map[string]string{
	"arn":                                 "description.CertificateAuthority.Arn",
	"certificate_authority_configuration": "description.CertificateAuthority.CertificateAuthorityConfiguration",
	"created_at":                          "description.CertificateAuthority.CreatedAt",
	"failure_reason":                      "description.CertificateAuthority.FailureReason",
	"og_account_id":                       "metadata.SourceID",
	"key_storage_security_standard":       "description.CertificateAuthority.KeyStorageSecurityStandard",
	"last_state_change_at":                "description.CertificateAuthority.LastStateChangeAt",
	"not_after":                           "description.CertificateAuthority.NotAfter",
	"not_before":                          "description.CertificateAuthority.NotBefore",
	"owner_account":                       "description.CertificateAuthority.OwnerAccount",
	"restorable_until":                    "description.CertificateAuthority.RestorableUntil",
	"revocation_configuration":            "description.CertificateAuthority.RevocationConfiguration",
	"serial":                              "description.CertificateAuthority.Serial",
	"status":                              "description.CertificateAuthority.Status",
	"tags":                                "description.Tags",
	"tags_src":                            "description.Tags",
	"type":                                "description.CertificateAuthority.Type",
	"usage_mode":                          "description.CertificateAuthority.UsageMode",
}

func ListACMPCACertificateAuthority(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListACMPCACertificateAuthority")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListACMPCACertificateAuthority NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListACMPCACertificateAuthority NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListACMPCACertificateAuthority GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListACMPCACertificateAuthority GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListACMPCACertificateAuthority GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewACMPCACertificateAuthorityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listACMPCACertificateAuthorityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListACMPCACertificateAuthority NewACMPCACertificateAuthorityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListACMPCACertificateAuthority paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getACMPCACertificateAuthorityFilters = map[string]string{
	"arn":                                 "description.CertificateAuthority.Arn",
	"certificate_authority_configuration": "description.CertificateAuthority.CertificateAuthorityConfiguration",
	"created_at":                          "description.CertificateAuthority.CreatedAt",
	"failure_reason":                      "description.CertificateAuthority.FailureReason",
	"og_account_id":                       "metadata.SourceID",
	"key_storage_security_standard":       "description.CertificateAuthority.KeyStorageSecurityStandard",
	"last_state_change_at":                "description.CertificateAuthority.LastStateChangeAt",
	"not_after":                           "description.CertificateAuthority.NotAfter",
	"not_before":                          "description.CertificateAuthority.NotBefore",
	"owner_account":                       "description.CertificateAuthority.OwnerAccount",
	"restorable_until":                    "description.CertificateAuthority.RestorableUntil",
	"revocation_configuration":            "description.CertificateAuthority.RevocationConfiguration",
	"serial":                              "description.CertificateAuthority.Serial",
	"status":                              "description.CertificateAuthority.Status",
	"tags":                                "description.Tags",
	"tags_src":                            "description.Tags",
	"type":                                "description.CertificateAuthority.Type",
	"usage_mode":                          "description.CertificateAuthority.UsageMode",
}

func GetACMPCACertificateAuthority(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetACMPCACertificateAuthority")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewACMPCACertificateAuthorityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getACMPCACertificateAuthorityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ACMPCACertificateAuthority =============================

// ==========================  START: ShieldProtectionGroup =============================

type ShieldProtectionGroup struct {
	Description   aws.ShieldProtectionGroupDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ShieldProtectionGroupHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ShieldProtectionGroup `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ShieldProtectionGroupHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ShieldProtectionGroupHit `json:"hits"`
}

type ShieldProtectionGroupSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ShieldProtectionGroupHits `json:"hits"`
}

type ShieldProtectionGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewShieldProtectionGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ShieldProtectionGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_shield_protectiongroup", filters, limit)
	if err != nil {
		return ShieldProtectionGroupPaginator{}, err
	}

	p := ShieldProtectionGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ShieldProtectionGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ShieldProtectionGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ShieldProtectionGroupPaginator) NextPage(ctx context.Context) ([]ShieldProtectionGroup, error) {
	var response ShieldProtectionGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ShieldProtectionGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listShieldProtectionGroupFilters = map[string]string{
	"arn":                 "description.ProtectionGroup.ProtectionGroupArn",
	"og_account_id":       "metadata.SourceID",
	"protection_group_id": "description.ProtectionGroup.ProtectionGroupId",
	"title":               "description.ProtectionGroup.ProtectionGroupId",
}

func ListShieldProtectionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListShieldProtectionGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListShieldProtectionGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListShieldProtectionGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListShieldProtectionGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListShieldProtectionGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListShieldProtectionGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewShieldProtectionGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listShieldProtectionGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListShieldProtectionGroup NewShieldProtectionGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListShieldProtectionGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getShieldProtectionGroupFilters = map[string]string{
	"arn":                 "description.ProtectionGroup.ProtectionGroupArn",
	"og_account_id":       "metadata.SourceID",
	"protection_group_id": "description.ProtectionGroup.ProtectionGroupId",
	"title":               "description.ProtectionGroup.ProtectionGroupId",
}

func GetShieldProtectionGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetShieldProtectionGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewShieldProtectionGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getShieldProtectionGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ShieldProtectionGroup =============================

// ==========================  START: StorageGatewayStorageGateway =============================

type StorageGatewayStorageGateway struct {
	Description   aws.StorageGatewayStorageGatewayDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type StorageGatewayStorageGatewayHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  StorageGatewayStorageGateway `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type StorageGatewayStorageGatewayHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []StorageGatewayStorageGatewayHit `json:"hits"`
}

type StorageGatewayStorageGatewaySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  StorageGatewayStorageGatewayHits `json:"hits"`
}

type StorageGatewayStorageGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageGatewayStorageGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (StorageGatewayStorageGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_storagegateway_storagegateway", filters, limit)
	if err != nil {
		return StorageGatewayStorageGatewayPaginator{}, err
	}

	p := StorageGatewayStorageGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageGatewayStorageGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageGatewayStorageGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageGatewayStorageGatewayPaginator) NextPage(ctx context.Context) ([]StorageGatewayStorageGateway, error) {
	var response StorageGatewayStorageGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageGatewayStorageGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageGatewayStorageGatewayFilters = map[string]string{
	"arn":           "description.StorageGateway.GatewayARN",
	"gateway_id":    "description.StorageGateway.GatewayId",
	"og_account_id": "metadata.SourceID",
	"name":          "description.StorageGateway.GatewayName",
	"title":         "description.StorageGateway.GatewayName",
}

func ListStorageGatewayStorageGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageGatewayStorageGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageGatewayStorageGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageGatewayStorageGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageGatewayStorageGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageGatewayStorageGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageGatewayStorageGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageGatewayStorageGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageGatewayStorageGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageGatewayStorageGateway NewStorageGatewayStorageGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageGatewayStorageGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageGatewayStorageGatewayFilters = map[string]string{
	"arn":           "description.StorageGateway.GatewayARN",
	"gateway_id":    "description.StorageGateway.GatewayId",
	"og_account_id": "metadata.SourceID",
	"name":          "description.StorageGateway.GatewayName",
	"title":         "description.StorageGateway.GatewayName",
}

func GetStorageGatewayStorageGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageGatewayStorageGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageGatewayStorageGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageGatewayStorageGatewayFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageGatewayStorageGateway =============================

// ==========================  START: ImageBuilderImage =============================

type ImageBuilderImage struct {
	Description   aws.ImageBuilderImageDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ImageBuilderImageHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ImageBuilderImage `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ImageBuilderImageHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ImageBuilderImageHit `json:"hits"`
}

type ImageBuilderImageSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ImageBuilderImageHits `json:"hits"`
}

type ImageBuilderImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewImageBuilderImagePaginator(filters []essdk.BoolFilter, limit *int64) (ImageBuilderImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_imagebuilder_image", filters, limit)
	if err != nil {
		return ImageBuilderImagePaginator{}, err
	}

	p := ImageBuilderImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ImageBuilderImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ImageBuilderImagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ImageBuilderImagePaginator) NextPage(ctx context.Context) ([]ImageBuilderImage, error) {
	var response ImageBuilderImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ImageBuilderImage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listImageBuilderImageFilters = map[string]string{
	"arn":           "description.Image.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Image.Name",
	"tags":          "description.Image.Tags",
	"title":         "description.Image.Name",
}

func ListImageBuilderImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListImageBuilderImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListImageBuilderImage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListImageBuilderImage NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListImageBuilderImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListImageBuilderImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListImageBuilderImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewImageBuilderImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listImageBuilderImageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListImageBuilderImage NewImageBuilderImagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListImageBuilderImage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getImageBuilderImageFilters = map[string]string{
	"arn":           "description.Image.Arn",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Image.Name",
	"tags":          "description.Image.Tags",
	"title":         "description.Image.Name",
}

func GetImageBuilderImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetImageBuilderImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewImageBuilderImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getImageBuilderImageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ImageBuilderImage =============================

// ==========================  START: AccountAlternateContact =============================

type AccountAlternateContact struct {
	Description   aws.AccountAlternateContactDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type AccountAlternateContactHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  AccountAlternateContact `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type AccountAlternateContactHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []AccountAlternateContactHit `json:"hits"`
}

type AccountAlternateContactSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  AccountAlternateContactHits `json:"hits"`
}

type AccountAlternateContactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountAlternateContactPaginator(filters []essdk.BoolFilter, limit *int64) (AccountAlternateContactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_account_alternatecontact", filters, limit)
	if err != nil {
		return AccountAlternateContactPaginator{}, err
	}

	p := AccountAlternateContactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountAlternateContactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountAlternateContactPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountAlternateContactPaginator) NextPage(ctx context.Context) ([]AccountAlternateContact, error) {
	var response AccountAlternateContactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccountAlternateContact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountAlternateContactFilters = map[string]string{
	"contact_title":     "description.AlternateContact.Title",
	"contact_type":      "description.AlternateContact.AlternateContactType",
	"email_address":     "description.AlternateContact.EmailAddress",
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.LinkedAccountID",
	"name":              "description.AlternateContact.Name",
	"phone_number":      "description.AlternateContact.PhoneNumber",
	"title":             "description.AlternateContact.Name",
}

func ListAccountAlternateContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccountAlternateContact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountAlternateContact NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountAlternateContact NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountAlternateContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountAlternateContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountAlternateContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountAlternateContactPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountAlternateContactFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountAlternateContact NewAccountAlternateContactPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccountAlternateContact paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountAlternateContactFilters = map[string]string{
	"contact_title":     "description.AlternateContact.Title",
	"contact_type":      "description.AlternateContact.AlternateContactType",
	"email_address":     "description.AlternateContact.EmailAddress",
	"og_account_id":     "metadata.SourceID",
	"linked_account_id": "description.LinkedAccountID",
	"name":              "description.AlternateContact.Name",
	"phone_number":      "description.AlternateContact.PhoneNumber",
	"title":             "description.AlternateContact.Name",
}

func GetAccountAlternateContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccountAlternateContact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountAlternateContactPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountAlternateContactFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccountAlternateContact =============================

// ==========================  START: AccountContact =============================

type AccountContact struct {
	Description   aws.AccountContactDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type AccountContactHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AccountContact `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AccountContactHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AccountContactHit `json:"hits"`
}

type AccountContactSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AccountContactHits `json:"hits"`
}

type AccountContactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountContactPaginator(filters []essdk.BoolFilter, limit *int64) (AccountContactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_account_contact", filters, limit)
	if err != nil {
		return AccountContactPaginator{}, err
	}

	p := AccountContactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountContactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountContactPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountContactPaginator) NextPage(ctx context.Context) ([]AccountContact, error) {
	var response AccountContactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccountContact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountContactFilters = map[string]string{
	"address_line_1":     "description.AlternateContact.AddressLine1",
	"address_line_2":     "description.AlternateContact.AddressLine2",
	"address_line_3":     "description.AlternateContact.AddressLine3",
	"city":               "description.AlternateContact.City",
	"company_name":       "description.AlternateContact.CompanyName",
	"country_code":       "description.AlternateContact.CountryCode",
	"district_or_county": "description.AlternateContact.DistrictOrCounty",
	"full_name":          "description.AlternateContact.FullName",
	"og_account_id":      "metadata.SourceID",
	"linked_account_id":  "description.LinkedAccountID",
	"phone_number":       "description.AlternateContact.PhoneNumber",
	"postal_code":        "description.AlternateContact.PostalCode",
	"state_or_region":    "description.AlternateContact.StateOrRegion",
	"title":              "description.AlternateContact.FullName",
	"website_url":        "description.AlternateContact.WebsiteUrl",
}

func ListAccountContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccountContact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountContact NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountContact NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountContactPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountContactFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountContact NewAccountContactPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccountContact paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountContactFilters = map[string]string{
	"address_line_1":     "description.AlternateContact.AddressLine1",
	"address_line_2":     "description.AlternateContact.AddressLine2",
	"address_line_3":     "description.AlternateContact.AddressLine3",
	"city":               "description.AlternateContact.City",
	"company_name":       "description.AlternateContact.CompanyName",
	"country_code":       "description.AlternateContact.CountryCode",
	"district_or_county": "description.AlternateContact.DistrictOrCounty",
	"full_name":          "description.AlternateContact.FullName",
	"og_account_id":      "metadata.SourceID",
	"linked_account_id":  "description.LinkedAccountID",
	"phone_number":       "description.AlternateContact.PhoneNumber",
	"postal_code":        "description.AlternateContact.PostalCode",
	"state_or_region":    "description.AlternateContact.StateOrRegion",
	"title":              "description.AlternateContact.FullName",
	"website_url":        "description.AlternateContact.WebsiteUrl",
}

func GetAccountContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccountContact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountContactPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountContactFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccountContact =============================

// ==========================  START: AmplifyApp =============================

type AmplifyApp struct {
	Description   aws.AmplifyAppDescription `json:"description"`
	Metadata      aws.Metadata              `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type AmplifyAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AmplifyApp    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AmplifyAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AmplifyAppHit   `json:"hits"`
}

type AmplifyAppSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  AmplifyAppHits `json:"hits"`
}

type AmplifyAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAmplifyAppPaginator(filters []essdk.BoolFilter, limit *int64) (AmplifyAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_amplify_app", filters, limit)
	if err != nil {
		return AmplifyAppPaginator{}, err
	}

	p := AmplifyAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AmplifyAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AmplifyAppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AmplifyAppPaginator) NextPage(ctx context.Context) ([]AmplifyApp, error) {
	var response AmplifyAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AmplifyApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAmplifyAppFilters = map[string]string{
	"app_id":                        "description.App.AppId",
	"arn":                           "description.App.AppArn",
	"auto_branch_creation_config":   "description.App.AutoBranchCreationConfig",
	"auto_branch_creation_patterns": "description.App.AutoBranchCreationPatterns",
	"basic_auth_credentials":        "description.App.BasicAuthCredentials",
	"create_time":                   "description.App.CreateTime",
	"custom_headers":                "description.App.CustomHeaders",
	"custom_rules":                  "description.App.CustomRules",
	"default_domain":                "description.App.DefaultDomain",
	"description":                   "description.App.Description",
	"enable_auto_branch_creation":   "description.App.EnableAutoBranchCreation",
	"enable_basic_auth":             "description.App.EnableBasicAuth",
	"enable_branch_auto_build":      "description.App.EnableBranchAutoBuild",
	"enable_branch_auto_deletion":   "description.App.EnableBranchAutoDeletion",
	"environment_variables":         "description.App.EnvironmentVariables",
	"iam_service_role_arn":          "description.App.IamServiceRoleArn",
	"og_account_id":                 "metadata.SourceID",
	"name":                          "description.App.Name",
	"platform":                      "description.App.Platform",
	"production_branch":             "description.App.ProductionBranch",
	"repository":                    "description.App.Repository",
	"repository_clone_method":       "description.App.RepositoryCloneMethod",
	"tags":                          "description.App.Tags",
	"title":                         "description.App.Name",
	"update_time":                   "description.App.UpdateTime",
}

func ListAmplifyApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAmplifyApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAmplifyApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAmplifyApp NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAmplifyApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAmplifyApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAmplifyApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAmplifyAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAmplifyAppFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAmplifyApp NewAmplifyAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAmplifyApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAmplifyAppFilters = map[string]string{
	"app_id":                        "description.App.AppId",
	"arn":                           "description.App.AppArn",
	"auto_branch_creation_config":   "description.App.AutoBranchCreationConfig",
	"auto_branch_creation_patterns": "description.App.AutoBranchCreationPatterns",
	"basic_auth_credentials":        "description.App.BasicAuthCredentials",
	"create_time":                   "description.App.CreateTime",
	"custom_headers":                "description.App.CustomHeaders",
	"custom_rules":                  "description.App.CustomRules",
	"default_domain":                "description.App.DefaultDomain",
	"description":                   "description.App.Description",
	"enable_auto_branch_creation":   "description.App.EnableAutoBranchCreation",
	"enable_basic_auth":             "description.App.EnableBasicAuth",
	"enable_branch_auto_build":      "description.App.EnableBranchAutoBuild",
	"enable_branch_auto_deletion":   "description.App.EnableBranchAutoDeletion",
	"environment_variables":         "description.App.EnvironmentVariables",
	"iam_service_role_arn":          "description.App.IamServiceRoleArn",
	"og_account_id":                 "metadata.SourceID",
	"name":                          "description.App.Name",
	"platform":                      "description.App.Platform",
	"production_branch":             "description.App.ProductionBranch",
	"repository":                    "description.App.Repository",
	"repository_clone_method":       "description.App.RepositoryCloneMethod",
	"tags":                          "description.App.Tags",
	"title":                         "description.App.Name",
	"update_time":                   "description.App.UpdateTime",
}

func GetAmplifyApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAmplifyApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAmplifyAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAmplifyAppFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AmplifyApp =============================

// ==========================  START: AppConfigApplication =============================

type AppConfigApplication struct {
	Description   aws.AppConfigApplicationDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AppConfigApplicationHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AppConfigApplication `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AppConfigApplicationHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AppConfigApplicationHit `json:"hits"`
}

type AppConfigApplicationSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AppConfigApplicationHits `json:"hits"`
}

type AppConfigApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppConfigApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (AppConfigApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_appconfig_application", filters, limit)
	if err != nil {
		return AppConfigApplicationPaginator{}, err
	}

	p := AppConfigApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppConfigApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppConfigApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppConfigApplicationPaginator) NextPage(ctx context.Context) ([]AppConfigApplication, error) {
	var response AppConfigApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppConfigApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppConfigApplicationFilters = map[string]string{
	"description":   "description.Application.Description",
	"id":            "description.Application.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Application.Name",
	"tags":          "description.Tags",
	"title":         "description.Application.Name",
}

func ListAppConfigApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppConfigApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfigApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfigApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfigApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfigApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfigApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppConfigApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppConfigApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfigApplication NewAppConfigApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppConfigApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppConfigApplicationFilters = map[string]string{
	"description":   "description.Application.Description",
	"id":            "description.Application.Id",
	"og_account_id": "metadata.SourceID",
	"name":          "description.Application.Name",
	"tags":          "description.Tags",
	"title":         "description.Application.Name",
}

func GetAppConfigApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppConfigApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppConfigApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppConfigApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppConfigApplication =============================

// ==========================  START: AuditManagerAssessment =============================

type AuditManagerAssessment struct {
	Description   aws.AuditManagerAssessmentDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type AuditManagerAssessmentHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  AuditManagerAssessment `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type AuditManagerAssessmentHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []AuditManagerAssessmentHit `json:"hits"`
}

type AuditManagerAssessmentSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  AuditManagerAssessmentHits `json:"hits"`
}

type AuditManagerAssessmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerAssessmentPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerAssessmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_assessment", filters, limit)
	if err != nil {
		return AuditManagerAssessmentPaginator{}, err
	}

	p := AuditManagerAssessmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerAssessmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerAssessmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AuditManagerAssessmentPaginator) NextPage(ctx context.Context) ([]AuditManagerAssessment, error) {
	var response AuditManagerAssessmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerAssessment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerAssessmentFilters = map[string]string{
	"arn":                                "arn",
	"assessment_report_destination":      "description.Assessment.Metadata.AssessmentReportsDestination.Destination",
	"assessment_report_destination_type": "description.Assessment.Metadata.AssessmentReportsDestination.DestinationType",
	"aws_account":                        "description.Assessment.AwsAccount",
	"compliance_type":                    "description.Assessment.Metadata.ComplianceType",
	"creation_time":                      "description.Assessment.Metadata.CreationTime",
	"delegations":                        "description.Assessment.Metadata.Delegations",
	"description":                        "description.Assessment.Metadata.Description",
	"framework":                          "description.Assessment.Framework",
	"id":                                 "description.Assessment.Metadata.Id",
	"og_account_id":                      "metadata.SourceID",
	"last_updated":                       "description.Assessment.Metadata.LastUpdated",
	"name":                               "description.Assessment.Metadata.Name",
	"roles":                              "description.Assessment.Metadata.Roles",
	"scope":                              "description.Assessment.Metadata.Scope",
	"status":                             "description.Assessment.Metadata.Status",
	"tags":                               "description.Assessment.Tags",
	"title":                              "description.Assessment.Metadata.Name",
}

func ListAuditManagerAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerAssessment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerAssessment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerAssessment NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerAssessment GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerAssessment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerAssessment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAuditManagerAssessmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAuditManagerAssessmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerAssessment NewAuditManagerAssessmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAuditManagerAssessment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAuditManagerAssessmentFilters = map[string]string{
	"arn":                                "arn",
	"assessment_id":                      "description.Assessment.Metadata.Id",
	"assessment_report_destination":      "description.Assessment.Metadata.AssessmentReportsDestination.Destination",
	"assessment_report_destination_type": "description.Assessment.Metadata.AssessmentReportsDestination.DestinationType",
	"aws_account":                        "description.Assessment.AwsAccount",
	"compliance_type":                    "description.Assessment.Metadata.ComplianceType",
	"creation_time":                      "description.Assessment.Metadata.CreationTime",
	"delegations":                        "description.Assessment.Metadata.Delegations",
	"description":                        "description.Assessment.Metadata.Description",
	"framework":                          "description.Assessment.Framework",
	"id":                                 "description.Assessment.Metadata.Id",
	"og_account_id":                      "metadata.SourceID",
	"last_updated":                       "description.Assessment.Metadata.LastUpdated",
	"name":                               "description.Assessment.Metadata.Name",
	"roles":                              "description.Assessment.Metadata.Roles",
	"scope":                              "description.Assessment.Metadata.Scope",
	"status":                             "description.Assessment.Metadata.Status",
	"tags":                               "description.Assessment.Tags",
	"title":                              "description.Assessment.Metadata.Name",
}

func GetAuditManagerAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerAssessment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAuditManagerAssessmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAuditManagerAssessmentFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AuditManagerAssessment =============================

// ==========================  START: AuditManagerControl =============================

type AuditManagerControl struct {
	Description   aws.AuditManagerControlDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type AuditManagerControlHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  AuditManagerControl `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type AuditManagerControlHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []AuditManagerControlHit `json:"hits"`
}

type AuditManagerControlSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  AuditManagerControlHits `json:"hits"`
}

type AuditManagerControlPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerControlPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerControlPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_control", filters, limit)
	if err != nil {
		return AuditManagerControlPaginator{}, err
	}

	p := AuditManagerControlPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerControlPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerControlPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AuditManagerControlPaginator) NextPage(ctx context.Context) ([]AuditManagerControl, error) {
	var response AuditManagerControlSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerControl
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerControlFilters = map[string]string{
	"action_plan_instructions": "description.Control.ActionPlanInstructions",
	"action_plan_title":        "description.Control.ActionPlanTitle",
	"arn":                      "description.Control.Arn",
	"control_mapping_sources":  "description.Control.ControlMappingSources",
	"control_sources":          "description.Control.ControlSources",
	"created_at":               "description.Control.CreatedAt",
	"created_by":               "description.Control.CreatedBy",
	"description":              "description.Control.Description",
	"id":                       "description.Control.Id",
	"og_account_id":            "metadata.SourceID",
	"last_updated_at":          "description.Control.LastUpdatedAt",
	"last_updated_by":          "description.Control.LastUpdatedBy",
	"name":                     "description.Control.Name",
	"tags":                     "description.Control.Tags",
	"testing_information":      "description.Control.TestingInformation",
	"title":                    "description.Control.Name",
	"type":                     "description.Control.Type",
}

func ListAuditManagerControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerControl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerControl NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerControl NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerControl GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAuditManagerControlPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAuditManagerControlFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerControl NewAuditManagerControlPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAuditManagerControl paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAuditManagerControlFilters = map[string]string{
	"action_plan_instructions": "description.Control.ActionPlanInstructions",
	"action_plan_title":        "description.Control.ActionPlanTitle",
	"arn":                      "description.Control.Arn",
	"control_id":               "description.Control.Id",
	"control_mapping_sources":  "description.Control.ControlMappingSources",
	"control_sources":          "description.Control.ControlSources",
	"created_at":               "description.Control.CreatedAt",
	"created_by":               "description.Control.CreatedBy",
	"description":              "description.Control.Description",
	"id":                       "description.Control.Id",
	"og_account_id":            "metadata.SourceID",
	"last_updated_at":          "description.Control.LastUpdatedAt",
	"last_updated_by":          "description.Control.LastUpdatedBy",
	"name":                     "description.Control.Name",
	"tags":                     "description.Control.Tags",
	"testing_information":      "description.Control.TestingInformation",
	"title":                    "description.Control.Name",
	"type":                     "description.Control.Type",
}

func GetAuditManagerControl(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerControl")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAuditManagerControlPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAuditManagerControlFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AuditManagerControl =============================

// ==========================  START: AuditManagerEvidence =============================

type AuditManagerEvidence struct {
	Description   aws.AuditManagerEvidenceDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AuditManagerEvidenceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AuditManagerEvidence `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AuditManagerEvidenceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AuditManagerEvidenceHit `json:"hits"`
}

type AuditManagerEvidenceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AuditManagerEvidenceHits `json:"hits"`
}

type AuditManagerEvidencePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerEvidencePaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerEvidencePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_evidence", filters, limit)
	if err != nil {
		return AuditManagerEvidencePaginator{}, err
	}

	p := AuditManagerEvidencePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerEvidencePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerEvidencePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AuditManagerEvidencePaginator) NextPage(ctx context.Context) ([]AuditManagerEvidence, error) {
	var response AuditManagerEvidenceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerEvidence
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerEvidenceFilters = map[string]string{
	"assessment_id":               "description.AssessmentID",
	"assessment_report_selection": "description.Evidence.AssessmentReportSelection",
	"attributes":                  "description.Evidence.Attributes",
	"aws_account_id":              "description.Evidence.AwsAccountId",
	"aws_organization":            "description.Evidence.AwsOrganization",
	"compliance_check":            "description.Evidence.ComplianceCheck",
	"control_set_id":              "description.ControlSetID",
	"data_source":                 "description.Evidence.DataSource",
	"event_name":                  "description.Evidence.EventName",
	"event_source":                "description.Evidence.EventSource",
	"evidence_aws_account_id":     "description.Evidence.EvidenceAwsAccountId",
	"evidence_by_type":            "description.Evidence.EvidenceByType",
	"evidence_folder_id":          "description.Evidence.EvidenceFolderId",
	"iam_id":                      "description.Evidence.IamId",
	"id":                          "description.Evidence.Id",
	"og_account_id":               "metadata.SourceID",
	"resources_included":          "description.Evidence.ResourcesIncluded",
	"time":                        "description.Evidence.Time",
	"title":                       "description.Evidence.Id",
}

func ListAuditManagerEvidence(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerEvidence")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidence NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidence NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidence GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidence GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidence GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAuditManagerEvidencePaginator(essdk.BuildFilter(ctx, d.QueryContext, listAuditManagerEvidenceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidence NewAuditManagerEvidencePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAuditManagerEvidence paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAuditManagerEvidenceFilters = map[string]string{
	"assessment_id":               "description.AssessmentID",
	"assessment_report_selection": "description.Evidence.AssessmentReportSelection",
	"attributes":                  "description.Evidence.Attributes",
	"aws_account_id":              "description.Evidence.AwsAccountId",
	"aws_organization":            "description.Evidence.AwsOrganization",
	"compliance_check":            "description.Evidence.ComplianceCheck",
	"control_set_id":              "description.ControlSetID",
	"data_source":                 "description.Evidence.DataSource",
	"event_name":                  "description.Evidence.EventName",
	"event_source":                "description.Evidence.EventSource",
	"evidence_aws_account_id":     "description.Evidence.EvidenceAwsAccountId",
	"evidence_by_type":            "description.Evidence.EvidenceByType",
	"evidence_folder_id":          "description.Evidence.EvidenceFolderId",
	"iam_id":                      "description.Evidence.IamId",
	"id":                          "description.Evidence.Id",
	"og_account_id":               "metadata.SourceID",
	"resources_included":          "description.Evidence.ResourcesIncluded",
	"time":                        "description.Evidence.Time",
	"title":                       "description.Evidence.Id",
}

func GetAuditManagerEvidence(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerEvidence")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAuditManagerEvidencePaginator(essdk.BuildFilter(ctx, d.QueryContext, getAuditManagerEvidenceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AuditManagerEvidence =============================

// ==========================  START: AuditManagerEvidenceFolder =============================

type AuditManagerEvidenceFolder struct {
	Description   aws.AuditManagerEvidenceFolderDescription `json:"description"`
	Metadata      aws.Metadata                              `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type AuditManagerEvidenceFolderHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  AuditManagerEvidenceFolder `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type AuditManagerEvidenceFolderHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []AuditManagerEvidenceFolderHit `json:"hits"`
}

type AuditManagerEvidenceFolderSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  AuditManagerEvidenceFolderHits `json:"hits"`
}

type AuditManagerEvidenceFolderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerEvidenceFolderPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerEvidenceFolderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_evidencefolder", filters, limit)
	if err != nil {
		return AuditManagerEvidenceFolderPaginator{}, err
	}

	p := AuditManagerEvidenceFolderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerEvidenceFolderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerEvidenceFolderPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AuditManagerEvidenceFolderPaginator) NextPage(ctx context.Context) ([]AuditManagerEvidenceFolder, error) {
	var response AuditManagerEvidenceFolderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerEvidenceFolder
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerEvidenceFolderFilters = map[string]string{
	"assessment_id":                     "description.AssessmentID",
	"assessment_report_selection_count": "description.EvidenceFolder.AssessmentReportSelectionCount",
	"author":                            "description.EvidenceFolder.Author",
	"control_id":                        "description.EvidenceFolder.ControlId",
	"control_name":                      "description.EvidenceFolder.ControlName",
	"control_set_id":                    "description.EvidenceFolder.ControlSetId",
	"data_source":                       "description.EvidenceFolder.DataSource",
	"date":                              "description.EvidenceFolder.Date",
	"evidence_aws_service_source_count": "description.EvidenceFolder.EvidenceAwsServiceSourceCount",
	"evidence_by_type_compliance_check_count":        "description.EvidenceFolder.EvidenceByTypeComplianceCheckCount",
	"evidence_by_type_compliance_check_issues_count": "description.EvidenceFolder.EvidenceByTypeComplianceCheckIssuesCount",
	"evidence_by_type_configuration_data_count":      "description.EvidenceFolder.EvidenceByTypeConfigurationDataCount",
	"evidence_by_type_manual_count":                  "description.EvidenceFolder.EvidenceByTypeManualCount",
	"evidence_by_type_user_activity_count":           "description.EvidenceFolder.EvidenceByTypeUserActivityCount",
	"evidence_resources_included_count":              "description.EvidenceFolder.EvidenceResourcesIncludedCount",
	"id":                                             "description.EvidenceFolder.Id",
	"og_account_id":                                  "metadata.SourceID",
	"name":                                           "description.EvidenceFolder.Name",
	"title":                                          "description.EvidenceFolder.Name",
	"total_evidence":                                 "description.EvidenceFolder.TotalEvidence",
}

func ListAuditManagerEvidenceFolder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerEvidenceFolder")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidenceFolder NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidenceFolder NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidenceFolder GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidenceFolder GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidenceFolder GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAuditManagerEvidenceFolderPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAuditManagerEvidenceFolderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerEvidenceFolder NewAuditManagerEvidenceFolderPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAuditManagerEvidenceFolder paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAuditManagerEvidenceFolderFilters = map[string]string{
	"assessment_id":                     "description.AssessmentID",
	"assessment_report_selection_count": "description.EvidenceFolder.AssessmentReportSelectionCount",
	"author":                            "description.EvidenceFolder.Author",
	"control_id":                        "description.EvidenceFolder.ControlId",
	"control_name":                      "description.EvidenceFolder.ControlName",
	"control_set_id":                    "description.ControlSetID",
	"data_source":                       "description.EvidenceFolder.DataSource",
	"date":                              "description.EvidenceFolder.Date",
	"evidence_aws_service_source_count": "description.EvidenceFolder.EvidenceAwsServiceSourceCount",
	"evidence_by_type_compliance_check_count":        "description.EvidenceFolder.EvidenceByTypeComplianceCheckCount",
	"evidence_by_type_compliance_check_issues_count": "description.EvidenceFolder.EvidenceByTypeComplianceCheckIssuesCount",
	"evidence_by_type_configuration_data_count":      "description.EvidenceFolder.EvidenceByTypeConfigurationDataCount",
	"evidence_by_type_manual_count":                  "description.EvidenceFolder.EvidenceByTypeManualCount",
	"evidence_by_type_user_activity_count":           "description.EvidenceFolder.EvidenceByTypeUserActivityCount",
	"evidence_resources_included_count":              "description.EvidenceFolder.EvidenceResourcesIncludedCount",
	"id":                                             "description.EvidenceFolder.Id",
	"og_account_id":                                  "metadata.SourceID",
	"name":                                           "description.EvidenceFolder.Name",
	"title":                                          "description.EvidenceFolder.Name",
	"total_evidence":                                 "description.EvidenceFolder.TotalEvidence",
}

func GetAuditManagerEvidenceFolder(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerEvidenceFolder")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAuditManagerEvidenceFolderPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAuditManagerEvidenceFolderFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AuditManagerEvidenceFolder =============================

// ==========================  START: AuditManagerFramework =============================

type AuditManagerFramework struct {
	Description   aws.AuditManagerFrameworkDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type AuditManagerFrameworkHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AuditManagerFramework `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AuditManagerFrameworkHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AuditManagerFrameworkHit `json:"hits"`
}

type AuditManagerFrameworkSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AuditManagerFrameworkHits `json:"hits"`
}

type AuditManagerFrameworkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAuditManagerFrameworkPaginator(filters []essdk.BoolFilter, limit *int64) (AuditManagerFrameworkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_auditmanager_framework", filters, limit)
	if err != nil {
		return AuditManagerFrameworkPaginator{}, err
	}

	p := AuditManagerFrameworkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AuditManagerFrameworkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AuditManagerFrameworkPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AuditManagerFrameworkPaginator) NextPage(ctx context.Context) ([]AuditManagerFramework, error) {
	var response AuditManagerFrameworkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AuditManagerFramework
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAuditManagerFrameworkFilters = map[string]string{
	"arn":                "description.Framework.Arn",
	"compliance_type":    "description.Framework.ComplianceType",
	"control_sets":       "description.Framework.ControlSets",
	"control_sets_count": "description.Framework.ControlSources",
	"control_sources":    "description.Framework.ControlSources",
	"controls_count":     "description.Framework.ControlSources",
	"created_at":         "description.Framework.CreatedAt",
	"created_by":         "description.Framework.CreatedBy",
	"description":        "description.Framework.Description",
	"id":                 "description.Framework.Id",
	"og_account_id":      "metadata.SourceID",
	"last_updated_at":    "description.Framework.LastUpdatedAt",
	"last_updated_by":    "description.Framework.LastUpdatedBy",
	"logo":               "description.Framework.Logo",
	"name":               "description.Framework.Name",
	"tags":               "description.Framework.Tags",
	"title":              "description.Framework.Name",
	"type":               "description.Framework.Type",
}

func ListAuditManagerFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAuditManagerFramework")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerFramework NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerFramework NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerFramework GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerFramework GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerFramework GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAuditManagerFrameworkPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAuditManagerFrameworkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAuditManagerFramework NewAuditManagerFrameworkPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAuditManagerFramework paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAuditManagerFrameworkFilters = map[string]string{
	"arn":                "description.Framework.Arn",
	"compliance_type":    "description.Framework.ComplianceType",
	"control_sets":       "description.Framework.ControlSets",
	"control_sets_count": "description.Framework.ControlSources",
	"control_sources":    "description.Framework.ControlSources",
	"controls_count":     "description.Framework.ControlSources",
	"created_at":         "description.Framework.CreatedAt",
	"created_by":         "description.Framework.CreatedBy",
	"description":        "description.Framework.Description",
	"id":                 "description.Framework.Id",
	"og_account_id":      "metadata.SourceID",
	"last_updated_at":    "description.Framework.LastUpdatedAt",
	"last_updated_by":    "description.Framework.LastUpdatedBy",
	"logo":               "description.Framework.Logo",
	"name":               "description.Framework.Name",
	"region":             "metadata.Region",
	"tags":               "description.Framework.Tags",
	"title":              "description.Framework.Name",
	"type":               "description.Framework.Type",
}

func GetAuditManagerFramework(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAuditManagerFramework")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAuditManagerFrameworkPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAuditManagerFrameworkFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AuditManagerFramework =============================

// ==========================  START: CloudSearchDomain =============================

type CloudSearchDomain struct {
	Description   aws.CloudSearchDomainDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type CloudSearchDomainHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  CloudSearchDomain `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type CloudSearchDomainHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []CloudSearchDomainHit `json:"hits"`
}

type CloudSearchDomainSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  CloudSearchDomainHits `json:"hits"`
}

type CloudSearchDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCloudSearchDomainPaginator(filters []essdk.BoolFilter, limit *int64) (CloudSearchDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_cloudsearch_domain", filters, limit)
	if err != nil {
		return CloudSearchDomainPaginator{}, err
	}

	p := CloudSearchDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CloudSearchDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CloudSearchDomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CloudSearchDomainPaginator) NextPage(ctx context.Context) ([]CloudSearchDomain, error) {
	var response CloudSearchDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CloudSearchDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCloudSearchDomainFilters = map[string]string{
	"created":                  "description.DomainStatus.Created",
	"deleted":                  "description.DomainStatus.Deleted",
	"doc_service":              "description.DomainStatus.DocService",
	"domain_id":                "description.DomainStatus.DomainId",
	"domain_name":              "description.DomainStatus.DomainName",
	"og_account_id":            "metadata.SourceID",
	"limits":                   "description.DomainStatus.Limits",
	"processing":               "description.DomainStatus.Processing",
	"requires_index_documents": "description.DomainStatus.RequiresIndexDocuments",
	"search_instance_count":    "description.DomainStatus.SearchInstanceCount",
	"search_instance_type":     "description.DomainStatus.SearchInstanceType",
	"search_partition_count":   "description.DomainStatus.SearchPartitionCount",
	"search_service":           "description.DomainStatus.SearchService",
	"title":                    "description.DomainStatus.DomainName",
}

func ListCloudSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCloudSearchDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudSearchDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudSearchDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudSearchDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudSearchDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudSearchDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCloudSearchDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCloudSearchDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCloudSearchDomain NewCloudSearchDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCloudSearchDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCloudSearchDomainFilters = map[string]string{
	"created":                  "description.DomainStatus.Created",
	"deleted":                  "description.DomainStatus.Deleted",
	"doc_service":              "description.DomainStatus.DocService",
	"domain_id":                "description.DomainStatus.DomainId",
	"domain_name":              "description.DomainStatus.DomainName",
	"og_account_id":            "metadata.SourceID",
	"limits":                   "description.DomainStatus.Limits",
	"processing":               "description.DomainStatus.Processing",
	"requires_index_documents": "description.DomainStatus.RequiresIndexDocuments",
	"search_instance_count":    "description.DomainStatus.SearchInstanceCount",
	"search_instance_type":     "description.DomainStatus.SearchInstanceType",
	"search_partition_count":   "description.DomainStatus.SearchPartitionCount",
	"search_service":           "description.DomainStatus.SearchService",
	"title":                    "description.DomainStatus.DomainName",
}

func GetCloudSearchDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCloudSearchDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCloudSearchDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCloudSearchDomainFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CloudSearchDomain =============================

// ==========================  START: DLMLifecyclePolicy =============================

type DLMLifecyclePolicy struct {
	Description   aws.DLMLifecyclePolicyDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type DLMLifecyclePolicyHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  DLMLifecyclePolicy `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type DLMLifecyclePolicyHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []DLMLifecyclePolicyHit `json:"hits"`
}

type DLMLifecyclePolicySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  DLMLifecyclePolicyHits `json:"hits"`
}

type DLMLifecyclePolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDLMLifecyclePolicyPaginator(filters []essdk.BoolFilter, limit *int64) (DLMLifecyclePolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_dlm_lifecyclepolicy", filters, limit)
	if err != nil {
		return DLMLifecyclePolicyPaginator{}, err
	}

	p := DLMLifecyclePolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DLMLifecyclePolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DLMLifecyclePolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DLMLifecyclePolicyPaginator) NextPage(ctx context.Context) ([]DLMLifecyclePolicy, error) {
	var response DLMLifecyclePolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DLMLifecyclePolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDLMLifecyclePolicyFilters = map[string]string{
	"arn":                "description.LifecyclePolicy.PolicyArn",
	"date_created":       "description.LifecyclePolicy.DateCreated",
	"date_modified":      "description.LifecyclePolicy.DateModified",
	"description":        "description.LifecyclePolicy.Description",
	"execution_role_arn": "description.LifecyclePolicy.ExecutionRoleArn",
	"og_account_id":      "metadata.SourceID",
	"policy_details":     "description.LifecyclePolicy.PolicyDetails",
	"policy_id":          "description.LifecyclePolicy.PolicyId",
	"policy_type":        "description.LifecyclePolicy.PolicyDetails.PolicyType",
	"state":              "description.LifecyclePolicy.State",
	"status_message":     "description.LifecyclePolicy.StatusMessage",
	"tags":               "description.LifecyclePolicy.Tags",
	"title":              "description.LifecyclePolicy.PolicyId",
}

func ListDLMLifecyclePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDLMLifecyclePolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDLMLifecyclePolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDLMLifecyclePolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDLMLifecyclePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDLMLifecyclePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDLMLifecyclePolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDLMLifecyclePolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDLMLifecyclePolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDLMLifecyclePolicy NewDLMLifecyclePolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDLMLifecyclePolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDLMLifecyclePolicyFilters = map[string]string{
	"arn":                "description.LifecyclePolicy.PolicyArn",
	"date_created":       "description.LifecyclePolicy.DateCreated",
	"date_modified":      "description.LifecyclePolicy.DateModified",
	"description":        "description.LifecyclePolicy.Description",
	"execution_role_arn": "description.LifecyclePolicy.ExecutionRoleArn",
	"id":                 "description.LifecyclePolicy.PolicyId",
	"og_account_id":      "metadata.SourceID",
	"policy_details":     "description.LifecyclePolicy.PolicyDetails",
	"policy_id":          "description.LifecyclePolicy.PolicyId",
	"policy_type":        "description.LifecyclePolicy.PolicyDetails.PolicyType",
	"state":              "description.LifecyclePolicy.State",
	"status_message":     "description.LifecyclePolicy.StatusMessage",
	"tags":               "description.LifecyclePolicy.Tags",
	"title":              "description.LifecyclePolicy.PolicyId",
}

func GetDLMLifecyclePolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDLMLifecyclePolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDLMLifecyclePolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDLMLifecyclePolicyFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DLMLifecyclePolicy =============================

// ==========================  START: DocDBCluster =============================

type DocDBCluster struct {
	Description   aws.DocDBClusterDescription `json:"description"`
	Metadata      aws.Metadata                `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type DocDBClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DocDBCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DocDBClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DocDBClusterHit `json:"hits"`
}

type DocDBClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  DocDBClusterHits `json:"hits"`
}

type DocDBClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDocDBClusterPaginator(filters []essdk.BoolFilter, limit *int64) (DocDBClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_docdb_cluster", filters, limit)
	if err != nil {
		return DocDBClusterPaginator{}, err
	}

	p := DocDBClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DocDBClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DocDBClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DocDBClusterPaginator) NextPage(ctx context.Context) ([]DocDBCluster, error) {
	var response DocDBClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DocDBCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDocDBClusterFilters = map[string]string{
	"arn":                             "description.DBCluster.DBClusterArn",
	"associated_roles":                "description.DBCluster.AssociatedRoles",
	"availability_zones":              "description.DBCluster.AvailabilityZones",
	"backup_retention_period":         "description.DBCluster.BackupRetentionPeriod",
	"clone_group_id":                  "description.DBCluster.CloneGroupId",
	"cluster_create_time":             "description.DBCluster.ClusterCreateTime",
	"db_cluster_identifier":           "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":      "description.DBCluster.DBClusterParameterGroup",
	"db_cluster_resource_id":          "description.DBCluster.DbClusterResourceId",
	"db_subnet_group":                 "description.DBCluster.DBSubnetGroup",
	"deletion_protection":             "description.DBCluster.DeletionProtection",
	"earliest_restorable_time":        "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports": "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                        "description.DBCluster.Endpoint",
	"engine":                          "description.DBCluster.Engine",
	"engine_version":                  "description.DBCluster.EngineVersion",
	"hosted_zone_id":                  "description.DBCluster.HostedZoneId",
	"og_account_id":                   "metadata.SourceID",
	"kms_key_id":                      "description.DBCluster.KmsKeyId",
	"latest_restorable_time":          "description.DBCluster.LatestRestorableTime",
	"master_user_name":                "description.DBCluster.MasterUsername",
	"members":                         "description.DBCluster.DBClusterMembers",
	"multi_az":                        "description.DBCluster.MultiAZ",
	"percent_progress":                "description.DBCluster.PercentProgress",
	"port":                            "description.DBCluster.Port",
	"preferred_backup_window":         "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":    "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":        "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                 "description.DBCluster.ReaderEndpoint",
	"replication_source_identifier":   "description.DBCluster.ReplicationSourceIdentifier",
	"status":                          "description.DBCluster.Status",
	"storage_encrypted":               "description.DBCluster.StorageEncrypted",
	"tags_src":                        "description.Tags",
	"title":                           "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":             "description.DBCluster.VpcSecurityGroups",
}

func ListDocDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDocDBCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDocDBClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDocDBClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBCluster NewDocDBClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDocDBCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDocDBClusterFilters = map[string]string{
	"arn":                             "description.DBCluster.DBClusterArn",
	"associated_roles":                "description.DBCluster.AssociatedRoles",
	"availability_zones":              "description.DBCluster.AvailabilityZones",
	"backup_retention_period":         "description.DBCluster.BackupRetentionPeriod",
	"clone_group_id":                  "description.DBCluster.CloneGroupId",
	"cluster_create_time":             "description.DBCluster.ClusterCreateTime",
	"db_cluster_identifier":           "description.DBCluster.DBClusterIdentifier",
	"db_cluster_parameter_group":      "description.DBCluster.DBClusterParameterGroup",
	"db_cluster_resource_id":          "description.DBCluster.DbClusterResourceId",
	"db_subnet_group":                 "description.DBCluster.DBSubnetGroup",
	"deletion_protection":             "description.DBCluster.DeletionProtection",
	"earliest_restorable_time":        "description.DBCluster.EarliestRestorableTime",
	"enabled_cloudwatch_logs_exports": "description.DBCluster.EnabledCloudwatchLogsExports",
	"endpoint":                        "description.DBCluster.Endpoint",
	"engine":                          "description.DBCluster.Engine",
	"engine_version":                  "description.DBCluster.EngineVersion",
	"hosted_zone_id":                  "description.DBCluster.HostedZoneId",
	"og_account_id":                   "metadata.SourceID",
	"kms_key_id":                      "description.DBCluster.KmsKeyId",
	"latest_restorable_time":          "description.DBCluster.LatestRestorableTime",
	"master_user_name":                "description.DBCluster.MasterUsername",
	"members":                         "description.DBCluster.DBClusterMembers",
	"multi_az":                        "description.DBCluster.MultiAZ",
	"percent_progress":                "description.DBCluster.PercentProgress",
	"port":                            "description.DBCluster.Port",
	"preferred_backup_window":         "description.DBCluster.PreferredBackupWindow",
	"preferred_maintenance_window":    "description.DBCluster.PreferredMaintenanceWindow",
	"read_replica_identifiers":        "description.DBCluster.ReadReplicaIdentifiers",
	"reader_endpoint":                 "description.DBCluster.ReaderEndpoint",
	"replication_source_identifier":   "description.DBCluster.ReplicationSourceIdentifier",
	"status":                          "description.DBCluster.Status",
	"storage_encrypted":               "description.DBCluster.StorageEncrypted",
	"tags_src":                        "description.Tags",
	"title":                           "description.DBCluster.DBClusterIdentifier",
	"vpc_security_groups":             "description.DBCluster.VpcSecurityGroups",
}

func GetDocDBCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDocDBCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDocDBClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDocDBClusterFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DocDBCluster =============================

// ==========================  START: DocDBClusterInstance =============================

type DocDBClusterInstance struct {
	Description   aws.DocDBClusterInstanceDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type DocDBClusterInstanceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  DocDBClusterInstance `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type DocDBClusterInstanceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []DocDBClusterInstanceHit `json:"hits"`
}

type DocDBClusterInstanceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  DocDBClusterInstanceHits `json:"hits"`
}

type DocDBClusterInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDocDBClusterInstancePaginator(filters []essdk.BoolFilter, limit *int64) (DocDBClusterInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_docdb_clusterinstance", filters, limit)
	if err != nil {
		return DocDBClusterInstancePaginator{}, err
	}

	p := DocDBClusterInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DocDBClusterInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DocDBClusterInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DocDBClusterInstancePaginator) NextPage(ctx context.Context) ([]DocDBClusterInstance, error) {
	var response DocDBClusterInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DocDBClusterInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDocDBClusterInstanceFilters = map[string]string{
	"availability_zone":               "description.DBInstance.AvailabilityZone",
	"backup_retention_period":         "description.DBInstance.BackupRetentionPeriod",
	"ca_certificate_identifier":       "description.DBInstance.CACertificateIdentifier",
	"copy_tags_to_snapshot":           "description.DBInstance.CopyTagsToSnapshot",
	"db_cluster_identifier":           "description.DBInstance.DBClusterIdentifier",
	"db_instance_arn":                 "description.DBInstance.DBInstanceArn",
	"db_instance_class":               "description.DBInstance.DBInstanceClass",
	"db_instance_identifier":          "description.DBInstance.DBInstanceIdentifier",
	"db_instance_status":              "description.DBInstance.DBInstanceStatus",
	"db_subnet_group_arn":             "description.DBInstance.DBSubnetGroup.DBSubnetGroupArn",
	"db_subnet_group_description":     "description.DBInstance.DBSubnetGroup.DBSubnetGroupDescription",
	"db_subnet_group_name":            "description.DBInstance.DBSubnetGroup.DBSubnetGroupName",
	"db_subnet_group_status":          "description.DBInstance.DBSubnetGroup.SubnetGroupStatus",
	"dbi_resource_id":                 "description.DBInstance.DbiResourceId",
	"enabled_cloudwatch_logs_exports": "description.DBInstance.EnabledCloudwatchLogsExports",
	"endpoint_address":                "description.DBInstance.Endpoint.Address",
	"endpoint_hosted_zone_id":         "description.DBInstance.Endpoint.HostedZoneId",
	"endpoint_port":                   "description.DBInstance.Endpoint.Port",
	"engine":                          "description.DBInstance.Engine",
	"engine_version":                  "description.DBInstance.EngineVersion",
	"instance_create_time":            "description.DBInstance.InstanceCreateTime",
	"og_account_id":                   "metadata.SourceID",
	"kms_key_id":                      "description.DBInstance.KmsKeyId",
	"latest_restorable_time":          "description.DBInstance.LatestRestorableTime",
	"pending_modified_values":         "description.DBInstance.PendingModifiedValues",
	"preferred_backup_window":         "description.DBInstance.PreferredBackupWindow",
	"preferred_maintenance_window":    "description.DBInstance.PreferredMaintenanceWindow",
	"promotion_tier":                  "description.DBInstance.PromotionTier",
	"publicly_accessible":             "description.DBInstance.PubliclyAccessible",
	"status_infos":                    "description.DBInstance.StatusInfos",
	"storage_encrypted":               "description.DBInstance.StorageEncrypted",
	"subnets":                         "description.DBInstance.DBSubnetGroup.Subnets",
	"tags_src":                        "description.Tags",
	"title":                           "description.DBInstance.DBInstanceIdentifier",
	"vpc_id":                          "description.DBInstance.DBSubnetGroup.VpcId",
	"vpc_security_groups":             "description.DBInstance.VpcSecurityGroups",
}

func ListDocDBClusterInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDocDBClusterInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDocDBClusterInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDocDBClusterInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterInstance NewDocDBClusterInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDocDBClusterInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDocDBClusterInstanceFilters = map[string]string{
	"availability_zone":               "description.DBInstance.AvailabilityZone",
	"backup_retention_period":         "description.DBInstance.BackupRetentionPeriod",
	"ca_certificate_identifier":       "description.DBInstance.CACertificateIdentifier",
	"copy_tags_to_snapshot":           "description.DBInstance.CopyTagsToSnapshot",
	"db_cluster_identifier":           "description.DBInstance.DBClusterIdentifier",
	"db_instance_arn":                 "description.DBInstance.DBInstanceArn",
	"db_instance_class":               "description.DBInstance.DBInstanceClass",
	"db_instance_identifier":          "description.DBCluster.DBClusterIdentifier",
	"db_instance_status":              "description.DBInstance.DBInstanceStatus",
	"db_subnet_group_arn":             "description.DBInstance.DBSubnetGroup.DBSubnetGroupArn",
	"db_subnet_group_description":     "description.DBInstance.DBSubnetGroup.DBSubnetGroupDescription",
	"db_subnet_group_name":            "description.DBInstance.DBSubnetGroup.DBSubnetGroupName",
	"db_subnet_group_status":          "description.DBInstance.DBSubnetGroup.SubnetGroupStatus",
	"dbi_resource_id":                 "description.DBInstance.DbiResourceId",
	"enabled_cloudwatch_logs_exports": "description.DBInstance.EnabledCloudwatchLogsExports",
	"endpoint_address":                "description.DBInstance.Endpoint.Address",
	"endpoint_hosted_zone_id":         "description.DBInstance.Endpoint.HostedZoneId",
	"endpoint_port":                   "description.DBInstance.Endpoint.Port",
	"engine":                          "description.DBInstance.Engine",
	"engine_version":                  "description.DBInstance.EngineVersion",
	"instance_create_time":            "description.DBInstance.InstanceCreateTime",
	"og_account_id":                   "metadata.SourceID",
	"kms_key_id":                      "description.DBInstance.KmsKeyId",
	"latest_restorable_time":          "description.DBInstance.LatestRestorableTime",
	"pending_modified_values":         "description.DBInstance.PendingModifiedValues",
	"preferred_backup_window":         "description.DBInstance.PreferredBackupWindow",
	"preferred_maintenance_window":    "description.DBInstance.PreferredMaintenanceWindow",
	"promotion_tier":                  "description.DBInstance.PromotionTier",
	"publicly_accessible":             "description.DBInstance.PubliclyAccessible",
	"status_infos":                    "description.DBInstance.StatusInfos",
	"storage_encrypted":               "description.DBInstance.StorageEncrypted",
	"subnets":                         "description.DBInstance.DBSubnetGroup.Subnets",
	"tags_src":                        "description.Tags",
	"title":                           "description.DBInstance.DBInstanceIdentifier",
	"vpc_id":                          "description.DBInstance.DBSubnetGroup.VpcId",
	"vpc_security_groups":             "description.DBInstance.VpcSecurityGroups",
}

func GetDocDBClusterInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDocDBClusterInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDocDBClusterInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDocDBClusterInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DocDBClusterInstance =============================

// ==========================  START: DocDBClusterSnapshot =============================

type DocDBClusterSnapshot struct {
	Description   aws.DocDBClusterSnapshotDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type DocDBClusterSnapshotHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  DocDBClusterSnapshot `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type DocDBClusterSnapshotHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []DocDBClusterSnapshotHit `json:"hits"`
}

type DocDBClusterSnapshotSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  DocDBClusterSnapshotHits `json:"hits"`
}

type DocDBClusterSnapshotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDocDBClusterSnapshotPaginator(filters []essdk.BoolFilter, limit *int64) (DocDBClusterSnapshotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_docdb_clustersnapshot", filters, limit)
	if err != nil {
		return DocDBClusterSnapshotPaginator{}, err
	}

	p := DocDBClusterSnapshotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DocDBClusterSnapshotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DocDBClusterSnapshotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DocDBClusterSnapshotPaginator) NextPage(ctx context.Context) ([]DocDBClusterSnapshot, error) {
	var response DocDBClusterSnapshotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DocDBClusterSnapshot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDocDBClusterSnapshotFilters = map[string]string{
	"arn":                            "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"availability_zones":             "description.DBClusterSnapshot.AvailabilityZones",
	"cluster_create_time":            "description.DBClusterSnapshot.ClusterCreateTime",
	"db_cluster_identifier":          "description.DBClusterSnapshot.DBClusterIdentifier",
	"db_cluster_snapshot_attributes": "description.Attributes.DBClusterSnapshotAttributes",
	"db_cluster_snapshot_identifier": "description.DBClusterSnapshot.DBClusterIdentifier",
	"engine":                         "description.DBClusterSnapshot.Engine",
	"engine_version":                 "description.DBClusterSnapshot.EngineVersion",
	"kms_key_id":                     "description.DBClusterSnapshot.KmsKeyId",
	"master_user_name":               "description.DBClusterSnapshot.MasterUsername",
	"percent_progress":               "description.DBClusterSnapshot.PercentProgress",
	"port":                           "description.DBClusterSnapshot.Port",
	"snapshot_create_time":           "description.DBClusterSnapshot.SnapshotCreateTime",
	"snapshot_type":                  "description.DBClusterSnapshot.SnapshotType",
	"source_db_cluster_snapshot_arn": "description.DBClusterSnapshot.SourceDBClusterSnapshotArn",
	"status":                         "description.DBClusterSnapshot.Status",
	"storage_encrypted":              "description.DBClusterSnapshot.StorageEncrypted",
	"tags_src":                       "description.Tags",
	"title":                          "description.DBClusterSnapshot.DBClusterIdentifier",
	"vpc_id":                         "description.DBClusterSnapshot.VpcId",
}

func ListDocDBClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDocDBClusterSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterSnapshot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterSnapshot NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterSnapshot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDocDBClusterSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDocDBClusterSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDocDBClusterSnapshot NewDocDBClusterSnapshotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDocDBClusterSnapshot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDocDBClusterSnapshotFilters = map[string]string{
	"arn":                            "description.DBClusterSnapshot.DBClusterSnapshotArn",
	"availability_zones":             "description.DBClusterSnapshot.AvailabilityZones",
	"cluster_create_time":            "description.DBClusterSnapshot.ClusterCreateTime",
	"db_cluster_identifier":          "description.DBClusterSnapshot.DBClusterIdentifier",
	"db_cluster_snapshot_attributes": "description.Attributes.DBClusterSnapshotAttributes",
	"db_cluster_snapshot_identifier": "description.DBClusterSnapshot.DBClusterIdentifier",
	"engine":                         "description.DBClusterSnapshot.Engine",
	"engine_version":                 "description.DBClusterSnapshot.EngineVersion",
	"kms_key_id":                     "description.DBClusterSnapshot.KmsKeyId",
	"master_user_name":               "description.DBClusterSnapshot.MasterUsername",
	"percent_progress":               "description.DBClusterSnapshot.PercentProgress",
	"port":                           "description.DBClusterSnapshot.Port",
	"snapshot_create_time":           "description.DBClusterSnapshot.SnapshotCreateTime",
	"snapshot_type":                  "description.DBClusterSnapshot.SnapshotType",
	"source_db_cluster_snapshot_arn": "description.DBClusterSnapshot.SourceDBClusterSnapshotArn",
	"status":                         "description.DBClusterSnapshot.Status",
	"storage_encrypted":              "description.DBClusterSnapshot.StorageEncrypted",
	"tags_src":                       "description.Tags",
	"title":                          "description.DBClusterSnapshot.DBClusterIdentifier",
	"vpc_id":                         "description.DBClusterSnapshot.VpcId",
}

func GetDocDBClusterSnapshot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDocDBClusterSnapshot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDocDBClusterSnapshotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDocDBClusterSnapshotFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DocDBClusterSnapshot =============================

// ==========================  START: GlobalAcceleratorAccelerator =============================

type GlobalAcceleratorAccelerator struct {
	Description   aws.GlobalAcceleratorAcceleratorDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type GlobalAcceleratorAcceleratorHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  GlobalAcceleratorAccelerator `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type GlobalAcceleratorAcceleratorHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []GlobalAcceleratorAcceleratorHit `json:"hits"`
}

type GlobalAcceleratorAcceleratorSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  GlobalAcceleratorAcceleratorHits `json:"hits"`
}

type GlobalAcceleratorAcceleratorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlobalAcceleratorAcceleratorPaginator(filters []essdk.BoolFilter, limit *int64) (GlobalAcceleratorAcceleratorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_globalaccelerator_accelerator", filters, limit)
	if err != nil {
		return GlobalAcceleratorAcceleratorPaginator{}, err
	}

	p := GlobalAcceleratorAcceleratorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlobalAcceleratorAcceleratorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlobalAcceleratorAcceleratorPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlobalAcceleratorAcceleratorPaginator) NextPage(ctx context.Context) ([]GlobalAcceleratorAccelerator, error) {
	var response GlobalAcceleratorAcceleratorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlobalAcceleratorAccelerator
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlobalAcceleratorAcceleratorFilters = map[string]string{
	"accelerator_attributes": "description.AcceleratorAttributes",
	"arn":                    "description.Accelerator.AcceleratorArn",
	"created_time":           "description.Accelerator.CreatedTime",
	"dns_name":               "description.Accelerator.DnsName",
	"enabled":                "description.Accelerator.Enabled",
	"ip_address_type":        "description.Accelerator.IpAddressType",
	"ip_sets":                "description.Accelerator.IpSets",
	"og_account_id":          "metadata.SourceID",
	"last_modified_time":     "description.Accelerator.LastModifiedTime",
	"name":                   "description.Accelerator.Name",
	"status":                 "description.Accelerator.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Accelerator.Name",
}

func ListGlobalAcceleratorAccelerator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlobalAcceleratorAccelerator")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorAccelerator NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorAccelerator NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorAccelerator GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorAccelerator GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorAccelerator GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlobalAcceleratorAcceleratorPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlobalAcceleratorAcceleratorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorAccelerator NewGlobalAcceleratorAcceleratorPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlobalAcceleratorAccelerator paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlobalAcceleratorAcceleratorFilters = map[string]string{
	"accelerator_attributes": "description.AcceleratorAttributes",
	"arn":                    "description.Accelerator.AcceleratorArn",
	"created_time":           "description.Accelerator.CreatedTime",
	"dns_name":               "description.Accelerator.DnsName",
	"enabled":                "description.Accelerator.Enabled",
	"ip_address_type":        "description.Accelerator.IpAddressType",
	"ip_sets":                "description.Accelerator.IpSets",
	"og_account_id":          "metadata.SourceID",
	"last_modified_time":     "description.Accelerator.LastModifiedTime",
	"name":                   "description.Accelerator.Name",
	"status":                 "description.Accelerator.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Accelerator.Name",
}

func GetGlobalAcceleratorAccelerator(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlobalAcceleratorAccelerator")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlobalAcceleratorAcceleratorPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlobalAcceleratorAcceleratorFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlobalAcceleratorAccelerator =============================

// ==========================  START: GlobalAcceleratorEndpointGroup =============================

type GlobalAcceleratorEndpointGroup struct {
	Description   aws.GlobalAcceleratorEndpointGroupDescription `json:"description"`
	Metadata      aws.Metadata                                  `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type GlobalAcceleratorEndpointGroupHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  GlobalAcceleratorEndpointGroup `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type GlobalAcceleratorEndpointGroupHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []GlobalAcceleratorEndpointGroupHit `json:"hits"`
}

type GlobalAcceleratorEndpointGroupSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  GlobalAcceleratorEndpointGroupHits `json:"hits"`
}

type GlobalAcceleratorEndpointGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlobalAcceleratorEndpointGroupPaginator(filters []essdk.BoolFilter, limit *int64) (GlobalAcceleratorEndpointGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_globalaccelerator_endpointgroup", filters, limit)
	if err != nil {
		return GlobalAcceleratorEndpointGroupPaginator{}, err
	}

	p := GlobalAcceleratorEndpointGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlobalAcceleratorEndpointGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlobalAcceleratorEndpointGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlobalAcceleratorEndpointGroupPaginator) NextPage(ctx context.Context) ([]GlobalAcceleratorEndpointGroup, error) {
	var response GlobalAcceleratorEndpointGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlobalAcceleratorEndpointGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlobalAcceleratorEndpointGroupFilters = map[string]string{
	"arn":                           "description.EndpointGroup.EndpointGroupArn",
	"endpoint_descriptions":         "description.EndpointGroup.EndpointDescriptions",
	"endpoint_group_region":         "description.EndpointGroup.EndpointGroupRegion",
	"health_check_interval_seconds": "description.EndpointGroup.HealthCheckIntervalSeconds",
	"health_check_path":             "description.EndpointGroup.HealthCheckPath",
	"health_check_port":             "description.EndpointGroup.HealthCheckPort",
	"health_check_protocol":         "description.EndpointGroup.HealthCheckProtocol",
	"og_account_id":                 "metadata.SourceID",
	"listener_arn":                  "description.ListenerArn",
	"port_overrides":                "description.EndpointGroup.PortOverrides",
	"threshold_count":               "description.EndpointGroup.ThresholdCount",
	"traffic_dial_percentage":       "description.EndpointGroup.TrafficDialPercentage",
}

func ListGlobalAcceleratorEndpointGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlobalAcceleratorEndpointGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorEndpointGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorEndpointGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorEndpointGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorEndpointGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorEndpointGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlobalAcceleratorEndpointGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlobalAcceleratorEndpointGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorEndpointGroup NewGlobalAcceleratorEndpointGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlobalAcceleratorEndpointGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlobalAcceleratorEndpointGroupFilters = map[string]string{
	"arn":                           "description.EndpointGroup.EndpointGroupArn",
	"endpoint_descriptions":         "description.EndpointGroup.EndpointDescriptions",
	"endpoint_group_region":         "description.EndpointGroup.EndpointGroupRegion",
	"health_check_interval_seconds": "description.EndpointGroup.HealthCheckIntervalSeconds",
	"health_check_path":             "description.EndpointGroup.HealthCheckPath",
	"health_check_port":             "description.EndpointGroup.HealthCheckPort",
	"health_check_protocol":         "description.EndpointGroup.HealthCheckProtocol",
	"og_account_id":                 "metadata.SourceID",
	"listener_arn":                  "description.ListenerArn",
	"port_overrides":                "description.EndpointGroup.PortOverrides",
	"threshold_count":               "description.EndpointGroup.ThresholdCount",
	"traffic_dial_percentage":       "description.EndpointGroup.TrafficDialPercentage",
}

func GetGlobalAcceleratorEndpointGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlobalAcceleratorEndpointGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlobalAcceleratorEndpointGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlobalAcceleratorEndpointGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlobalAcceleratorEndpointGroup =============================

// ==========================  START: GlobalAcceleratorListener =============================

type GlobalAcceleratorListener struct {
	Description   aws.GlobalAcceleratorListenerDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type GlobalAcceleratorListenerHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  GlobalAcceleratorListener `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type GlobalAcceleratorListenerHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []GlobalAcceleratorListenerHit `json:"hits"`
}

type GlobalAcceleratorListenerSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  GlobalAcceleratorListenerHits `json:"hits"`
}

type GlobalAcceleratorListenerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlobalAcceleratorListenerPaginator(filters []essdk.BoolFilter, limit *int64) (GlobalAcceleratorListenerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_globalaccelerator_listener", filters, limit)
	if err != nil {
		return GlobalAcceleratorListenerPaginator{}, err
	}

	p := GlobalAcceleratorListenerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlobalAcceleratorListenerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlobalAcceleratorListenerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlobalAcceleratorListenerPaginator) NextPage(ctx context.Context) ([]GlobalAcceleratorListener, error) {
	var response GlobalAcceleratorListenerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlobalAcceleratorListener
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlobalAcceleratorListenerFilters = map[string]string{
	"accelerator_arn": "description.AcceleratorArn",
	"arn":             "description.Listener.ListenerArn",
	"client_affinity": "description.Listener.ClientAffinity",
	"og_account_id":   "metadata.SourceID",
	"port_ranges":     "description.Listener.PortRanges",
	"protocol":        "description.Listener.Protocol",
}

func ListGlobalAcceleratorListener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlobalAcceleratorListener")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorListener NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorListener NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorListener GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorListener GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorListener GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlobalAcceleratorListenerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlobalAcceleratorListenerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlobalAcceleratorListener NewGlobalAcceleratorListenerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlobalAcceleratorListener paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlobalAcceleratorListenerFilters = map[string]string{
	"accelerator_arn": "description.AcceleratorArn",
	"arn":             "description.Listener.ListenerArn",
	"client_affinity": "description.Listener.ClientAffinity",
	"og_account_id":   "metadata.SourceID",
	"port_ranges":     "description.Listener.PortRanges",
	"protocol":        "description.Listener.Protocol",
}

func GetGlobalAcceleratorListener(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlobalAcceleratorListener")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlobalAcceleratorListenerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlobalAcceleratorListenerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlobalAcceleratorListener =============================

// ==========================  START: GlueCatalogDatabase =============================

type GlueCatalogDatabase struct {
	Description   aws.GlueCatalogDatabaseDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type GlueCatalogDatabaseHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  GlueCatalogDatabase `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type GlueCatalogDatabaseHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []GlueCatalogDatabaseHit `json:"hits"`
}

type GlueCatalogDatabaseSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  GlueCatalogDatabaseHits `json:"hits"`
}

type GlueCatalogDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueCatalogDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (GlueCatalogDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_catalogdatabase", filters, limit)
	if err != nil {
		return GlueCatalogDatabasePaginator{}, err
	}

	p := GlueCatalogDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueCatalogDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueCatalogDatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueCatalogDatabasePaginator) NextPage(ctx context.Context) ([]GlueCatalogDatabase, error) {
	var response GlueCatalogDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueCatalogDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueCatalogDatabaseFilters = map[string]string{
	"catalog_id":                       "description.Database.CatalogId",
	"create_table_default_permissions": "description.Database.CreateTableDefaultPermissions",
	"create_time":                      "description.Database.CreateTime",
	"description":                      "description.Database.Description",
	"og_account_id":                    "metadata.SourceID",
	"location_uri":                     "description.Database.LocationUri",
	"name":                             "description.Database.Name",
	"parameters":                       "description.Database.Parameters",
	"target_database":                  "description.Database.TargetDatabase",
	"title":                            "description.Database.Name",
}

func ListGlueCatalogDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueCatalogDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueCatalogDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueCatalogDatabaseFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogDatabase NewGlueCatalogDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueCatalogDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueCatalogDatabaseFilters = map[string]string{
	"catalog_id":                       "description.Database.CatalogId",
	"create_table_default_permissions": "description.Database.CreateTableDefaultPermissions",
	"create_time":                      "description.Database.CreateTime",
	"description":                      "description.Database.Description",
	"og_account_id":                    "metadata.SourceID",
	"location_uri":                     "description.Database.LocationUri",
	"name":                             "description.Database.Name",
	"parameters":                       "description.Database.Parameters",
	"target_database":                  "description.Database.TargetDatabase",
	"title":                            "description.Database.Name",
}

func GetGlueCatalogDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueCatalogDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueCatalogDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueCatalogDatabaseFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueCatalogDatabase =============================

// ==========================  START: GlueCatalogTable =============================

type GlueCatalogTable struct {
	Description   aws.GlueCatalogTableDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type GlueCatalogTableHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  GlueCatalogTable `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type GlueCatalogTableHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []GlueCatalogTableHit `json:"hits"`
}

type GlueCatalogTableSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  GlueCatalogTableHits `json:"hits"`
}

type GlueCatalogTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueCatalogTablePaginator(filters []essdk.BoolFilter, limit *int64) (GlueCatalogTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_catalogtable", filters, limit)
	if err != nil {
		return GlueCatalogTablePaginator{}, err
	}

	p := GlueCatalogTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueCatalogTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueCatalogTablePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueCatalogTablePaginator) NextPage(ctx context.Context) ([]GlueCatalogTable, error) {
	var response GlueCatalogTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueCatalogTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueCatalogTableFilters = map[string]string{
	"catalog_id":                        "description.Table.CatalogId",
	"create_time":                       "description.Table.CreateTime",
	"created_by":                        "description.Table.CreatedBy",
	"database_name":                     "description.Table.DatabaseName",
	"description":                       "description.Table.Description",
	"is_registered_with_lake_formation": "description.Table.IsRegisteredWithLakeFormation",
	"og_account_id":                     "metadata.SourceID",
	"last_access_time":                  "description.Table.LastAccessTime",
	"last_analyzed_time":                "description.Table.LastAnalyzedTime",
	"lf_tags":                           "description.LfTags",
	"name":                              "description.Table.Name",
	"owner":                             "description.Table.Owner",
	"parameters":                        "description.Table.Parameters",
	"partition_keys":                    "description.Table.PartitionKeys",
	"retention":                         "description.Table.Retention",
	"storage_descriptor":                "description.Table.StorageDescriptor",
	"table_type":                        "description.Table.TableType",
	"target_table":                      "description.Table.TargetTable",
	"title":                             "description.Table.Name",
	"update_time":                       "description.Table.UpdateTime",
	"view_expanded_text":                "description.Table.ViewExpandedText",
	"view_original_text":                "description.Table.ViewOriginalText",
}

func ListGlueCatalogTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueCatalogTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogTable NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogTable NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueCatalogTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueCatalogTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCatalogTable NewGlueCatalogTablePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueCatalogTable paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueCatalogTableFilters = map[string]string{
	"catalog_id":                        "description.Table.CatalogId",
	"create_time":                       "description.Table.CreateTime",
	"created_by":                        "description.Table.CreatedBy",
	"database_name":                     "description.DatabaseName",
	"description":                       "description.Table.Description",
	"is_registered_with_lake_formation": "description.Table.IsRegisteredWithLakeFormation",
	"og_account_id":                     "metadata.SourceID",
	"last_access_time":                  "description.Table.LastAccessTime",
	"last_analyzed_time":                "description.Table.LastAnalyzedTime",
	"lf_tags":                           "description.LfTags",
	"name":                              "description.Table.Name",
	"owner":                             "description.Table.Owner",
	"parameters":                        "description.Table.Parameters",
	"partition_keys":                    "description.Table.PartitionKeys",
	"retention":                         "description.Table.Retention",
	"storage_descriptor":                "description.Table.StorageDescriptor",
	"table_type":                        "description.Table.TableType",
	"target_table":                      "description.Table.TargetTable",
	"title":                             "description.Table.Name",
	"update_time":                       "description.Table.UpdateTime",
	"view_expanded_text":                "description.Table.ViewExpandedText",
	"view_original_text":                "description.Table.ViewOriginalText",
}

func GetGlueCatalogTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueCatalogTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueCatalogTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueCatalogTableFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueCatalogTable =============================

// ==========================  START: GlueConnection =============================

type GlueConnection struct {
	Description   aws.GlueConnectionDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type GlueConnectionHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  GlueConnection `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type GlueConnectionHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []GlueConnectionHit `json:"hits"`
}

type GlueConnectionSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  GlueConnectionHits `json:"hits"`
}

type GlueConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (GlueConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_connection", filters, limit)
	if err != nil {
		return GlueConnectionPaginator{}, err
	}

	p := GlueConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueConnectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueConnectionPaginator) NextPage(ctx context.Context) ([]GlueConnection, error) {
	var response GlueConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueConnectionFilters = map[string]string{
	"connection_properties":            "description.Connection.ConnectionProperties",
	"connection_type":                  "description.Connection.ConnectionType",
	"creation_time":                    "description.Connection.CreationTime",
	"description":                      "description.Connection.Description",
	"og_account_id":                    "metadata.SourceID",
	"last_updated_by":                  "description.Connection.LastUpdatedBy",
	"last_updated_time":                "description.Connection.LastUpdatedTime",
	"match_criteria":                   "description.Connection.MatchCriteria",
	"name":                             "description.Connection.Name",
	"physical_connection_requirements": "description.Connection.PhysicalConnectionRequirements",
	"title":                            "description.Connection.Name",
}

func ListGlueConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueConnection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueConnection NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueConnection NewGlueConnectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueConnection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueConnectionFilters = map[string]string{
	"connection_properties":            "description.Connection.ConnectionProperties",
	"connection_type":                  "description.Connection.ConnectionType",
	"creation_time":                    "description.Connection.CreationTime",
	"description":                      "description.Connection.Description",
	"og_account_id":                    "metadata.SourceID",
	"last_updated_by":                  "description.Connection.LastUpdatedBy",
	"last_updated_time":                "description.Connection.LastUpdatedTime",
	"match_criteria":                   "description.Connection.MatchCriteria",
	"name":                             "description.Connection.Name",
	"physical_connection_requirements": "description.Connection.PhysicalConnectionRequirements",
	"title":                            "description.Connection.Name",
}

func GetGlueConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueConnectionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueConnection =============================

// ==========================  START: GlueCrawler =============================

type GlueCrawler struct {
	Description   aws.GlueCrawlerDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type GlueCrawlerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GlueCrawler   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GlueCrawlerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GlueCrawlerHit  `json:"hits"`
}

type GlueCrawlerSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  GlueCrawlerHits `json:"hits"`
}

type GlueCrawlerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueCrawlerPaginator(filters []essdk.BoolFilter, limit *int64) (GlueCrawlerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_crawler", filters, limit)
	if err != nil {
		return GlueCrawlerPaginator{}, err
	}

	p := GlueCrawlerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueCrawlerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueCrawlerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueCrawlerPaginator) NextPage(ctx context.Context) ([]GlueCrawler, error) {
	var response GlueCrawlerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueCrawler
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueCrawlerFilters = map[string]string{
	"classifiers":                    "description.Crawler.Classifiers",
	"configuration":                  "description.Crawler.Configuration",
	"crawl_elapsed_time":             "description.Crawler.CrawlElapsedTime",
	"crawler_lineage_settings":       "description.Crawler.LineageConfiguration.CrawlerLineageSettings",
	"crawler_security_configuration": "description.Crawler.CrawlerSecurityConfiguration",
	"creation_time":                  "description.Crawler.CreationTime",
	"database_name":                  "description.Crawler.DatabaseName",
	"description":                    "description.Crawler.Description",
	"og_account_id":                  "metadata.SourceID",
	"last_crawl":                     "description.Crawler.LastCrawl",
	"last_updated":                   "description.Crawler.LastUpdated",
	"name":                           "description.Crawler.Name",
	"recrawl_behavior":               "description.Crawler.RecrawlPolicy.RecrawlBehavior",
	"role":                           "description.Crawler.Role",
	"schedule":                       "description.Crawler.Schedule",
	"schema_change_policy":           "description.Crawler.SchemaChangePolicy",
	"state":                          "description.Crawler.State",
	"table_prefix":                   "description.Crawler.TablePrefix",
	"targets":                        "description.Crawler.Targets",
	"title":                          "description.Crawler.Name",
	"version":                        "description.Crawler.Version",
}

func ListGlueCrawler(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueCrawler")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCrawler NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCrawler NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCrawler GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCrawler GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCrawler GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueCrawlerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueCrawlerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueCrawler NewGlueCrawlerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueCrawler paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueCrawlerFilters = map[string]string{
	"classifiers":                    "description.Crawler.Classifiers",
	"configuration":                  "description.Crawler.Configuration",
	"crawl_elapsed_time":             "description.Crawler.CrawlElapsedTime",
	"crawler_lineage_settings":       "description.Crawler.LineageConfiguration.CrawlerLineageSettings",
	"crawler_security_configuration": "description.Crawler.CrawlerSecurityConfiguration",
	"creation_time":                  "description.Crawler.CreationTime",
	"database_name":                  "description.Crawler.DatabaseName",
	"description":                    "description.Crawler.Description",
	"og_account_id":                  "metadata.SourceID",
	"last_crawl":                     "description.Crawler.LastCrawl",
	"last_updated":                   "description.Crawler.LastUpdated",
	"name":                           "description.Crawler.Name",
	"recrawl_behavior":               "description.Crawler.RecrawlPolicy.RecrawlBehavior",
	"role":                           "description.Crawler.Role",
	"schedule":                       "description.Crawler.Schedule",
	"schema_change_policy":           "description.Crawler.SchemaChangePolicy",
	"state":                          "description.Crawler.State",
	"table_prefix":                   "description.Crawler.TablePrefix",
	"targets":                        "description.Crawler.Targets",
	"title":                          "description.Crawler.Name",
	"version":                        "description.Crawler.Version",
}

func GetGlueCrawler(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueCrawler")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueCrawlerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueCrawlerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueCrawler =============================

// ==========================  START: GlueDataCatalogEncryptionSettings =============================

type GlueDataCatalogEncryptionSettings struct {
	Description   aws.GlueDataCatalogEncryptionSettingsDescription `json:"description"`
	Metadata      aws.Metadata                                     `json:"metadata"`
	ResourceJobID int                                              `json:"resource_job_id"`
	SourceJobID   int                                              `json:"source_job_id"`
	ResourceType  string                                           `json:"resource_type"`
	SourceType    string                                           `json:"source_type"`
	ID            string                                           `json:"id"`
	ARN           string                                           `json:"arn"`
	SourceID      string                                           `json:"source_id"`
}

type GlueDataCatalogEncryptionSettingsHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  GlueDataCatalogEncryptionSettings `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type GlueDataCatalogEncryptionSettingsHits struct {
	Total essdk.SearchTotal                      `json:"total"`
	Hits  []GlueDataCatalogEncryptionSettingsHit `json:"hits"`
}

type GlueDataCatalogEncryptionSettingsSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  GlueDataCatalogEncryptionSettingsHits `json:"hits"`
}

type GlueDataCatalogEncryptionSettingsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueDataCatalogEncryptionSettingsPaginator(filters []essdk.BoolFilter, limit *int64) (GlueDataCatalogEncryptionSettingsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_datacatalogencryptionsettings", filters, limit)
	if err != nil {
		return GlueDataCatalogEncryptionSettingsPaginator{}, err
	}

	p := GlueDataCatalogEncryptionSettingsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueDataCatalogEncryptionSettingsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueDataCatalogEncryptionSettingsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueDataCatalogEncryptionSettingsPaginator) NextPage(ctx context.Context) ([]GlueDataCatalogEncryptionSettings, error) {
	var response GlueDataCatalogEncryptionSettingsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueDataCatalogEncryptionSettings
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueDataCatalogEncryptionSettingsFilters = map[string]string{
	"connection_password_encryption": "description.DataCatalogEncryptionSettings.ConnectionPasswordEncryption",
	"encryption_at_rest":             "description.DataCatalogEncryptionSettings.EncryptionAtRest",
	"og_account_id":                  "metadata.SourceID",
}

func ListGlueDataCatalogEncryptionSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueDataCatalogEncryptionSettings")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataCatalogEncryptionSettings NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataCatalogEncryptionSettings NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataCatalogEncryptionSettings GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataCatalogEncryptionSettings GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataCatalogEncryptionSettings GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueDataCatalogEncryptionSettingsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueDataCatalogEncryptionSettingsFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataCatalogEncryptionSettings NewGlueDataCatalogEncryptionSettingsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueDataCatalogEncryptionSettings paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueDataCatalogEncryptionSettingsFilters = map[string]string{
	"connection_password_encryption": "description.DataCatalogEncryptionSettings.ConnectionPasswordEncryption",
	"encryption_at_rest":             "description.DataCatalogEncryptionSettings.EncryptionAtRest",
	"og_account_id":                  "metadata.SourceID",
}

func GetGlueDataCatalogEncryptionSettings(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueDataCatalogEncryptionSettings")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueDataCatalogEncryptionSettingsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueDataCatalogEncryptionSettingsFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueDataCatalogEncryptionSettings =============================

// ==========================  START: GlueDataQualityRuleset =============================

type GlueDataQualityRuleset struct {
	Description   aws.GlueDataQualityRulesetDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type GlueDataQualityRulesetHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  GlueDataQualityRuleset `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type GlueDataQualityRulesetHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []GlueDataQualityRulesetHit `json:"hits"`
}

type GlueDataQualityRulesetSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  GlueDataQualityRulesetHits `json:"hits"`
}

type GlueDataQualityRulesetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueDataQualityRulesetPaginator(filters []essdk.BoolFilter, limit *int64) (GlueDataQualityRulesetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_dataqualityruleset", filters, limit)
	if err != nil {
		return GlueDataQualityRulesetPaginator{}, err
	}

	p := GlueDataQualityRulesetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueDataQualityRulesetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueDataQualityRulesetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueDataQualityRulesetPaginator) NextPage(ctx context.Context) ([]GlueDataQualityRuleset, error) {
	var response GlueDataQualityRulesetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueDataQualityRuleset
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueDataQualityRulesetFilters = map[string]string{
	"created_on":            "description.DataQualityRuleset.CreatedOn",
	"database_name":         "description.DataQualityRuleset.TargetTable.DatabaseName",
	"description":           "description.DataQualityRuleset.Description",
	"og_account_id":         "metadata.SourceID",
	"last_modified_on":      "description.DataQualityRuleset.LastModifiedOn",
	"name":                  "description.DataQualityRuleset.Name",
	"recommendation_run_id": "description.DataQualityRuleset.RecommendationRunId",
	"rule_count":            "description.RulesetRuleCount",
	"rule_set":              "description.DataQualityRuleset.Ruleset",
	"table_name":            "description.DataQualityRuleset.TargetTable.TableName",
	"target_table":          "description.DataQualityRuleset.TargetTable",
	"title":                 "description.DataQualityRuleset.Name",
}

func ListGlueDataQualityRuleset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueDataQualityRuleset")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataQualityRuleset NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataQualityRuleset NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataQualityRuleset GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataQualityRuleset GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataQualityRuleset GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueDataQualityRulesetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueDataQualityRulesetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDataQualityRuleset NewGlueDataQualityRulesetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueDataQualityRuleset paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueDataQualityRulesetFilters = map[string]string{
	"created_on":            "description.DataQualityRuleset.CreatedOn",
	"database_name":         "description.DataQualityRuleset.TargetTable.DatabaseName",
	"description":           "description.DataQualityRuleset.Description",
	"og_account_id":         "metadata.SourceID",
	"last_modified_on":      "description.DataQualityRuleset.LastModifiedOn",
	"name":                  "description.DataQualityRuleset.Name",
	"recommendation_run_id": "description.DataQualityRuleset.RecommendationRunId",
	"rule_count":            "description.RulesetRuleCount",
	"rule_set":              "description.DataQualityRuleset.Ruleset",
	"table_name":            "description.DataQualityRuleset.TargetTable.TableName",
	"target_table":          "description.DataQualityRuleset.TargetTable",
	"title":                 "description.DataQualityRuleset.Name",
}

func GetGlueDataQualityRuleset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueDataQualityRuleset")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueDataQualityRulesetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueDataQualityRulesetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueDataQualityRuleset =============================

// ==========================  START: GlueDevEndpoint =============================

type GlueDevEndpoint struct {
	Description   aws.GlueDevEndpointDescription `json:"description"`
	Metadata      aws.Metadata                   `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type GlueDevEndpointHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  GlueDevEndpoint `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type GlueDevEndpointHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []GlueDevEndpointHit `json:"hits"`
}

type GlueDevEndpointSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  GlueDevEndpointHits `json:"hits"`
}

type GlueDevEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueDevEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (GlueDevEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_devendpoint", filters, limit)
	if err != nil {
		return GlueDevEndpointPaginator{}, err
	}

	p := GlueDevEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueDevEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueDevEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueDevEndpointPaginator) NextPage(ctx context.Context) ([]GlueDevEndpoint, error) {
	var response GlueDevEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueDevEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueDevEndpointFilters = map[string]string{
	"availability_zone":                      "description.DevEndpoint.AvailabilityZone",
	"created_timestamp":                      "description.DevEndpoint.CreatedTimestamp",
	"endpoint_name":                          "description.DevEndpoint.EndpointName",
	"extra_jars_s3_path":                     "description.DevEndpoint.ExtraJarsS3Path",
	"extra_python_libs_s3_path":              "description.DevEndpoint.ExtraPythonLibsS3Path",
	"failure_reason":                         "description.DevEndpoint.FailureReason",
	"glue_version":                           "description.DevEndpoint.GlueVersion",
	"og_account_id":                          "metadata.SourceID",
	"last_modified_timestamp":                "description.DevEndpoint.LastModifiedTimestamp",
	"last_update_status":                     "description.DevEndpoint.LastUpdateStatus",
	"number_of_nodes":                        "description.DevEndpoint.NumberOfNodes",
	"number_of_workers":                      "description.DevEndpoint.NumberOfWorkers",
	"private_address":                        "description.DevEndpoint.PrivateAddress",
	"public_address":                         "description.DevEndpoint.PublicAddress",
	"public_key":                             "description.DevEndpoint.PublicKey",
	"public_keys":                            "description.DevEndpoint.PublicKeys",
	"role_arn":                               "description.DevEndpoint.RoleArn",
	"security_configuration":                 "description.DevEndpoint.SecurityConfiguration",
	"security_group_ids":                     "description.DevEndpoint.SecurityGroupIds",
	"status":                                 "description.DevEndpoint.Status",
	"subnet_id":                              "description.DevEndpoint.SubnetId",
	"title":                                  "description.DevEndpoint.EndpointName",
	"vpc_id":                                 "description.DevEndpoint.VpcId",
	"worker_type":                            "description.DevEndpoint.WorkerType",
	"yarn_endpoint_address":                  "description.DevEndpoint.YarnEndpointAddress",
	"zeppelin_remote_spark_interpreter_port": "description.DevEndpoint.ZeppelinRemoteSparkInterpreterPort",
}

func ListGlueDevEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueDevEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDevEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDevEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDevEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDevEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDevEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueDevEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueDevEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueDevEndpoint NewGlueDevEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueDevEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueDevEndpointFilters = map[string]string{
	"availability_zone":                      "description.DevEndpoint.AvailabilityZone",
	"created_timestamp":                      "description.DevEndpoint.CreatedTimestamp",
	"endpoint_name":                          "description.DevEndpoint.EndpointName",
	"extra_jars_s3_path":                     "description.DevEndpoint.ExtraJarsS3Path",
	"extra_python_libs_s3_path":              "description.DevEndpoint.ExtraPythonLibsS3Path",
	"failure_reason":                         "description.DevEndpoint.FailureReason",
	"glue_version":                           "description.DevEndpoint.GlueVersion",
	"og_account_id":                          "metadata.SourceID",
	"last_modified_timestamp":                "description.DevEndpoint.LastModifiedTimestamp",
	"last_update_status":                     "description.DevEndpoint.LastUpdateStatus",
	"number_of_nodes":                        "description.DevEndpoint.NumberOfNodes",
	"number_of_workers":                      "description.DevEndpoint.NumberOfWorkers",
	"private_address":                        "description.DevEndpoint.PrivateAddress",
	"public_address":                         "description.DevEndpoint.PublicAddress",
	"public_key":                             "description.DevEndpoint.PublicKey",
	"public_keys":                            "description.DevEndpoint.PublicKeys",
	"role_arn":                               "description.DevEndpoint.RoleArn",
	"security_configuration":                 "description.DevEndpoint.SecurityConfiguration",
	"security_group_ids":                     "description.DevEndpoint.SecurityGroupIds",
	"status":                                 "description.DevEndpoint.Status",
	"subnet_id":                              "description.DevEndpoint.SubnetId",
	"title":                                  "description.DevEndpoint.EndpointName",
	"vpc_id":                                 "description.DevEndpoint.VpcId",
	"worker_type":                            "description.DevEndpoint.WorkerType",
	"yarn_endpoint_address":                  "description.DevEndpoint.YarnEndpointAddress",
	"zeppelin_remote_spark_interpreter_port": "description.DevEndpoint.ZeppelinRemoteSparkInterpreterPort",
}

func GetGlueDevEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueDevEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueDevEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueDevEndpointFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueDevEndpoint =============================

// ==========================  START: GlueJob =============================

type GlueJob struct {
	Description   aws.GlueJobDescription `json:"description"`
	Metadata      aws.Metadata           `json:"metadata"`
	ResourceJobID int                    `json:"resource_job_id"`
	SourceJobID   int                    `json:"source_job_id"`
	ResourceType  string                 `json:"resource_type"`
	SourceType    string                 `json:"source_type"`
	ID            string                 `json:"id"`
	ARN           string                 `json:"arn"`
	SourceID      string                 `json:"source_id"`
}

type GlueJobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  GlueJob       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type GlueJobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []GlueJobHit      `json:"hits"`
}

type GlueJobSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  GlueJobHits `json:"hits"`
}

type GlueJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueJobPaginator(filters []essdk.BoolFilter, limit *int64) (GlueJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_job", filters, limit)
	if err != nil {
		return GlueJobPaginator{}, err
	}

	p := GlueJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueJobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueJobPaginator) NextPage(ctx context.Context) ([]GlueJob, error) {
	var response GlueJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueJobFilters = map[string]string{
	"allocated_capacity":        "description.Job.AllocatedCapacity",
	"command":                   "description.Job.Command",
	"connections":               "description.Job.Connections",
	"created_on":                "description.Job.CreatedOn",
	"default_arguments":         "description.Job.DefaultArguments",
	"description":               "description.Job.Description",
	"execution_property":        "description.Job.ExecutionProperty",
	"glue_version":              "description.Job.GlueVersion",
	"job_bookmark":              "description.Bookmark",
	"og_account_id":             "metadata.SourceID",
	"last_modified_on":          "description.Job.LastModifiedOn",
	"log_uri":                   "description.Job.LogUri",
	"max_capacity":              "description.Job.MaxCapacity",
	"max_retries":               "description.Job.MaxRetries",
	"name":                      "description.Job.Name",
	"non_overridable_arguments": "description.Job.NonOverridableArguments",
	"notification_property":     "description.Job.NotificationProperty",
	"number_of_workers":         "description.Job.NumberOfWorkers",
	"role":                      "description.Job.Role",
	"security_configuration":    "description.Job.SecurityConfiguration",
	"timeout":                   "description.Job.Timeout",
	"title":                     "description.Job.Name",
	"worker_type":               "description.Job.WorkerType",
}

func ListGlueJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueJob NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueJob NewGlueJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueJobFilters = map[string]string{
	"allocated_capacity":        "description.Job.AllocatedCapacity",
	"command":                   "description.Job.Command",
	"connections":               "description.Job.Connections",
	"created_on":                "description.Job.CreatedOn",
	"default_arguments":         "description.Job.DefaultArguments",
	"description":               "description.Job.Description",
	"execution_property":        "description.Job.ExecutionProperty",
	"glue_version":              "description.Job.GlueVersion",
	"job_bookmark":              "description.Bookmark",
	"og_account_id":             "metadata.SourceID",
	"last_modified_on":          "description.Job.LastModifiedOn",
	"log_uri":                   "description.Job.LogUri",
	"max_capacity":              "description.Job.MaxCapacity",
	"max_retries":               "description.Job.MaxRetries",
	"name":                      "description.Job.Name",
	"non_overridable_arguments": "description.Job.NonOverridableArguments",
	"notification_property":     "description.Job.NotificationProperty",
	"number_of_workers":         "description.Job.NumberOfWorkers",
	"role":                      "description.Job.Role",
	"security_configuration":    "description.Job.SecurityConfiguration",
	"timeout":                   "description.Job.Timeout",
	"title":                     "description.Job.Name",
	"worker_type":               "description.Job.WorkerType",
}

func GetGlueJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueJob =============================

// ==========================  START: GlueSecurityConfiguration =============================

type GlueSecurityConfiguration struct {
	Description   aws.GlueSecurityConfigurationDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type GlueSecurityConfigurationHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  GlueSecurityConfiguration `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type GlueSecurityConfigurationHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []GlueSecurityConfigurationHit `json:"hits"`
}

type GlueSecurityConfigurationSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  GlueSecurityConfigurationHits `json:"hits"`
}

type GlueSecurityConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGlueSecurityConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (GlueSecurityConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_glue_securityconfiguration", filters, limit)
	if err != nil {
		return GlueSecurityConfigurationPaginator{}, err
	}

	p := GlueSecurityConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GlueSecurityConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GlueSecurityConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GlueSecurityConfigurationPaginator) NextPage(ctx context.Context) ([]GlueSecurityConfiguration, error) {
	var response GlueSecurityConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GlueSecurityConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGlueSecurityConfigurationFilters = map[string]string{
	"cloud_watch_encryption":   "description.SecurityConfiguration.EncryptionConfiguration.CloudWatchEncryption",
	"created_time_stamp":       "description.SecurityConfiguration.CreatedTimeStamp",
	"job_bookmarks_encryption": "description.SecurityConfiguration.EncryptionConfiguration.JobBookmarksEncryption",
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.SecurityConfiguration.Name",
	"s3_encryption":            "description.SecurityConfiguration.EncryptionConfiguration.S3Encryption",
	"title":                    "description.SecurityConfiguration.Name",
}

func ListGlueSecurityConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGlueSecurityConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueSecurityConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueSecurityConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueSecurityConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueSecurityConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueSecurityConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGlueSecurityConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listGlueSecurityConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGlueSecurityConfiguration NewGlueSecurityConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGlueSecurityConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGlueSecurityConfigurationFilters = map[string]string{
	"cloud_watch_encryption":   "description.SecurityConfiguration.EncryptionConfiguration.CloudWatchEncryption",
	"created_time_stamp":       "description.SecurityConfiguration.CreatedTimeStamp",
	"job_bookmarks_encryption": "description.SecurityConfiguration.EncryptionConfiguration.JobBookmarksEncryption",
	"og_account_id":            "metadata.SourceID",
	"name":                     "description.SecurityConfiguration.Name",
	"s3_encryption":            "description.SecurityConfiguration.EncryptionConfiguration.S3Encryption",
	"title":                    "description.SecurityConfiguration.Name",
}

func GetGlueSecurityConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGlueSecurityConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGlueSecurityConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getGlueSecurityConfigurationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GlueSecurityConfiguration =============================

// ==========================  START: HealthEvent =============================

type HealthEvent struct {
	Description   aws.HealthEventDescription `json:"description"`
	Metadata      aws.Metadata               `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type HealthEventHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  HealthEvent   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type HealthEventHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []HealthEventHit  `json:"hits"`
}

type HealthEventSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  HealthEventHits `json:"hits"`
}

type HealthEventPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHealthEventPaginator(filters []essdk.BoolFilter, limit *int64) (HealthEventPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_health_event", filters, limit)
	if err != nil {
		return HealthEventPaginator{}, err
	}

	p := HealthEventPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HealthEventPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HealthEventPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HealthEventPaginator) NextPage(ctx context.Context) ([]HealthEvent, error) {
	var response HealthEventSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HealthEvent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHealthEventFilters = map[string]string{
	"arn":                 "description.Event.Arn",
	"availability_zone":   "description.Event.AvailabilityZone",
	"end_time":            "description.Event.EndTime",
	"event_scope_code":    "description.Event.EventScopeCode",
	"event_type_category": "description.Event.EventTypeCategory",
	"event_type_code":     "description.Event.EventTypeCode",
	"og_account_id":       "metadata.SourceID",
	"last_updated_time":   "description.Event.LastUpdatedTime",
	"service":             "description.Event.Service",
	"start_time":          "description.Event.StartTime",
	"status_code":         "description.Event.StatusCode",
}

func ListHealthEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHealthEvent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthEvent NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthEvent NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthEvent GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHealthEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, listHealthEventFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthEvent NewHealthEventPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHealthEvent paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHealthEventFilters = map[string]string{
	"arn":                 "description.Event.Arn",
	"availability_zone":   "description.Event.AvailabilityZone",
	"end_time":            "description.Event.EndTime",
	"event_scope_code":    "description.Event.EventScopeCode",
	"event_type_category": "description.Event.EventTypeCategory",
	"event_type_code":     "description.Event.EventTypeCode",
	"og_account_id":       "metadata.SourceID",
	"last_updated_time":   "description.Event.LastUpdatedTime",
	"service":             "description.Event.Service",
	"start_time":          "description.Event.StartTime",
	"status_code":         "description.Event.StatusCode",
}

func GetHealthEvent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHealthEvent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHealthEventPaginator(essdk.BuildFilter(ctx, d.QueryContext, getHealthEventFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: HealthEvent =============================

// ==========================  START: HealthAffectedEntity =============================

type HealthAffectedEntity struct {
	Description   aws.HealthAffectedEntityDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type HealthAffectedEntityHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  HealthAffectedEntity `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type HealthAffectedEntityHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []HealthAffectedEntityHit `json:"hits"`
}

type HealthAffectedEntitySearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  HealthAffectedEntityHits `json:"hits"`
}

type HealthAffectedEntityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHealthAffectedEntityPaginator(filters []essdk.BoolFilter, limit *int64) (HealthAffectedEntityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_health_affectedentity", filters, limit)
	if err != nil {
		return HealthAffectedEntityPaginator{}, err
	}

	p := HealthAffectedEntityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HealthAffectedEntityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HealthAffectedEntityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HealthAffectedEntityPaginator) NextPage(ctx context.Context) ([]HealthAffectedEntity, error) {
	var response HealthAffectedEntitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HealthAffectedEntity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHealthAffectedEntityFilters = map[string]string{
	"arn":               "description.Entity.EntityArn",
	"entity_url":        "description.Entity.EntityUrl",
	"entity_value":      "description.Entity.EntityValue",
	"event_arn":         "description.Entity.EntityArn",
	"og_account_id":     "metadata.SourceID",
	"last_updated_time": "description.Entity.LastUpdatedTime",
	"status_code":       "description.Entity.StatusCode",
	"tags":              "description.Entity.Tags",
}

func ListHealthAffectedEntity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHealthAffectedEntity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthAffectedEntity NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthAffectedEntity NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthAffectedEntity GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthAffectedEntity GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthAffectedEntity GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHealthAffectedEntityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listHealthAffectedEntityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthAffectedEntity NewHealthAffectedEntityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHealthAffectedEntity paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHealthAffectedEntityFilters = map[string]string{
	"arn":               "description.Entity.EntityArn",
	"entity_url":        "description.Entity.EntityUrl",
	"entity_value":      "description.Entity.EntityValue",
	"event_arn":         "description.Entity.EntityArn",
	"og_account_id":     "metadata.SourceID",
	"last_updated_time": "description.Entity.LastUpdatedTime",
	"status_code":       "description.Entity.StatusCode",
	"tags":              "description.Entity.Tags",
}

func GetHealthAffectedEntity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHealthAffectedEntity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHealthAffectedEntityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getHealthAffectedEntityFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: HealthAffectedEntity =============================

// ==========================  START: IdentityStoreGroup =============================

type IdentityStoreGroup struct {
	Description   aws.IdentityStoreGroupDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type IdentityStoreGroupHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  IdentityStoreGroup `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type IdentityStoreGroupHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []IdentityStoreGroupHit `json:"hits"`
}

type IdentityStoreGroupSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  IdentityStoreGroupHits `json:"hits"`
}

type IdentityStoreGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIdentityStoreGroupPaginator(filters []essdk.BoolFilter, limit *int64) (IdentityStoreGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_identitystore_group", filters, limit)
	if err != nil {
		return IdentityStoreGroupPaginator{}, err
	}

	p := IdentityStoreGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IdentityStoreGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IdentityStoreGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IdentityStoreGroupPaginator) NextPage(ctx context.Context) ([]IdentityStoreGroup, error) {
	var response IdentityStoreGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IdentityStoreGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIdentityStoreGroupFilters = map[string]string{
	"external_ids":      "description.Group.ExternalIds",
	"id":                "description.Group.GroupId",
	"identity_store_id": "description.Group.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.Group.DisplayName",
	"title":             "description.Group.DisplayName",
}

func ListIdentityStoreGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIdentityStoreGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIdentityStoreGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIdentityStoreGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroup NewIdentityStoreGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIdentityStoreGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIdentityStoreGroupFilters = map[string]string{
	"external_ids":      "description.Group.ExternalIds",
	"id":                "description.Group.GroupId",
	"identity_store_id": "description.Group.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.Group.DisplayName",
	"title":             "description.Group.DisplayName",
}

func GetIdentityStoreGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIdentityStoreGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIdentityStoreGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIdentityStoreGroupFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IdentityStoreGroup =============================

// ==========================  START: IdentityStoreUser =============================

type IdentityStoreUser struct {
	Description   aws.IdentityStoreUserDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type IdentityStoreUserHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  IdentityStoreUser `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type IdentityStoreUserHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []IdentityStoreUserHit `json:"hits"`
}

type IdentityStoreUserSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  IdentityStoreUserHits `json:"hits"`
}

type IdentityStoreUserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIdentityStoreUserPaginator(filters []essdk.BoolFilter, limit *int64) (IdentityStoreUserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_identitystore_user", filters, limit)
	if err != nil {
		return IdentityStoreUserPaginator{}, err
	}

	p := IdentityStoreUserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IdentityStoreUserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IdentityStoreUserPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IdentityStoreUserPaginator) NextPage(ctx context.Context) ([]IdentityStoreUser, error) {
	var response IdentityStoreUserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IdentityStoreUser
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIdentityStoreUserFilters = map[string]string{
	"email":             "description.PrimaryEmail",
	"external_ids":      "description.User.ExternalIds",
	"id":                "description.User.UserId",
	"identity_store_id": "description.User.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.User.DisplayName",
	"title":             "description.User.Title",
	"user_name":         "description.User.UserName",
}

func ListIdentityStoreUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIdentityStoreUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreUser NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreUser NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIdentityStoreUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIdentityStoreUserFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreUser NewIdentityStoreUserPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIdentityStoreUser paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIdentityStoreUserFilters = map[string]string{
	"email":             "description.PrimaryEmail",
	"external_ids":      "description.User.ExternalIds",
	"id":                "description.User.UserId",
	"identity_store_id": "description.User.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"name":              "description.User.DisplayName",
	"title":             "description.User.Title",
	"user_name":         "description.User.UserName",
}

func GetIdentityStoreUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIdentityStoreUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIdentityStoreUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIdentityStoreUserFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IdentityStoreUser =============================

// ==========================  START: IdentityStoreGroupMembership =============================

type IdentityStoreGroupMembership struct {
	Description   aws.IdentityStoreGroupMembershipDescription `json:"description"`
	Metadata      aws.Metadata                                `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type IdentityStoreGroupMembershipHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  IdentityStoreGroupMembership `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type IdentityStoreGroupMembershipHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []IdentityStoreGroupMembershipHit `json:"hits"`
}

type IdentityStoreGroupMembershipSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  IdentityStoreGroupMembershipHits `json:"hits"`
}

type IdentityStoreGroupMembershipPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIdentityStoreGroupMembershipPaginator(filters []essdk.BoolFilter, limit *int64) (IdentityStoreGroupMembershipPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_identitystore_groupmembership", filters, limit)
	if err != nil {
		return IdentityStoreGroupMembershipPaginator{}, err
	}

	p := IdentityStoreGroupMembershipPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IdentityStoreGroupMembershipPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IdentityStoreGroupMembershipPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IdentityStoreGroupMembershipPaginator) NextPage(ctx context.Context) ([]IdentityStoreGroupMembership, error) {
	var response IdentityStoreGroupMembershipSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IdentityStoreGroupMembership
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIdentityStoreGroupMembershipFilters = map[string]string{
	"group_id":          "description.GroupId",
	"identity_store_id": "description.Group.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"member_id":         "description.MemberId.Value",
	"membership_id":     "description.MembershipId",
	"title":             "description.MembershipId",
}

func ListIdentityStoreGroupMembership(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIdentityStoreGroupMembership")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroupMembership NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroupMembership NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroupMembership GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroupMembership GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroupMembership GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIdentityStoreGroupMembershipPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIdentityStoreGroupMembershipFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIdentityStoreGroupMembership NewIdentityStoreGroupMembershipPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIdentityStoreGroupMembership paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIdentityStoreGroupMembershipFilters = map[string]string{
	"group_id":          "description.GroupId",
	"id":                "description.Group.GroupId",
	"identity_store_id": "description.Group.IdentityStoreId",
	"og_account_id":     "metadata.SourceID",
	"member_id":         "description.MemberId.Value",
	"membership_id":     "description.MembershipId",
	"title":             "description.MembershipId",
}

func GetIdentityStoreGroupMembership(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIdentityStoreGroupMembership")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIdentityStoreGroupMembershipPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIdentityStoreGroupMembershipFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IdentityStoreGroupMembership =============================

// ==========================  START: InspectorAssessmentRun =============================

type InspectorAssessmentRun struct {
	Description   aws.InspectorAssessmentRunDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type InspectorAssessmentRunHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  InspectorAssessmentRun `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type InspectorAssessmentRunHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []InspectorAssessmentRunHit `json:"hits"`
}

type InspectorAssessmentRunSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  InspectorAssessmentRunHits `json:"hits"`
}

type InspectorAssessmentRunPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorAssessmentRunPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorAssessmentRunPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_assessmentrun", filters, limit)
	if err != nil {
		return InspectorAssessmentRunPaginator{}, err
	}

	p := InspectorAssessmentRunPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorAssessmentRunPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorAssessmentRunPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p InspectorAssessmentRunPaginator) NextPage(ctx context.Context) ([]InspectorAssessmentRun, error) {
	var response InspectorAssessmentRunSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorAssessmentRun
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorAssessmentRunFilters = map[string]string{
	"arn":                          "description.AssessmentRun.Arn",
	"assessment_template_arn":      "description.AssessmentRun.AssessmentTemplateArn",
	"completed_at":                 "description.AssessmentRun.CompletedAt",
	"created_at":                   "description.AssessmentRun.CreatedAt",
	"data_collected":               "description.AssessmentRun.DataCollected",
	"duration_in_seconds":          "description.AssessmentRun.DurationInSeconds",
	"finding_counts":               "description.AssessmentRun.FindingCounts",
	"og_account_id":                "metadata.SourceID",
	"name":                         "description.AssessmentRun.Name",
	"notifications":                "description.AssessmentRun.Notifications",
	"rules_package_arns":           "description.AssessmentRun.RulesPackageArns",
	"started_at":                   "description.AssessmentRun.StartedAt",
	"state":                        "description.AssessmentRun.State",
	"state_changed_at":             "description.AssessmentRun.StateChangedAt",
	"state_changes":                "description.AssessmentRun.StateChanges",
	"title":                        "description.AssessmentRun.Name",
	"user_attributes_for_findings": "description.AssessmentRun.UserAttributesForFindings",
}

func ListInspectorAssessmentRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorAssessmentRun")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentRun NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentRun NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentRun GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspectorAssessmentRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspectorAssessmentRunFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentRun NewInspectorAssessmentRunPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspectorAssessmentRun paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspectorAssessmentRunFilters = map[string]string{
	"arn":                          "description.AssessmentRun.Arn",
	"assessment_template_arn":      "description.AssessmentRun.AssessmentTemplateArn",
	"completed_at":                 "description.AssessmentRun.CompletedAt",
	"created_at":                   "description.AssessmentRun.CreatedAt",
	"data_collected":               "description.AssessmentRun.DataCollected",
	"duration_in_seconds":          "description.AssessmentRun.DurationInSeconds",
	"finding_counts":               "description.AssessmentRun.FindingCounts",
	"og_account_id":                "metadata.SourceID",
	"name":                         "description.AssessmentRun.Name",
	"notifications":                "description.AssessmentRun.Notifications",
	"rules_package_arns":           "description.AssessmentRun.RulesPackageArns",
	"started_at":                   "description.AssessmentRun.StartedAt",
	"state":                        "description.AssessmentRun.State",
	"state_changed_at":             "description.AssessmentRun.StateChangedAt",
	"state_changes":                "description.AssessmentRun.StateChanges",
	"title":                        "description.AssessmentRun.Name",
	"user_attributes_for_findings": "description.AssessmentRun.UserAttributesForFindings",
}

func GetInspectorAssessmentRun(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorAssessmentRun")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspectorAssessmentRunPaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspectorAssessmentRunFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: InspectorAssessmentRun =============================

// ==========================  START: InspectorAssessmentTarget =============================

type InspectorAssessmentTarget struct {
	Description   aws.InspectorAssessmentTargetDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type InspectorAssessmentTargetHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  InspectorAssessmentTarget `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type InspectorAssessmentTargetHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []InspectorAssessmentTargetHit `json:"hits"`
}

type InspectorAssessmentTargetSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  InspectorAssessmentTargetHits `json:"hits"`
}

type InspectorAssessmentTargetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorAssessmentTargetPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorAssessmentTargetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_assessmenttarget", filters, limit)
	if err != nil {
		return InspectorAssessmentTargetPaginator{}, err
	}

	p := InspectorAssessmentTargetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorAssessmentTargetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorAssessmentTargetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p InspectorAssessmentTargetPaginator) NextPage(ctx context.Context) ([]InspectorAssessmentTarget, error) {
	var response InspectorAssessmentTargetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorAssessmentTarget
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorAssessmentTargetFilters = map[string]string{
	"arn":                "description.AssessmentTarget.Arn",
	"created_at":         "description.AssessmentTarget.CreatedAt",
	"og_account_id":      "metadata.SourceID",
	"name":               "description.AssessmentTarget.Name",
	"resource_group_arn": "description.AssessmentTarget.ResourceGroupArn",
	"title":              "description.AssessmentTarget.Name",
	"updated_at":         "description.AssessmentTarget.UpdatedAt",
}

func ListInspectorAssessmentTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorAssessmentTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTarget NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTarget NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTarget GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspectorAssessmentTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspectorAssessmentTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTarget NewInspectorAssessmentTargetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspectorAssessmentTarget paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspectorAssessmentTargetFilters = map[string]string{
	"arn":                "description.AssessmentTarget.Arn",
	"created_at":         "description.AssessmentTarget.CreatedAt",
	"og_account_id":      "metadata.SourceID",
	"name":               "description.AssessmentTarget.Name",
	"resource_group_arn": "description.AssessmentTarget.ResourceGroupArn",
	"title":              "description.AssessmentTarget.Name",
	"updated_at":         "description.AssessmentTarget.UpdatedAt",
}

func GetInspectorAssessmentTarget(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorAssessmentTarget")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspectorAssessmentTargetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspectorAssessmentTargetFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: InspectorAssessmentTarget =============================

// ==========================  START: InspectorAssessmentTemplate =============================

type InspectorAssessmentTemplate struct {
	Description   aws.InspectorAssessmentTemplateDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type InspectorAssessmentTemplateHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  InspectorAssessmentTemplate `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type InspectorAssessmentTemplateHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []InspectorAssessmentTemplateHit `json:"hits"`
}

type InspectorAssessmentTemplateSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  InspectorAssessmentTemplateHits `json:"hits"`
}

type InspectorAssessmentTemplatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorAssessmentTemplatePaginator(filters []essdk.BoolFilter, limit *int64) (InspectorAssessmentTemplatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_assessmenttemplate", filters, limit)
	if err != nil {
		return InspectorAssessmentTemplatePaginator{}, err
	}

	p := InspectorAssessmentTemplatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorAssessmentTemplatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorAssessmentTemplatePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p InspectorAssessmentTemplatePaginator) NextPage(ctx context.Context) ([]InspectorAssessmentTemplate, error) {
	var response InspectorAssessmentTemplateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorAssessmentTemplate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorAssessmentTemplateFilters = map[string]string{
	"arn":                          "description.AssessmentTemplate.Arn",
	"assessment_run_count":         "description.AssessmentTemplate.AssessmentRunCount",
	"assessment_target_arn":        "description.AssessmentTemplate.AssessmentTargetArn",
	"created_at":                   "description.AssessmentTemplate.CreatedAt",
	"duration_in_seconds":          "description.AssessmentTemplate.DurationInSeconds",
	"event_subscriptions":          "description.EventSubscriptions",
	"og_account_id":                "metadata.SourceID",
	"last_assessment_run_arn":      "description.AssessmentTemplate.LastAssessmentRunArn",
	"name":                         "description.AssessmentTemplate.Name",
	"rules_package_arns":           "description.AssessmentTemplate.RulesPackageArns",
	"tags_src":                     "description.Tags",
	"title":                        "description.AssessmentTemplate.Name",
	"user_attributes_for_findings": "description.AssessmentTemplate.UserAttributesForFindings",
}

func ListInspectorAssessmentTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorAssessmentTemplate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTemplate NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTemplate NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTemplate GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTemplate GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTemplate GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspectorAssessmentTemplatePaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspectorAssessmentTemplateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorAssessmentTemplate NewInspectorAssessmentTemplatePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspectorAssessmentTemplate paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspectorAssessmentTemplateFilters = map[string]string{
	"arn":                          "description.AssessmentTemplate.Arn",
	"assessment_run_count":         "description.AssessmentTemplate.AssessmentRunCount",
	"assessment_target_arn":        "description.AssessmentTemplate.AssessmentTargetArn",
	"created_at":                   "description.AssessmentTemplate.CreatedAt",
	"duration_in_seconds":          "description.AssessmentTemplate.DurationInSeconds",
	"event_subscriptions":          "description.EventSubscriptions",
	"og_account_id":                "metadata.SourceID",
	"last_assessment_run_arn":      "description.AssessmentTemplate.LastAssessmentRunArn",
	"name":                         "description.AssessmentTemplate.Name",
	"rules_package_arns":           "description.AssessmentTemplate.RulesPackageArns",
	"tags_src":                     "description.Tags",
	"title":                        "description.AssessmentTemplate.Name",
	"user_attributes_for_findings": "description.AssessmentTemplate.UserAttributesForFindings",
}

func GetInspectorAssessmentTemplate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorAssessmentTemplate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspectorAssessmentTemplatePaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspectorAssessmentTemplateFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: InspectorAssessmentTemplate =============================

// ==========================  START: InspectorExclusion =============================

type InspectorExclusion struct {
	Description   aws.InspectorExclusionDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type InspectorExclusionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  InspectorExclusion `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type InspectorExclusionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []InspectorExclusionHit `json:"hits"`
}

type InspectorExclusionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  InspectorExclusionHits `json:"hits"`
}

type InspectorExclusionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorExclusionPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorExclusionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_exclusion", filters, limit)
	if err != nil {
		return InspectorExclusionPaginator{}, err
	}

	p := InspectorExclusionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorExclusionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorExclusionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p InspectorExclusionPaginator) NextPage(ctx context.Context) ([]InspectorExclusion, error) {
	var response InspectorExclusionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorExclusion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorExclusionFilters = map[string]string{
	"arn":                "description.Exclusion.Arn",
	"assessment_run_arn": "description.Exclusion.Arn",
	"attributes":         "description.Exclusion.Attributes",
	"description":        "description.Exclusion.Description",
	"og_account_id":      "metadata.SourceID",
	"recommendation":     "description.Exclusion.Recommendation",
	"scopes":             "description.Exclusion.Scopes",
	"title":              "description.Exclusion.Title",
}

func ListInspectorExclusion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorExclusion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorExclusion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorExclusion NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorExclusion GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorExclusion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorExclusion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspectorExclusionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspectorExclusionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorExclusion NewInspectorExclusionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspectorExclusion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspectorExclusionFilters = map[string]string{
	"arn":                "description.Exclusion.Arn",
	"assessment_run_arn": "description.AssessmentRunArn",
	"attributes":         "description.Exclusion.Attributes",
	"description":        "description.Exclusion.Description",
	"og_account_id":      "metadata.SourceID",
	"recommendation":     "description.Exclusion.Recommendation",
	"scopes":             "description.Exclusion.Scopes",
	"title":              "description.Exclusion.Title",
}

func GetInspectorExclusion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorExclusion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspectorExclusionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspectorExclusionFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: InspectorExclusion =============================

// ==========================  START: InspectorFinding =============================

type InspectorFinding struct {
	Description   aws.InspectorFindingDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type InspectorFindingHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  InspectorFinding `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type InspectorFindingHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []InspectorFindingHit `json:"hits"`
}

type InspectorFindingSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  InspectorFindingHits `json:"hits"`
}

type InspectorFindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspectorFindingPaginator(filters []essdk.BoolFilter, limit *int64) (InspectorFindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector_finding", filters, limit)
	if err != nil {
		return InspectorFindingPaginator{}, err
	}

	p := InspectorFindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p InspectorFindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p InspectorFindingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p InspectorFindingPaginator) NextPage(ctx context.Context) ([]InspectorFinding, error) {
	var response InspectorFindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []InspectorFinding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspectorFindingFilters = map[string]string{
	"agent_id":                "description.Finding.AssetAttributes.AgentId",
	"arn":                     "description.Finding.Arn",
	"asset_attributes":        "description.Finding.AssetAttributes",
	"asset_type":              "description.Finding.AssetType",
	"attributes":              "description.Finding.Attributes",
	"auto_scaling_group":      "description.Finding.AssetAttributes.AutoScalingGroup",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"description":             "description.Finding.Description",
	"failed_items":            "description.FailedItems",
	"id":                      "description.Finding.Id",
	"indicator_of_compromise": "description.Finding.IndicatorOfCompromise",
	"og_account_id":           "metadata.SourceID",
	"numeric_severity":        "description.Finding.NumericSeverity",
	"recommendation":          "description.Finding.Recommendation",
	"schema_version":          "description.Finding.SchemaVersion",
	"service":                 "description.Finding.Service",
	"service_attributes":      "description.Finding.ServiceAttributes",
	"severity":                "description.Finding.Severity",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_attributes":         "description.Finding.UserAttributes",
}

func ListInspectorFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspectorFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorFinding NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorFinding NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorFinding GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspectorFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspectorFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspectorFinding NewInspectorFindingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspectorFinding paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspectorFindingFilters = map[string]string{
	"agent_id":                "description.Finding.AssetAttributes.AgentId",
	"arn":                     "description.Finding.Arn",
	"asset_attributes":        "description.Finding.AssetAttributes",
	"asset_type":              "description.Finding.AssetType",
	"attributes":              "description.Finding.Attributes",
	"auto_scaling_group":      "description.Finding.AssetAttributes.AutoScalingGroup",
	"confidence":              "description.Finding.Confidence",
	"created_at":              "description.Finding.CreatedAt",
	"description":             "description.Finding.Description",
	"failed_items":            "description.FailedItems",
	"id":                      "description.Finding.Id",
	"indicator_of_compromise": "description.Finding.IndicatorOfCompromise",
	"og_account_id":           "metadata.SourceID",
	"numeric_severity":        "description.Finding.NumericSeverity",
	"recommendation":          "description.Finding.Recommendation",
	"schema_version":          "description.Finding.SchemaVersion",
	"service":                 "description.Finding.Service",
	"service_attributes":      "description.Finding.ServiceAttributes",
	"severity":                "description.Finding.Severity",
	"title":                   "description.Finding.Title",
	"updated_at":              "description.Finding.UpdatedAt",
	"user_attributes":         "description.Finding.UserAttributes",
}

func GetInspectorFinding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspectorFinding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspectorFindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspectorFindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: InspectorFinding =============================

// ==========================  START: Inspector2Coverage =============================

type Inspector2Coverage struct {
	Description   aws.Inspector2CoverageDescription `json:"description"`
	Metadata      aws.Metadata                      `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type Inspector2CoverageHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  Inspector2Coverage `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type Inspector2CoverageHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []Inspector2CoverageHit `json:"hits"`
}

type Inspector2CoverageSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  Inspector2CoverageHits `json:"hits"`
}

type Inspector2CoveragePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspector2CoveragePaginator(filters []essdk.BoolFilter, limit *int64) (Inspector2CoveragePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector2_coverage", filters, limit)
	if err != nil {
		return Inspector2CoveragePaginator{}, err
	}

	p := Inspector2CoveragePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Inspector2CoveragePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Inspector2CoveragePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Inspector2CoveragePaginator) NextPage(ctx context.Context) ([]Inspector2Coverage, error) {
	var response Inspector2CoverageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Inspector2Coverage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspector2CoverageFilters = map[string]string{
	"account_id":                    "description.CoveredResource.AccountId",
	"ec2_ami_id":                    "description.CoveredResource.ResourceMetadata.Ec2.AmiId",
	"ec2_instance_tags":             "description.CoveredResource.ResourceMetadata.Ec2.Tags",
	"ec2_platform":                  "description.CoveredResource.ResourceMetadata.Ec2.Platform",
	"ecr_image_tag":                 "description.CoveredResource.ResourceMetadata.EcrImage.Tags",
	"ecr_image_tags":                "description.CoveredResource.ResourceMetadata.EcrImage.Tags",
	"ecr_repository_name":           "description.CoveredResource.ResourceMetadata.EcrRepository.Name",
	"ecr_repository_scan_frequency": "description.CoveredResource.ResourceMetadata.EcrRepository.ScanFrequency",
	"og_account_id":                 "metadata.SourceID",
	"lambda_function_layers":        "description.CoveredResource.ResourceMetadata.LambdaFunction.Layers",
	"lambda_function_name":          "description.CoveredResource.ResourceMetadata.LambdaFunction.FunctionName",
	"lambda_function_runtime":       "description.CoveredResource.ResourceMetadata.LambdaFunction.Runtime",
	"lambda_function_tags":          "description.CoveredResource.ResourceMetadata.LambdaFunction.FunctionTags",
	"resource_id":                   "description.CoveredResource.ResourceId",
	"resource_type":                 "description.CoveredResource.ResourceType",
	"scan_status_code":              "description.CoveredResource.ScanStatus.StatusCode",
	"scan_status_reason":            "description.CoveredResource.ScanStatus.Reason",
	"scan_type":                     "description.CoveredResource.ScanType",
	"source_account_id":             "description.CoveredResource.AccountId",
}

func ListInspector2Coverage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspector2Coverage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Coverage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Coverage NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Coverage GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Coverage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Coverage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspector2CoveragePaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspector2CoverageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Coverage NewInspector2CoveragePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspector2Coverage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspector2CoverageFilters = map[string]string{
	"ec2_ami_id":                    "description.CoveredResource.ResourceMetadata.Ec2.AmiId",
	"ec2_instance_tags":             "description.CoveredResource.ResourceMetadata.Ec2.Tags",
	"ec2_platform":                  "description.CoveredResource.ResourceMetadata.Ec2.Platform",
	"ecr_image_tag":                 "description.CoveredResource.ResourceMetadata.EcrImage.Tags",
	"ecr_image_tags":                "description.CoveredResource.ResourceMetadata.EcrImage.Tags",
	"ecr_repository_name":           "description.CoveredResource.ResourceMetadata.EcrRepository.Name",
	"ecr_repository_scan_frequency": "description.CoveredResource.ResourceMetadata.EcrRepository.ScanFrequency",
	"og_account_id":                 "metadata.SourceID",
	"lambda_function_layers":        "description.CoveredResource.ResourceMetadata.LambdaFunction.Layers",
	"lambda_function_name":          "description.CoveredResource.ResourceMetadata.LambdaFunction.FunctionName",
	"lambda_function_runtime":       "description.CoveredResource.ResourceMetadata.LambdaFunction.Runtime",
	"lambda_function_tags":          "description.CoveredResource.ResourceMetadata.LambdaFunction.FunctionTags",
	"resource_id":                   "description.CoveredResource.ResourceId",
	"resource_type":                 "description.CoveredResource.ResourceType",
	"scan_status_code":              "description.CoveredResource.ScanStatus.StatusCode",
	"scan_status_reason":            "description.CoveredResource.ScanStatus.Reason",
	"scan_type":                     "description.CoveredResource.ScanType",
	"source_account_id":             "description.CoveredResource.AccountId",
}

func GetInspector2Coverage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspector2Coverage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspector2CoveragePaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspector2CoverageFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Inspector2Coverage =============================

// ==========================  START: Inspector2CoverageStatistic =============================

type Inspector2CoverageStatistic struct {
	Description   aws.Inspector2CoverageStatisticDescription `json:"description"`
	Metadata      aws.Metadata                               `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type Inspector2CoverageStatisticHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  Inspector2CoverageStatistic `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type Inspector2CoverageStatisticHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []Inspector2CoverageStatisticHit `json:"hits"`
}

type Inspector2CoverageStatisticSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  Inspector2CoverageStatisticHits `json:"hits"`
}

type Inspector2CoverageStatisticPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspector2CoverageStatisticPaginator(filters []essdk.BoolFilter, limit *int64) (Inspector2CoverageStatisticPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector2_coveragestatistics", filters, limit)
	if err != nil {
		return Inspector2CoverageStatisticPaginator{}, err
	}

	p := Inspector2CoverageStatisticPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Inspector2CoverageStatisticPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Inspector2CoverageStatisticPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Inspector2CoverageStatisticPaginator) NextPage(ctx context.Context) ([]Inspector2CoverageStatistic, error) {
	var response Inspector2CoverageStatisticSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Inspector2CoverageStatistic
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspector2CoverageStatisticFilters = map[string]string{
	"counts_by_group": "description.Counts",
	"og_account_id":   "metadata.SourceID",
	"total_counts":    "description.TotalCounts",
}

func ListInspector2CoverageStatistic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspector2CoverageStatistic")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2CoverageStatistic NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2CoverageStatistic NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2CoverageStatistic GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2CoverageStatistic GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2CoverageStatistic GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspector2CoverageStatisticPaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspector2CoverageStatisticFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2CoverageStatistic NewInspector2CoverageStatisticPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspector2CoverageStatistic paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspector2CoverageStatisticFilters = map[string]string{
	"counts_by_group": "description.Counts",
	"og_account_id":   "metadata.SourceID",
	"total_counts":    "description.TotalCounts",
}

func GetInspector2CoverageStatistic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspector2CoverageStatistic")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspector2CoverageStatisticPaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspector2CoverageStatisticFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Inspector2CoverageStatistic =============================

// ==========================  START: Inspector2Member =============================

type Inspector2Member struct {
	Description   aws.Inspector2MemberDescription `json:"description"`
	Metadata      aws.Metadata                    `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type Inspector2MemberHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  Inspector2Member `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type Inspector2MemberHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []Inspector2MemberHit `json:"hits"`
}

type Inspector2MemberSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  Inspector2MemberHits `json:"hits"`
}

type Inspector2MemberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspector2MemberPaginator(filters []essdk.BoolFilter, limit *int64) (Inspector2MemberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector2_member", filters, limit)
	if err != nil {
		return Inspector2MemberPaginator{}, err
	}

	p := Inspector2MemberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Inspector2MemberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Inspector2MemberPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Inspector2MemberPaginator) NextPage(ctx context.Context) ([]Inspector2Member, error) {
	var response Inspector2MemberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Inspector2Member
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspector2MemberFilters = map[string]string{
	"delegated_admin_account_id": "description.Member.DelegatedAdminAccountId",
	"og_account_id":              "metadata.SourceID",
	"member_account_id":          "description.Member.AccountId",
	"relationship_status":        "description.Member.RelationshipStatus",
	"title":                      "description.Member.AccountId",
	"updated_at":                 "description.Member.UpdatedAt",
}

func ListInspector2Member(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspector2Member")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Member NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Member NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Member GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Member GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Member GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspector2MemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspector2MemberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Member NewInspector2MemberPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspector2Member paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspector2MemberFilters = map[string]string{
	"delegated_admin_account_id": "description.Member.DelegatedAdminAccountId",
	"og_account_id":              "metadata.SourceID",
	"member_account_id":          "description.Member.AccountId",
	"relationship_status":        "description.Member.RelationshipStatus",
	"title":                      "description.Member.AccountId",
	"updated_at":                 "description.Member.UpdatedAt",
}

func GetInspector2Member(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspector2Member")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspector2MemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspector2MemberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Inspector2Member =============================

// ==========================  START: Inspector2Finding =============================

type Inspector2Finding struct {
	Description   aws.Inspector2FindingDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type Inspector2FindingHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  Inspector2Finding `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type Inspector2FindingHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []Inspector2FindingHit `json:"hits"`
}

type Inspector2FindingSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  Inspector2FindingHits `json:"hits"`
}

type Inspector2FindingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewInspector2FindingPaginator(filters []essdk.BoolFilter, limit *int64) (Inspector2FindingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_inspector2_finding", filters, limit)
	if err != nil {
		return Inspector2FindingPaginator{}, err
	}

	p := Inspector2FindingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Inspector2FindingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Inspector2FindingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Inspector2FindingPaginator) NextPage(ctx context.Context) ([]Inspector2Finding, error) {
	var response Inspector2FindingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Inspector2Finding
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listInspector2FindingFilters = map[string]string{
	"arn":                                "description.Finding.FindingArn",
	"cvss":                               "description.Finding.PackageVulnerabilityDetails.Cvss",
	"description":                        "description.Finding.Description",
	"ec2_instance_image_id":              "description.Resource.Details.AwsEc2Instance.ImageId",
	"ec2_instance_subnet_id":             "description.Resource.Details.AwsEc2Instance.SubnetId",
	"ec2_instance_vpc_id":                "description.Resource.Details.AwsEc2Instance.VpcId",
	"ecr_image_architecture":             "description.Resource.Details.AwsEcrContainerImage.Architecture",
	"ecr_image_hash":                     "description.Resource.Details.AwsEcrContainerImage.ImageHash",
	"ecr_image_pushed_at":                "description.Resource.Details.AwsEcrContainerImage.PushedAt",
	"ecr_image_registry":                 "description.Resource.Details.AwsEcrContainerImage.Registry",
	"ecr_image_repository_name":          "description.Resource.Details.AwsEcrContainerImage.RepositoryName",
	"ecr_image_tags":                     "description.Resource.Details.AwsEcrContainerImage.ImageTags",
	"exploit_available":                  "description.Finding.ExploitAvailable",
	"exploitability_details":             "description.Finding.ExploitabilityDetails",
	"finding_account_id":                 "description.Finding.AwsAccountId",
	"first_observed_at":                  "description.Finding.FirstObservedAt",
	"fix_available":                      "description.Finding.FixAvailable",
	"inspector_score":                    "description.Finding.InspectorScore",
	"inspector_score_details":            "description.Finding.InspectorScoreDetails",
	"og_account_id":                      "metadata.SourceID",
	"lambda_function_execution_role_arn": "description.Resource.Details.AwsLambdaFunction.ExecutionRoleArn",
	"lambda_function_last_modified_at":   "description.Resource.Details.AwsLambdaFunction.LastModifiedAt",
	"lambda_function_layers":             "description.Resource.Details.AwsLambdaFunction.Layers",
	"lambda_function_name":               "description.Resource.Details.AwsLambdaFunction.FunctionName",
	"last_observed_at":                   "description.Finding.LastObservedAt",
	"network_protocol":                   "description.Finding.NetworkReachabilityDetails.Protocol",
	"network_reachability_details":       "description.Finding.NetworkReachabilityDetails",
	"package_vulnerability_details":      "description.Finding.PackageVulnerabilityDetails",
	"reference_urls":                     "description.Finding.PackageVulnerabilityDetails.ReferenceUrls",
	"related_vulnerabilitie":             "description.Finding.PackageVulnerabilityDetails.VulnerabilityId",
	"related_vulnerabilities":            "description.Finding.PackageVulnerabilityDetails.RelatedVulnerabilities",
	"remediation_recommendation_text":    "description.Finding.Remediation.Recommendation.Text",
	"remediation_recommendation_url":     "description.Finding.Remediation.Recommendation.Url",
	"resource_id":                        "description.Resource.Id",
	"resource_tags":                      "description.Resource.Tags",
	"resource_type":                      "description.Resource.Type",
	"resources":                          "description.Resource",
	"severity":                           "description.Finding.Severity",
	"source":                             "description.Finding.PackageVulnerabilityDetails.Source",
	"source_url":                         "description.Finding.PackageVulnerabilityDetails.SourceUrl",
	"status":                             "description.Finding.Status",
	"title":                              "description.Finding.Title",
	"type":                               "description.Finding.Type",
	"updated_at":                         "description.Finding.UpdatedAt",
	"vendor_created_at":                  "description.Finding.PackageVulnerabilityDetails.VendorCreatedAt",
	"vendor_severity":                    "description.Finding.PackageVulnerabilityDetails.VendorSeverity",
	"vendor_updated_at":                  "description.Finding.PackageVulnerabilityDetails.vendorUpdatedAt",
	"vulnerability_id":                   "description.Finding.PackageVulnerabilityDetails.VulnerabilityId",
	"vulnerable_package":                 "description.Finding.PackageVulnerabilityDetails.VulnerablePackages",
	"vulnerable_packages":                "description.Finding.PackageVulnerabilityDetails.VulnerablePackages",
}

func ListInspector2Finding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListInspector2Finding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Finding NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Finding NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Finding GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Finding GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Finding GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewInspector2FindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listInspector2FindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListInspector2Finding NewInspector2FindingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListInspector2Finding paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getInspector2FindingFilters = map[string]string{
	"arn":                                "description.Finding.FindingArn",
	"cvss":                               "description.Finding.PackageVulnerabilityDetails.Cvss",
	"description":                        "description.Finding.Description",
	"ec2_instance_image_id":              "description.Resource.Details.AwsEc2Instance.ImageId",
	"ec2_instance_subnet_id":             "description.Resource.Details.AwsEc2Instance.SubnetId",
	"ec2_instance_vpc_id":                "description.Resource.Details.AwsEc2Instance.VpcId",
	"ecr_image_architecture":             "description.Resource.Details.AwsEcrContainerImage.Architecture",
	"ecr_image_hash":                     "description.Resource.Details.AwsEcrContainerImage.ImageHash",
	"ecr_image_pushed_at":                "description.Resource.Details.AwsEcrContainerImage.PushedAt",
	"ecr_image_registry":                 "description.Resource.Details.AwsEcrContainerImage.Registry",
	"ecr_image_repository_name":          "description.Resource.Details.AwsEcrContainerImage.RepositoryName",
	"ecr_image_tags":                     "description.Resource.Details.AwsEcrContainerImage.ImageTags",
	"exploit_available":                  "description.Finding.ExploitAvailable",
	"exploitability_details":             "description.Finding.ExploitabilityDetails",
	"finding_account_id":                 "description.Finding.AwsAccountId",
	"first_observed_at":                  "description.Finding.FirstObservedAt",
	"fix_available":                      "description.Finding.FixAvailable",
	"inspector_score":                    "description.Finding.InspectorScore",
	"inspector_score_details":            "description.Finding.InspectorScoreDetails",
	"og_account_id":                      "metadata.SourceID",
	"lambda_function_execution_role_arn": "description.Resource.Details.AwsLambdaFunction.ExecutionRoleArn",
	"lambda_function_last_modified_at":   "description.Resource.Details.AwsLambdaFunction.LastModifiedAt",
	"lambda_function_layers":             "description.Resource.Details.AwsLambdaFunction.Layers",
	"lambda_function_name":               "description.Resource.Details.AwsLambdaFunction.FunctionName",
	"last_observed_at":                   "description.Finding.LastObservedAt",
	"network_protocol":                   "description.Finding.NetworkReachabilityDetails.Protocol",
	"network_reachability_details":       "description.Finding.NetworkReachabilityDetails",
	"package_vulnerability_details":      "description.Finding.PackageVulnerabilityDetails",
	"reference_urls":                     "description.Finding.PackageVulnerabilityDetails.ReferenceUrls",
	"related_vulnerabilitie":             "description.Finding.PackageVulnerabilityDetails.VulnerabilityId",
	"related_vulnerabilities":            "description.Finding.PackageVulnerabilityDetails.RelatedVulnerabilities",
	"remediation_recommendation_text":    "description.Finding.Remediation.Recommendation.Text",
	"remediation_recommendation_url":     "description.Finding.Remediation.Recommendation.Url",
	"resource_id":                        "description.Resource.Id",
	"resource_tags":                      "description.Resource.Tags",
	"resource_type":                      "description.Resource.Type",
	"resources":                          "description.Resource",
	"severity":                           "description.Finding.Severity",
	"source":                             "description.Finding.PackageVulnerabilityDetails.Source",
	"source_url":                         "description.Finding.PackageVulnerabilityDetails.SourceUrl",
	"status":                             "description.Finding.Status",
	"title":                              "description.Finding.Title",
	"type":                               "description.Finding.Type",
	"updated_at":                         "description.Finding.UpdatedAt",
	"vendor_created_at":                  "description.Finding.PackageVulnerabilityDetails.VendorCreatedAt",
	"vendor_severity":                    "description.Finding.PackageVulnerabilityDetails.VendorSeverity",
	"vendor_updated_at":                  "description.Finding.PackageVulnerabilityDetails.vendorUpdatedAt",
	"vulnerability_id":                   "description.Finding.PackageVulnerabilityDetails.VulnerabilityId",
	"vulnerable_package":                 "description.Finding.PackageVulnerabilityDetails.VulnerablePackages",
	"vulnerable_packages":                "description.Finding.PackageVulnerabilityDetails.VulnerablePackages",
}

func GetInspector2Finding(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetInspector2Finding")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewInspector2FindingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getInspector2FindingFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Inspector2Finding =============================

// ==========================  START: FirehoseDeliveryStream =============================

type FirehoseDeliveryStream struct {
	Description   aws.FirehoseDeliveryStreamDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type FirehoseDeliveryStreamHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  FirehoseDeliveryStream `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type FirehoseDeliveryStreamHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []FirehoseDeliveryStreamHit `json:"hits"`
}

type FirehoseDeliveryStreamSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  FirehoseDeliveryStreamHits `json:"hits"`
}

type FirehoseDeliveryStreamPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFirehoseDeliveryStreamPaginator(filters []essdk.BoolFilter, limit *int64) (FirehoseDeliveryStreamPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_firehose_deliverystream", filters, limit)
	if err != nil {
		return FirehoseDeliveryStreamPaginator{}, err
	}

	p := FirehoseDeliveryStreamPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FirehoseDeliveryStreamPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FirehoseDeliveryStreamPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FirehoseDeliveryStreamPaginator) NextPage(ctx context.Context) ([]FirehoseDeliveryStream, error) {
	var response FirehoseDeliveryStreamSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FirehoseDeliveryStream
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFirehoseDeliveryStreamFilters = map[string]string{
	"arn":              "description.DeliveryStream.DeliveryStreamARN",
	"create_timestamp": "description.DeliveryStream.CreateTimestamp",
	"delivery_stream_encryption_configuration": "description.DeliveryStream.DeliveryStreamEncryptionConfiguration",
	"delivery_stream_name":                     "description.DeliveryStream.DeliveryStreamName",
	"delivery_stream_status":                   "description.DeliveryStream.DeliveryStreamStatus",
	"delivery_stream_type":                     "description.DeliveryStream.DeliveryStreamType",
	"destinations":                             "description.DeliveryStream.Destinations",
	"failure_description":                      "description.DeliveryStream.FailureDescription",
	"has_more_destinations":                    "description.DeliveryStream.HasMoreDestinations",
	"og_account_id":                            "metadata.SourceID",
	"last_update_timestamp":                    "description.DeliveryStream.LastUpdateTimestamp",
	"source":                                   "description.DeliveryStream.Source",
	"tags_src":                                 "description.Tags",
	"title":                                    "description.DeliveryStream.DeliveryStreamName",
	"version_id":                               "description.DeliveryStream.VersionId",
}

func ListFirehoseDeliveryStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFirehoseDeliveryStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirehoseDeliveryStream NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirehoseDeliveryStream NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirehoseDeliveryStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirehoseDeliveryStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirehoseDeliveryStream GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFirehoseDeliveryStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFirehoseDeliveryStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirehoseDeliveryStream NewFirehoseDeliveryStreamPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFirehoseDeliveryStream paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFirehoseDeliveryStreamFilters = map[string]string{
	"arn":              "description.DeliveryStream.DeliveryStreamARN",
	"create_timestamp": "description.DeliveryStream.CreateTimestamp",
	"delivery_stream_encryption_configuration": "description.DeliveryStream.DeliveryStreamEncryptionConfiguration",
	"delivery_stream_name":                     "description.DeliveryStream.DeliveryStreamName",
	"delivery_stream_status":                   "description.DeliveryStream.DeliveryStreamStatus",
	"delivery_stream_type":                     "description.DeliveryStream.DeliveryStreamType",
	"destinations":                             "description.DeliveryStream.Destinations",
	"failure_description":                      "description.DeliveryStream.FailureDescription",
	"has_more_destinations":                    "description.DeliveryStream.HasMoreDestinations",
	"og_account_id":                            "metadata.SourceID",
	"last_update_timestamp":                    "description.DeliveryStream.LastUpdateTimestamp",
	"source":                                   "description.DeliveryStream.Source",
	"tags_src":                                 "description.Tags",
	"title":                                    "description.DeliveryStream.DeliveryStreamName",
	"version_id":                               "description.DeliveryStream.VersionId",
}

func GetFirehoseDeliveryStream(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFirehoseDeliveryStream")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFirehoseDeliveryStreamPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFirehoseDeliveryStreamFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FirehoseDeliveryStream =============================

// ==========================  START: LightsailInstance =============================

type LightsailInstance struct {
	Description   aws.LightsailInstanceDescription `json:"description"`
	Metadata      aws.Metadata                     `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type LightsailInstanceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  LightsailInstance `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type LightsailInstanceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []LightsailInstanceHit `json:"hits"`
}

type LightsailInstanceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  LightsailInstanceHits `json:"hits"`
}

type LightsailInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLightsailInstancePaginator(filters []essdk.BoolFilter, limit *int64) (LightsailInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_lightsail_instance", filters, limit)
	if err != nil {
		return LightsailInstancePaginator{}, err
	}

	p := LightsailInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LightsailInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LightsailInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LightsailInstancePaginator) NextPage(ctx context.Context) ([]LightsailInstance, error) {
	var response LightsailInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LightsailInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLightsailInstanceFilters = map[string]string{
	"arn":                "description.Instance.Arn",
	"availability_zone":  "description.Instance.Location.AvailabilityZone",
	"blueprint_id":       "description.Instance.BlueprintId",
	"blueprint_name":     "description.Instance.BlueprintName",
	"bundle_id":          "description.Instance.BundleId",
	"created_at":         "description.Instance.CreatedAt",
	"hardware":           "description.Instance.Hardware",
	"ip_address_type":    "description.Instance.IpAddressType",
	"ip_v6_addresses":    "description.Instance.Ipv6Addresses",
	"is_static_ip":       "description.Instance.IsStaticIp",
	"og_account_id":      "metadata.SourceID",
	"metadata_options":   "description.Instance.MetadataOptions",
	"name":               "description.Instance.Name",
	"networking":         "description.Instance.Networking",
	"private_ip_address": "description.Instance.PrivateIpAddress",
	"public_ip_address":  "description.Instance.PublicIpAddress",
	"resource_type":      "description.Instance.ResourceType",
	"ssh_key_name":       "description.Instance.SshKeyName",
	"state_code":         "description.Instance.State.Code",
	"state_name":         "description.Instance.State.Name",
	"support_code":       "description.Instance.SupportCode",
	"tags_src":           "description.Instance.Tags",
	"title":              "description.Instance.Name",
	"username":           "description.Instance.Username",
}

func ListLightsailInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLightsailInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLightsailInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLightsailInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLightsailInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLightsailInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLightsailInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLightsailInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLightsailInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLightsailInstance NewLightsailInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLightsailInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLightsailInstanceFilters = map[string]string{
	"arn":                "description.Instance.Arn",
	"availability_zone":  "description.Instance.Location.AvailabilityZone",
	"blueprint_id":       "description.Instance.BlueprintId",
	"blueprint_name":     "description.Instance.BlueprintName",
	"bundle_id":          "description.Instance.BundleId",
	"created_at":         "description.Instance.CreatedAt",
	"hardware":           "description.Instance.Hardware",
	"ip_address_type":    "description.Instance.IpAddressType",
	"ip_v6_addresses":    "description.Instance.Ipv6Addresses",
	"is_static_ip":       "description.Instance.IsStaticIp",
	"og_account_id":      "metadata.SourceID",
	"metadata_options":   "description.Instance.MetadataOptions",
	"name":               "description.Instance.",
	"networking":         "description.Instance.Networking",
	"private_ip_address": "description.Instance.PrivateIpAddress",
	"public_ip_address":  "description.Instance.PublicIpAddress",
	"resource_type":      "description.Instance.ResourceType",
	"ssh_key_name":       "description.Instance.SshKeyName",
	"state_code":         "description.Instance.State.Code",
	"state_name":         "description.Instance.State.Name",
	"support_code":       "description.Instance.SupportCode",
	"tags_src":           "description.Instance.Tags",
	"title":              "description.Instance.Name",
	"username":           "description.Instance.Username",
}

func GetLightsailInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLightsailInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLightsailInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLightsailInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LightsailInstance =============================

// ==========================  START: Macie2ClassificationJob =============================

type Macie2ClassificationJob struct {
	Description   aws.Macie2ClassificationJobDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type Macie2ClassificationJobHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  Macie2ClassificationJob `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type Macie2ClassificationJobHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []Macie2ClassificationJobHit `json:"hits"`
}

type Macie2ClassificationJobSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  Macie2ClassificationJobHits `json:"hits"`
}

type Macie2ClassificationJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMacie2ClassificationJobPaginator(filters []essdk.BoolFilter, limit *int64) (Macie2ClassificationJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_macie2_classificationjob", filters, limit)
	if err != nil {
		return Macie2ClassificationJobPaginator{}, err
	}

	p := Macie2ClassificationJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p Macie2ClassificationJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p Macie2ClassificationJobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p Macie2ClassificationJobPaginator) NextPage(ctx context.Context) ([]Macie2ClassificationJob, error) {
	var response Macie2ClassificationJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Macie2ClassificationJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMacie2ClassificationJobFilters = map[string]string{
	"arn":                        "description.ClassificationJob.JobArn",
	"bucket_definitions":         "description.ClassificationJob.S3JobDefinition.BucketDefinitions",
	"client_token":               "description.ClassificationJob.ClientToken",
	"created_at":                 "description.ClassificationJob.CreatedAt",
	"custom_data_identifier_ids": "description.ClassificationJob.CustomDataIdentifierIds",
	"job_id":                     "description.ClassificationJob.JobId",
	"job_status":                 "description.ClassificationJob.JobStatus",
	"job_type":                   "description.ClassificationJob.JobType",
	"og_account_id":              "metadata.SourceID",
	"last_run_error_status":      "description.ClassificationJob.LastRunErrorStatus",
	"last_run_time":              "description.ClassificationJob.LastRunTime",
	"name":                       "description.ClassificationJob.Name",
	"s3_job_definition":          "description.ClassificationJob.S3JobDefinition",
	"sampling_percentage":        "description.ClassificationJob.SamplingPercentage",
	"schedule_frequency":         "description.ClassificationJob.ScheduleFrequency",
	"statistics":                 "description.ClassificationJob.Statistics",
	"tags":                       "description.ClassificationJob.Tags",
	"title":                      "description.ClassificationJob.Name",
	"user_paused_details":        "description.ClassificationJob.UserPausedDetails",
}

func ListMacie2ClassificationJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMacie2ClassificationJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMacie2ClassificationJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMacie2ClassificationJob NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMacie2ClassificationJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMacie2ClassificationJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMacie2ClassificationJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMacie2ClassificationJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMacie2ClassificationJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMacie2ClassificationJob NewMacie2ClassificationJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMacie2ClassificationJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMacie2ClassificationJobFilters = map[string]string{
	"arn":                        "description.ClassificationJob.JobArn",
	"bucket_definitions":         "description.ClassificationJob.S3JobDefinition.BucketDefinitions",
	"client_token":               "description.ClassificationJob.ClientToken",
	"created_at":                 "description.ClassificationJob.CreatedAt",
	"custom_data_identifier_ids": "description.ClassificationJob.CustomDataIdentifierIds",
	"job_id":                     "description.ClassificationJob.JobId",
	"job_status":                 "description.ClassificationJob.JobStatus",
	"job_type":                   "description.ClassificationJob.JobType",
	"og_account_id":              "metadata.SourceID",
	"last_run_error_status":      "description.ClassificationJob.LastRunErrorStatus",
	"last_run_time":              "description.ClassificationJob.LastRunTime",
	"name":                       "description.ClassificationJob.Name",
	"s3_job_definition":          "description.ClassificationJob.S3JobDefinition",
	"sampling_percentage":        "description.ClassificationJob.SamplingPercentage",
	"schedule_frequency":         "description.ClassificationJob.ScheduleFrequency",
	"statistics":                 "description.ClassificationJob.Statistics",
	"tags":                       "description.ClassificationJob.Tags",
	"title":                      "description.ClassificationJob.Name",
	"user_paused_details":        "description.ClassificationJob.UserPausedDetails",
}

func GetMacie2ClassificationJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMacie2ClassificationJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMacie2ClassificationJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMacie2ClassificationJobFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Macie2ClassificationJob =============================

// ==========================  START: MediaStoreContainer =============================

type MediaStoreContainer struct {
	Description   aws.MediaStoreContainerDescription `json:"description"`
	Metadata      aws.Metadata                       `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type MediaStoreContainerHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  MediaStoreContainer `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type MediaStoreContainerHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []MediaStoreContainerHit `json:"hits"`
}

type MediaStoreContainerSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  MediaStoreContainerHits `json:"hits"`
}

type MediaStoreContainerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMediaStoreContainerPaginator(filters []essdk.BoolFilter, limit *int64) (MediaStoreContainerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mediastore_container", filters, limit)
	if err != nil {
		return MediaStoreContainerPaginator{}, err
	}

	p := MediaStoreContainerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MediaStoreContainerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MediaStoreContainerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MediaStoreContainerPaginator) NextPage(ctx context.Context) ([]MediaStoreContainer, error) {
	var response MediaStoreContainerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MediaStoreContainer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMediaStoreContainerFilters = map[string]string{
	"access_logging_enabled": "description.Container.AccessLoggingEnabled",
	"arn":                    "description.Container.ARN",
	"creation_time":          "description.Container.CreationTime",
	"endpoint":               "description.Container.Endpoint",
	"og_account_id":          "metadata.SourceID",
	"name":                   "description.Container.Name",
	"policy":                 "description.Policy",
	"status":                 "description.Container.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Container.Name",
}

func ListMediaStoreContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMediaStoreContainer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMediaStoreContainer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMediaStoreContainer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMediaStoreContainer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMediaStoreContainer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMediaStoreContainer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMediaStoreContainerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMediaStoreContainerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMediaStoreContainer NewMediaStoreContainerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMediaStoreContainer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMediaStoreContainerFilters = map[string]string{
	"access_logging_enabled": "description.Container.AccessLoggingEnabled",
	"arn":                    "description.Container.ARN",
	"creation_time":          "description.Container.CreationTime",
	"endpoint":               "description.Container.Endpoint",
	"og_account_id":          "metadata.SourceID",
	"name":                   "description.Container.Name",
	"policy":                 "description.Policy",
	"status":                 "description.Container.Status",
	"tags_src":               "description.Tags",
	"title":                  "description.Container.Name",
}

func GetMediaStoreContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMediaStoreContainer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMediaStoreContainerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMediaStoreContainerFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MediaStoreContainer =============================

// ==========================  START: MgnApplication =============================

type MgnApplication struct {
	Description   aws.MgnApplicationDescription `json:"description"`
	Metadata      aws.Metadata                  `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type MgnApplicationHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  MgnApplication `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type MgnApplicationHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []MgnApplicationHit `json:"hits"`
}

type MgnApplicationSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  MgnApplicationHits `json:"hits"`
}

type MgnApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMgnApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (MgnApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_mgn_application", filters, limit)
	if err != nil {
		return MgnApplicationPaginator{}, err
	}

	p := MgnApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MgnApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MgnApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MgnApplicationPaginator) NextPage(ctx context.Context) ([]MgnApplication, error) {
	var response MgnApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MgnApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMgnApplicationFilters = map[string]string{
	"application_aggregated_status": "description.Application.ApplicationAggregatedStatus",
	"application_id":                "description.Application.ApplicationID",
	"arn":                           "description.Application.Arn",
	"creation_date_time":            "description.Application.CreationDateTime",
	"description":                   "description.Application.Description",
	"is_archived":                   "description.Application.IsArchived",
	"og_account_id":                 "metadata.SourceID",
	"last_modified_date_time":       "description.Application.LastModifiedDateTime",
	"name":                          "description.Application.Name",
	"tags":                          "description.Application.Tags",
	"title":                         "description.Application.Name",
	"wave_id":                       "description.Application.WaveID",
}

func ListMgnApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMgnApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMgnApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMgnApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMgnApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMgnApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMgnApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMgnApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMgnApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMgnApplication NewMgnApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMgnApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMgnApplicationFilters = map[string]string{
	"application_aggregated_status": "description.Application.ApplicationAggregatedStatus",
	"application_id":                "description.Application.ApplicationID",
	"arn":                           "description.Application.Arn",
	"creation_date_time":            "description.Application.CreationDateTime",
	"description":                   "description.Application.Description",
	"is_archived":                   "description.Application.IsArchived",
	"og_account_id":                 "metadata.SourceID",
	"last_modified_date_time":       "description.Application.LastModifiedDateTime",
	"name":                          "description.Application.Name",
	"tags":                          "description.Application.Tags",
	"title":                         "description.Application.Name",
	"wave_id":                       "description.Application.WaveID",
}

func GetMgnApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMgnApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMgnApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMgnApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MgnApplication =============================

// ==========================  START: SecurityLakeDataLake =============================

type SecurityLakeDataLake struct {
	Description   aws.SecurityLakeDataLakeDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SecurityLakeDataLakeHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SecurityLakeDataLake `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SecurityLakeDataLakeHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SecurityLakeDataLakeHit `json:"hits"`
}

type SecurityLakeDataLakeSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SecurityLakeDataLakeHits `json:"hits"`
}

type SecurityLakeDataLakePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityLakeDataLakePaginator(filters []essdk.BoolFilter, limit *int64) (SecurityLakeDataLakePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securitylake_datalake", filters, limit)
	if err != nil {
		return SecurityLakeDataLakePaginator{}, err
	}

	p := SecurityLakeDataLakePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityLakeDataLakePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityLakeDataLakePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityLakeDataLakePaginator) NextPage(ctx context.Context) ([]SecurityLakeDataLake, error) {
	var response SecurityLakeDataLakeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityLakeDataLake
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityLakeDataLakeFilters = map[string]string{
	"arn":                       "description.DataLake.DataLakeArn",
	"create_status":             "description.DataLake.CreateStatus",
	"og_account_id":             "metadata.SourceID",
	"kms_key_id":                "description.DataLake.EncryptionConfiguration.KmsKeyId",
	"lifecycle_configuration":   "description.DataLake.LifecycleConfiguration",
	"replication_configuration": "description.DataLake.ReplicationConfiguration",
	"replication_role_arn":      "description.DataLake.ReplicationConfiguration.RoleArn",
	"s3_bucket_arn":             "description.DataLake.ReplicationConfiguration.S3BucketArn",
	"update_status":             "description.DataLake.UpdateStatus",
}

func ListSecurityLakeDataLake(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityLakeDataLake")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeDataLake NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeDataLake NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeDataLake GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeDataLake GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeDataLake GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityLakeDataLakePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityLakeDataLakeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeDataLake NewSecurityLakeDataLakePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityLakeDataLake paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityLakeDataLakeFilters = map[string]string{
	"arn":                       "description.DataLake.DataLakeArn",
	"create_status":             "description.DataLake.CreateStatus",
	"og_account_id":             "metadata.SourceID",
	"kms_key_id":                "description.DataLake.EncryptionConfiguration.KmsKeyId",
	"lifecycle_configuration":   "description.DataLake.LifecycleConfiguration",
	"replication_configuration": "description.DataLake.ReplicationConfiguration",
	"replication_role_arn":      "description.DataLake.ReplicationConfiguration.RoleArn",
	"s3_bucket_arn":             "description.DataLake.ReplicationConfiguration.S3BucketArn",
	"update_status":             "description.DataLake.UpdateStatus",
}

func GetSecurityLakeDataLake(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityLakeDataLake")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityLakeDataLakePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityLakeDataLakeFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityLakeDataLake =============================

// ==========================  START: SecurityLakeSubscriber =============================

type SecurityLakeSubscriber struct {
	Description   aws.SecurityLakeSubscriberDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type SecurityLakeSubscriberHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  SecurityLakeSubscriber `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type SecurityLakeSubscriberHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []SecurityLakeSubscriberHit `json:"hits"`
}

type SecurityLakeSubscriberSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  SecurityLakeSubscriberHits `json:"hits"`
}

type SecurityLakeSubscriberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityLakeSubscriberPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityLakeSubscriberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_securitylake_subscriber", filters, limit)
	if err != nil {
		return SecurityLakeSubscriberPaginator{}, err
	}

	p := SecurityLakeSubscriberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityLakeSubscriberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityLakeSubscriberPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityLakeSubscriberPaginator) NextPage(ctx context.Context) ([]SecurityLakeSubscriber, error) {
	var response SecurityLakeSubscriberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityLakeSubscriber
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityLakeSubscriberFilters = map[string]string{
	"access_types":           "description.Subscriber.AccessTypes",
	"created_at":             "description.Subscriber.CreatedAt",
	"external_id":            "description.Subscriber.ExternalId",
	"og_account_id":          "metadata.SourceID",
	"role_arn":               "description.Subscriber.RoleArn",
	"s3_bucket_arn":          "description.Subscriber.S3BucketArn",
	"sns_arn":                "description.Subscriber.SnsArn",
	"source_types":           "description.Subscriber.SourceTypes",
	"subscriber_description": "description.Subscriber.SubscriberDescription",
	"subscriber_name":        "description.Subscriber.SubscriberName",
	"subscription_endpoint":  "description.Subscriber.SubscriptionEndpoint",
	"subscription_id":        "description.Subscriber.SubscriptionId",
	"subscription_protocol":  "description.Subscriber.SubscriptionProtocol",
	"subscription_status":    "description.Subscriber.SubscriptionStatus",
	"title":                  "description.Subscriber.SubscriberName",
	"updated_at":             "description.Subscriber.UpdatedAt",
}

func ListSecurityLakeSubscriber(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityLakeSubscriber")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeSubscriber NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeSubscriber NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeSubscriber GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeSubscriber GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeSubscriber GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityLakeSubscriberPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityLakeSubscriberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityLakeSubscriber NewSecurityLakeSubscriberPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityLakeSubscriber paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityLakeSubscriberFilters = map[string]string{
	"access_types":           "description.Subscriber.AccessTypes",
	"created_at":             "description.Subscriber.CreatedAt",
	"external_id":            "description.Subscriber.ExternalId",
	"og_account_id":          "metadata.SourceID",
	"role_arn":               "description.Subscriber.RoleArn",
	"s3_bucket_arn":          "description.Subscriber.S3BucketArn",
	"sns_arn":                "description.Subscriber.SnsArn",
	"source_types":           "description.Subscriber.SourceTypes",
	"subscriber_description": "description.Subscriber.SubscriberDescription",
	"subscriber_id":          "description.Subscriber.SubscriberId",
	"subscriber_name":        "description.Subscriber.SubscriberName",
	"subscription_endpoint":  "description.Subscriber.SubscriptionEndpoint",
	"subscription_id":        "description.Subscriber.SubscriptionId",
	"subscription_protocol":  "description.Subscriber.SubscriptionProtocol",
	"subscription_status":    "description.Subscriber.SubscriptionStatus",
	"title":                  "description.Subscriber.SubscriberName",
	"updated_at":             "description.Subscriber.UpdatedAt",
}

func GetSecurityLakeSubscriber(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityLakeSubscriber")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityLakeSubscriberPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityLakeSubscriberFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityLakeSubscriber =============================

// ==========================  START: RamPrincipalAssociation =============================

type RamPrincipalAssociation struct {
	Description   aws.RamPrincipalAssociationDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type RamPrincipalAssociationHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  RamPrincipalAssociation `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type RamPrincipalAssociationHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []RamPrincipalAssociationHit `json:"hits"`
}

type RamPrincipalAssociationSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  RamPrincipalAssociationHits `json:"hits"`
}

type RamPrincipalAssociationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRamPrincipalAssociationPaginator(filters []essdk.BoolFilter, limit *int64) (RamPrincipalAssociationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ram_principalassociation", filters, limit)
	if err != nil {
		return RamPrincipalAssociationPaginator{}, err
	}

	p := RamPrincipalAssociationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RamPrincipalAssociationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RamPrincipalAssociationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RamPrincipalAssociationPaginator) NextPage(ctx context.Context) ([]RamPrincipalAssociation, error) {
	var response RamPrincipalAssociationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RamPrincipalAssociation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRamPrincipalAssociationFilters = map[string]string{
	"associated_entity":         "description.PrincipalAssociation.AssociatedEntity",
	"association_type":          "description.PrincipalAssociation.AssociationType",
	"creation_time":             "description.PrincipalAssociation.CreationTime",
	"external":                  "description.PrincipalAssociation.External",
	"og_account_id":             "metadata.SourceID",
	"last_updated_time":         "description.PrincipalAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.PrincipalAssociation.ResourceShareArn",
	"resource_share_name":       "description.PrincipalAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.PrincipalAssociation.Status",
	"status_message":            "description.PrincipalAssociation.StatusMessage",
	"title":                     "description.PrincipalAssociation.ResourceShareName",
}

func ListRamPrincipalAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRamPrincipalAssociation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamPrincipalAssociation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamPrincipalAssociation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamPrincipalAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamPrincipalAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamPrincipalAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRamPrincipalAssociationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRamPrincipalAssociationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamPrincipalAssociation NewRamPrincipalAssociationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRamPrincipalAssociation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRamPrincipalAssociationFilters = map[string]string{
	"associated_entity":         "description.PrincipalAssociation.AssociatedEntity",
	"association_type":          "description.PrincipalAssociation.AssociationType",
	"creation_time":             "description.PrincipalAssociation.CreationTime",
	"external":                  "description.PrincipalAssociation.External",
	"og_account_id":             "metadata.SourceID",
	"last_updated_time":         "description.PrincipalAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.PrincipalAssociation.ResourceShareArn",
	"resource_share_name":       "description.PrincipalAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.PrincipalAssociation.Status",
	"status_message":            "description.PrincipalAssociation.StatusMessage",
	"title":                     "description.PrincipalAssociation.ResourceShareName",
}

func GetRamPrincipalAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRamPrincipalAssociation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRamPrincipalAssociationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRamPrincipalAssociationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RamPrincipalAssociation =============================

// ==========================  START: RamResourceAssociation =============================

type RamResourceAssociation struct {
	Description   aws.RamResourceAssociationDescription `json:"description"`
	Metadata      aws.Metadata                          `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type RamResourceAssociationHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  RamResourceAssociation `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type RamResourceAssociationHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []RamResourceAssociationHit `json:"hits"`
}

type RamResourceAssociationSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  RamResourceAssociationHits `json:"hits"`
}

type RamResourceAssociationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRamResourceAssociationPaginator(filters []essdk.BoolFilter, limit *int64) (RamResourceAssociationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_ram_resourceassociation", filters, limit)
	if err != nil {
		return RamResourceAssociationPaginator{}, err
	}

	p := RamResourceAssociationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RamResourceAssociationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RamResourceAssociationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RamResourceAssociationPaginator) NextPage(ctx context.Context) ([]RamResourceAssociation, error) {
	var response RamResourceAssociationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RamResourceAssociation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRamResourceAssociationFilters = map[string]string{
	"associated_entity":         "description.ResourceAssociation.AssociatedEntity",
	"association_type":          "description.ResourceAssociation.AssociationType",
	"creation_time":             "description.ResourceAssociation.CreationTime",
	"external":                  "description.ResourceAssociation.External",
	"og_account_id":             "metadata.SourceID",
	"last_updated_time":         "description.ResourceAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.ResourceAssociation.ResourceShareArn",
	"resource_share_name":       "description.ResourceAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.ResourceAssociation.Status",
	"status_message":            "description.ResourceAssociation.StatusMessage",
	"title":                     "description.ResourceAssociation.ResourceShareName",
}

func ListRamResourceAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRamResourceAssociation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamResourceAssociation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamResourceAssociation NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamResourceAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamResourceAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamResourceAssociation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRamResourceAssociationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRamResourceAssociationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRamResourceAssociation NewRamResourceAssociationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRamResourceAssociation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRamResourceAssociationFilters = map[string]string{
	"associated_entity":         "description.ResourceAssociation.AssociatedEntity",
	"association_type":          "description.ResourceAssociation.AssociationType",
	"creation_time":             "description.ResourceAssociation.CreationTime",
	"external":                  "description.ResourceAssociation.External",
	"og_account_id":             "metadata.SourceID",
	"last_updated_time":         "description.ResourceAssociation.LastUpdatedTime",
	"resource_share_arn":        "description.ResourceAssociation.ResourceShareArn",
	"resource_share_name":       "description.ResourceAssociation.ResourceShareName",
	"resource_share_permission": "description.ResourceSharePermission",
	"status":                    "description.ResourceAssociation.Status",
	"status_message":            "description.ResourceAssociation.StatusMessage",
	"title":                     "description.ResourceAssociation.ResourceShareName",
}

func GetRamResourceAssociation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRamResourceAssociation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRamResourceAssociationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRamResourceAssociationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RamResourceAssociation =============================

// ==========================  START: ServerlessApplicationRepositoryApplication =============================

type ServerlessApplicationRepositoryApplication struct {
	Description   aws.ServerlessApplicationRepositoryApplicationDescription `json:"description"`
	Metadata      aws.Metadata                                              `json:"metadata"`
	ResourceJobID int                                                       `json:"resource_job_id"`
	SourceJobID   int                                                       `json:"source_job_id"`
	ResourceType  string                                                    `json:"resource_type"`
	SourceType    string                                                    `json:"source_type"`
	ID            string                                                    `json:"id"`
	ARN           string                                                    `json:"arn"`
	SourceID      string                                                    `json:"source_id"`
}

type ServerlessApplicationRepositoryApplicationHit struct {
	ID      string                                     `json:"_id"`
	Score   float64                                    `json:"_score"`
	Index   string                                     `json:"_index"`
	Type    string                                     `json:"_type"`
	Version int64                                      `json:"_version,omitempty"`
	Source  ServerlessApplicationRepositoryApplication `json:"_source"`
	Sort    []interface{}                              `json:"sort"`
}

type ServerlessApplicationRepositoryApplicationHits struct {
	Total essdk.SearchTotal                               `json:"total"`
	Hits  []ServerlessApplicationRepositoryApplicationHit `json:"hits"`
}

type ServerlessApplicationRepositoryApplicationSearchResponse struct {
	PitID string                                         `json:"pit_id"`
	Hits  ServerlessApplicationRepositoryApplicationHits `json:"hits"`
}

type ServerlessApplicationRepositoryApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServerlessApplicationRepositoryApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (ServerlessApplicationRepositoryApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_severlessapplicationrepository_application", filters, limit)
	if err != nil {
		return ServerlessApplicationRepositoryApplicationPaginator{}, err
	}

	p := ServerlessApplicationRepositoryApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServerlessApplicationRepositoryApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServerlessApplicationRepositoryApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServerlessApplicationRepositoryApplicationPaginator) NextPage(ctx context.Context) ([]ServerlessApplicationRepositoryApplication, error) {
	var response ServerlessApplicationRepositoryApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServerlessApplicationRepositoryApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServerlessApplicationRepositoryApplicationFilters = map[string]string{
	"arn":                 "description.Application.ApplicationId",
	"author":              "description.Application.Author",
	"creation_time":       "description.Application.CreationTime",
	"description":         "description.Application.Description",
	"home_page_url":       "description.Application.HomePageUrl",
	"is_verified_author":  "description.Application.IsVerifiedAuthor",
	"og_account_id":       "metadata.SourceID",
	"labels":              "description.Application.Labels",
	"license_url":         "description.Application.LicenseUrl",
	"name":                "description.Application.Name",
	"readme_url":          "description.Application.ReadmeUrl",
	"spdx_license_id":     "description.Application.SpdxLicenseId",
	"statements":          "description.Statements",
	"title":               "description.Application.Name",
	"verified_author_url": "description.Application.VerifiedAuthorUrl",
	"version":             "description.Application.Version",
}

func ListServerlessApplicationRepositoryApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServerlessApplicationRepositoryApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServerlessApplicationRepositoryApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServerlessApplicationRepositoryApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServerlessApplicationRepositoryApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServerlessApplicationRepositoryApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServerlessApplicationRepositoryApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServerlessApplicationRepositoryApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listServerlessApplicationRepositoryApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServerlessApplicationRepositoryApplication NewServerlessApplicationRepositoryApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServerlessApplicationRepositoryApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServerlessApplicationRepositoryApplicationFilters = map[string]string{
	"arn":                 "description.Application.ApplicationId",
	"author":              "description.Application.Author",
	"creation_time":       "description.Application.CreationTime",
	"description":         "description.Application.Description",
	"home_page_url":       "description.Application.HomePageUrl",
	"is_verified_author":  "description.Application.IsVerifiedAuthor",
	"og_account_id":       "metadata.SourceID",
	"labels":              "description.Application.Labels",
	"license_url":         "description.Application.LicenseUrl",
	"name":                "description.Application.Name",
	"readme_url":          "description.Application.ReadmeUrl",
	"spdx_license_id":     "description.Application.SpdxLicenseId",
	"statements":          "description.Statements",
	"title":               "description.Application.Name",
	"verified_author_url": "description.Application.VerifiedAuthorUrl",
	"version":             "description.Application.Version",
}

func GetServerlessApplicationRepositoryApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServerlessApplicationRepositoryApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServerlessApplicationRepositoryApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getServerlessApplicationRepositoryApplicationFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServerlessApplicationRepositoryApplication =============================

// ==========================  START: ServiceQuotasServiceQuotaChangeRequest =============================

type ServiceQuotasServiceQuotaChangeRequest struct {
	Description   aws.ServiceQuotasServiceQuotaChangeRequestDescription `json:"description"`
	Metadata      aws.Metadata                                          `json:"metadata"`
	ResourceJobID int                                                   `json:"resource_job_id"`
	SourceJobID   int                                                   `json:"source_job_id"`
	ResourceType  string                                                `json:"resource_type"`
	SourceType    string                                                `json:"source_type"`
	ID            string                                                `json:"id"`
	ARN           string                                                `json:"arn"`
	SourceID      string                                                `json:"source_id"`
}

type ServiceQuotasServiceQuotaChangeRequestHit struct {
	ID      string                                 `json:"_id"`
	Score   float64                                `json:"_score"`
	Index   string                                 `json:"_index"`
	Type    string                                 `json:"_type"`
	Version int64                                  `json:"_version,omitempty"`
	Source  ServiceQuotasServiceQuotaChangeRequest `json:"_source"`
	Sort    []interface{}                          `json:"sort"`
}

type ServiceQuotasServiceQuotaChangeRequestHits struct {
	Total essdk.SearchTotal                           `json:"total"`
	Hits  []ServiceQuotasServiceQuotaChangeRequestHit `json:"hits"`
}

type ServiceQuotasServiceQuotaChangeRequestSearchResponse struct {
	PitID string                                     `json:"pit_id"`
	Hits  ServiceQuotasServiceQuotaChangeRequestHits `json:"hits"`
}

type ServiceQuotasServiceQuotaChangeRequestPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceQuotasServiceQuotaChangeRequestPaginator(filters []essdk.BoolFilter, limit *int64) (ServiceQuotasServiceQuotaChangeRequestPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicequotas_servicequotachangerequest", filters, limit)
	if err != nil {
		return ServiceQuotasServiceQuotaChangeRequestPaginator{}, err
	}

	p := ServiceQuotasServiceQuotaChangeRequestPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceQuotasServiceQuotaChangeRequestPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceQuotasServiceQuotaChangeRequestPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceQuotasServiceQuotaChangeRequestPaginator) NextPage(ctx context.Context) ([]ServiceQuotasServiceQuotaChangeRequest, error) {
	var response ServiceQuotasServiceQuotaChangeRequestSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceQuotasServiceQuotaChangeRequest
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceQuotasServiceQuotaChangeRequestFilters = map[string]string{
	"case_id":       "description.ServiceQuotaChangeRequest.CaseId",
	"created":       "description.ServiceQuotaChangeRequest.Created",
	"desired_value": "description.ServiceQuotaChangeRequest.DesiredValue",
	"global_quota":  "description.ServiceQuotaChangeRequest.GlobalQuota",
	"id":            "description.ServiceQuotaChangeRequest.Id",
	"og_account_id": "metadata.SourceID",
	"last_updated":  "description.ServiceQuotaChangeRequest.LastUpdated",
	"quota_arn":     "description.ServiceQuotaChangeRequest.QuotaArn",
	"quota_code":    "description.ServiceQuotaChangeRequest.QuotaCode",
	"quota_name":    "description.ServiceQuotaChangeRequest.QuotaName",
	"requester":     "description.ServiceQuotaChangeRequest.Requester",
	"service_code":  "description.ServiceQuotaChangeRequest.ServiceCode",
	"service_name":  "description.ServiceQuotaChangeRequest.ServiceName",
	"status":        "description.ServiceQuotaChangeRequest.Status",
	"tags_src":      "description.Tags",
	"title":         "description.ServiceQuotaChangeRequest.QuotaName",
	"unit":          "description.ServiceQuotaChangeRequest.Unit",
}

func ListServiceQuotasServiceQuotaChangeRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceQuotasServiceQuotaChangeRequest")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasServiceQuotaChangeRequest NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasServiceQuotaChangeRequest NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasServiceQuotaChangeRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasServiceQuotaChangeRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasServiceQuotaChangeRequest GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceQuotasServiceQuotaChangeRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceQuotasServiceQuotaChangeRequestFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasServiceQuotaChangeRequest NewServiceQuotasServiceQuotaChangeRequestPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceQuotasServiceQuotaChangeRequest paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceQuotasServiceQuotaChangeRequestFilters = map[string]string{
	"case_id":       "description.ServiceQuotaChangeRequest.CaseId",
	"created":       "description.ServiceQuotaChangeRequest.Created",
	"desired_value": "description.ServiceQuotaChangeRequest.DesiredValue",
	"global_quota":  "description.ServiceQuotaChangeRequest.GlobalQuota",
	"id":            "description.ServiceQuotaChangeRequest.Id",
	"og_account_id": "metadata.SourceID",
	"last_updated":  "description.ServiceQuotaChangeRequest.LastUpdated",
	"quota_arn":     "description.ServiceQuotaChangeRequest.QuotaArn",
	"quota_code":    "description.ServiceQuotaChangeRequest.QuotaCode",
	"quota_name":    "description.ServiceQuotaChangeRequest.QuotaName",
	"requester":     "description.ServiceQuotaChangeRequest.Requester",
	"service_code":  "description.ServiceQuotaChangeRequest.ServiceCode",
	"service_name":  "description.ServiceQuotaChangeRequest.ServiceName",
	"status":        "description.ServiceQuotaChangeRequest.Status",
	"tags_src":      "description.Tags",
	"title":         "description.ServiceQuotaChangeRequest.QuotaName",
	"unit":          "description.ServiceQuotaChangeRequest.Unit",
}

func GetServiceQuotasServiceQuotaChangeRequest(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceQuotasServiceQuotaChangeRequest")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceQuotasServiceQuotaChangeRequestPaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceQuotasServiceQuotaChangeRequestFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceQuotasServiceQuotaChangeRequest =============================

// ==========================  START: ServiceQuotasService =============================

type ServiceQuotasService struct {
	Description   aws.ServiceQuotasServiceDescription `json:"description"`
	Metadata      aws.Metadata                        `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ServiceQuotasServiceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ServiceQuotasService `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ServiceQuotasServiceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ServiceQuotasServiceHit `json:"hits"`
}

type ServiceQuotasServiceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ServiceQuotasServiceHits `json:"hits"`
}

type ServiceQuotasServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceQuotasServicePaginator(filters []essdk.BoolFilter, limit *int64) (ServiceQuotasServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicequotas_service", filters, limit)
	if err != nil {
		return ServiceQuotasServicePaginator{}, err
	}

	p := ServiceQuotasServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceQuotasServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceQuotasServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceQuotasServicePaginator) NextPage(ctx context.Context) ([]ServiceQuotasService, error) {
	var response ServiceQuotasServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceQuotasService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceQuotasServiceFilters = map[string]string{
	"service_code": "description.Service.ServiceCode",
	"service_name": "description.Service.ServiceName",
	"title":        "description.Service.ServiceName",
}

func ListServiceQuotasService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceQuotasService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasService NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasService GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceQuotasServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceQuotasServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceQuotasService NewServiceQuotasServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceQuotasService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceQuotasServiceFilters = map[string]string{
	"service_code": "description.Service.ServiceCode",
	"service_name": "description.Service.ServiceName",
	"title":        "description.Service.ServiceName",
}

func GetServiceQuotasService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceQuotasService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceQuotasServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceQuotasServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceQuotasService =============================

// ==========================  START: ServiceCatalogProduct =============================

type ServiceCatalogProduct struct {
	Description   aws.ServiceCatalogProductDescription `json:"description"`
	Metadata      aws.Metadata                         `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ServiceCatalogProductHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ServiceCatalogProduct `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ServiceCatalogProductHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ServiceCatalogProductHit `json:"hits"`
}

type ServiceCatalogProductSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ServiceCatalogProductHits `json:"hits"`
}

type ServiceCatalogProductPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceCatalogProductPaginator(filters []essdk.BoolFilter, limit *int64) (ServiceCatalogProductPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicecatalog_product", filters, limit)
	if err != nil {
		return ServiceCatalogProductPaginator{}, err
	}

	p := ServiceCatalogProductPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceCatalogProductPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceCatalogProductPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceCatalogProductPaginator) NextPage(ctx context.Context) ([]ServiceCatalogProduct, error) {
	var response ServiceCatalogProductSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceCatalogProduct
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceCatalogProductFilters = map[string]string{
	"budgets":                "description.Budgets",
	"distributor":            "description.ProductViewSummary.Distributor",
	"has_default_path":       "description.ProductViewSummary.HasDefaultPath",
	"id":                     "description.ProductViewSummary.Id",
	"og_account_id":          "metadata.SourceID",
	"launch_paths":           "description.LunchPaths",
	"name":                   "description.ProductViewSummary.Name",
	"owner":                  "description.ProductViewSummary.Owner",
	"product_id":             "description.ProductViewSummary.ProductId",
	"provisioning_artifacts": "description.ProvisioningArtifacts",
	"short_description":      "description.ProductViewSummary.ShortDescription",
	"support_description":    "description.ProductViewSummary.SupportDescription",
	"support_email":          "description.ProductViewSummary.SupportEmail",
	"support_url":            "description.ProductViewSummary.SupportUrl",
	"title":                  "description.ProductViewSummary.Name",
	"type":                   "description.ProductViewSummary.Type",
}

func ListServiceCatalogProduct(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceCatalogProduct")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogProduct NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogProduct NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogProduct GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogProduct GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogProduct GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceCatalogProductPaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceCatalogProductFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogProduct NewServiceCatalogProductPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceCatalogProduct paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceCatalogProductFilters = map[string]string{
	"budgets":                "description.Budgets",
	"distributor":            "description.ProductViewSummary.Distributor",
	"has_default_path":       "description.ProductViewSummary.HasDefaultPath",
	"id":                     "description.ProductViewSummary.Id",
	"og_account_id":          "metadata.SourceID",
	"launch_paths":           "description.LunchPaths",
	"name":                   "description.ProductViewSummary.Name",
	"owner":                  "description.ProductViewSummary.Owner",
	"product_id":             "description.ProductViewSummary.ProductId",
	"provisioning_artifacts": "description.ProvisioningArtifacts",
	"short_description":      "description.ProductViewSummary.ShortDescription",
	"support_description":    "description.ProductViewSummary.SupportDescription",
	"support_email":          "description.ProductViewSummary.SupportEmail",
	"support_url":            "description.ProductViewSummary.SupportUrl",
	"title":                  "description.ProductViewSummary.Name",
	"type":                   "description.ProductViewSummary.Type",
}

func GetServiceCatalogProduct(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceCatalogProduct")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceCatalogProductPaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceCatalogProductFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceCatalogProduct =============================

// ==========================  START: ServiceCatalogPortfolio =============================

type ServiceCatalogPortfolio struct {
	Description   aws.ServiceCatalogPortfolioDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type ServiceCatalogPortfolioHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  ServiceCatalogPortfolio `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type ServiceCatalogPortfolioHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []ServiceCatalogPortfolioHit `json:"hits"`
}

type ServiceCatalogPortfolioSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  ServiceCatalogPortfolioHits `json:"hits"`
}

type ServiceCatalogPortfolioPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceCatalogPortfolioPaginator(filters []essdk.BoolFilter, limit *int64) (ServiceCatalogPortfolioPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicecatalog_portfolio", filters, limit)
	if err != nil {
		return ServiceCatalogPortfolioPaginator{}, err
	}

	p := ServiceCatalogPortfolioPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceCatalogPortfolioPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceCatalogPortfolioPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceCatalogPortfolioPaginator) NextPage(ctx context.Context) ([]ServiceCatalogPortfolio, error) {
	var response ServiceCatalogPortfolioSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceCatalogPortfolio
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceCatalogPortfolioFilters = map[string]string{
	"arn":           "description.Portfolio.ARN",
	"budgets":       "description.Budgets",
	"created_time":  "description.Portfolio.CreatedTime",
	"description":   "description.Portfolio.Description",
	"display_name":  "description.Portfolio.DisplayName",
	"id":            "description.Portfolio.Id",
	"og_account_id": "metadata.SourceID",
	"provider_name": "description.Portfolio.ProviderName",
	"tag_options":   "description.TagOptions",
	"tags":          "description.Tag",
	"tags_src":      "description.Tag",
	"title":         "description.Portfolio.DisplayName",
}

func ListServiceCatalogPortfolio(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceCatalogPortfolio")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogPortfolio NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogPortfolio NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogPortfolio GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogPortfolio GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogPortfolio GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceCatalogPortfolioPaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceCatalogPortfolioFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceCatalogPortfolio NewServiceCatalogPortfolioPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceCatalogPortfolio paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceCatalogPortfolioFilters = map[string]string{
	"arn":           "description.Portfolio.ARN",
	"budgets":       "description.Budgets",
	"created_time":  "description.Portfolio.CreatedTime",
	"description":   "description.Portfolio.Description",
	"display_name":  "description.Portfolio.DisplayName",
	"id":            "description.Portfolio.Id",
	"og_account_id": "metadata.SourceID",
	"provider_name": "description.Portfolio.ProviderName",
	"tag_options":   "description.TagOptions",
	"tags":          "description.Tag",
	"tags_src":      "description.Tag",
	"title":         "description.Portfolio.DisplayName",
}

func GetServiceCatalogPortfolio(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceCatalogPortfolio")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceCatalogPortfolioPaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceCatalogPortfolioFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceCatalogPortfolio =============================

// ==========================  START: ServiceDiscoveryService =============================

type ServiceDiscoveryService struct {
	Description   aws.ServiceDiscoveryServiceDescription `json:"description"`
	Metadata      aws.Metadata                           `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type ServiceDiscoveryServiceHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  ServiceDiscoveryService `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type ServiceDiscoveryServiceHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []ServiceDiscoveryServiceHit `json:"hits"`
}

type ServiceDiscoveryServiceSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  ServiceDiscoveryServiceHits `json:"hits"`
}

type ServiceDiscoveryServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceDiscoveryServicePaginator(filters []essdk.BoolFilter, limit *int64) (ServiceDiscoveryServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicediscovery_service", filters, limit)
	if err != nil {
		return ServiceDiscoveryServicePaginator{}, err
	}

	p := ServiceDiscoveryServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceDiscoveryServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceDiscoveryServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceDiscoveryServicePaginator) NextPage(ctx context.Context) ([]ServiceDiscoveryService, error) {
	var response ServiceDiscoveryServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceDiscoveryService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceDiscoveryServiceFilters = map[string]string{
	"arn":                        "description.Service.Arn",
	"create_date":                "description.Service.CreateDate",
	"description":                "description.Service.Description",
	"dns_records":                "description.Service.DnsConfig.DnsRecords",
	"health_check_config":        "description.Service.HealthCheckConfig",
	"health_check_custom_config": "description.Service.HealthCheckCustomConfig",
	"id":                         "description.Service.Id",
	"instance_count":             "description.Service.DnsConfig.InstanceCount",
	"og_account_id":              "metadata.SourceID",
	"name":                       "description.Service.Name",
	"namespace_id":               "description.Service.DnsConfig.NamespaceId",
	"routing_policy":             "description.Service.DnsConfig.RoutingPolicy",
	"tags":                       "description.Tags",
	"tags_src":                   "description.Tags",
	"title":                      "description.Service.Name",
	"type":                       "description.Service.Type",
}

func ListServiceDiscoveryService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceDiscoveryService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryService NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryService GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceDiscoveryServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceDiscoveryServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryService NewServiceDiscoveryServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceDiscoveryService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceDiscoveryServiceFilters = map[string]string{
	"arn":                        "description.Service.Arn",
	"create_date":                "description.Service.CreateDate",
	"description":                "description.Service.Description",
	"dns_records":                "description.Service.DnsConfig.DnsRecords",
	"health_check_config":        "description.Service.HealthCheckConfig",
	"health_check_custom_config": "description.Service.HealthCheckCustomConfig",
	"id":                         "description.Service.Id",
	"instance_count":             "description.Service.DnsConfig.InstanceCount",
	"og_account_id":              "metadata.SourceID",
	"name":                       "description.Service.Name",
	"namespace_id":               "description.Service.DnsConfig.NamespaceId",
	"routing_policy":             "description.Service.DnsConfig.RoutingPolicy",
	"tags":                       "description.Tags",
	"tags_src":                   "description.Tags",
	"title":                      "description.Service.Name",
	"type":                       "description.Service.Type",
}

func GetServiceDiscoveryService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceDiscoveryService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceDiscoveryServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceDiscoveryServiceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceDiscoveryService =============================

// ==========================  START: ServiceDiscoveryNamespace =============================

type ServiceDiscoveryNamespace struct {
	Description   aws.ServiceDiscoveryNamespaceDescription `json:"description"`
	Metadata      aws.Metadata                             `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type ServiceDiscoveryNamespaceHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  ServiceDiscoveryNamespace `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type ServiceDiscoveryNamespaceHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []ServiceDiscoveryNamespaceHit `json:"hits"`
}

type ServiceDiscoveryNamespaceSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  ServiceDiscoveryNamespaceHits `json:"hits"`
}

type ServiceDiscoveryNamespacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceDiscoveryNamespacePaginator(filters []essdk.BoolFilter, limit *int64) (ServiceDiscoveryNamespacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicediscovery_namespace", filters, limit)
	if err != nil {
		return ServiceDiscoveryNamespacePaginator{}, err
	}

	p := ServiceDiscoveryNamespacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceDiscoveryNamespacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceDiscoveryNamespacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceDiscoveryNamespacePaginator) NextPage(ctx context.Context) ([]ServiceDiscoveryNamespace, error) {
	var response ServiceDiscoveryNamespaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceDiscoveryNamespace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceDiscoveryNamespaceFilters = map[string]string{
	"arn":             "description.Namespace.Arn",
	"create_date":     "description.Namespace.CreateDate",
	"description":     "description.Namespace.Description",
	"dns_properties":  "description.Namespace.Properties.DnsProperties",
	"http_properties": "description.Namespace.Properties.HttpProperties",
	"id":              "description.Namespace.Id",
	"og_account_id":   "metadata.SourceID",
	"name":            "description.Namespace.Name",
	"service_count":   "description.Namespace.ServiceCount",
	"tags":            "description.Tags",
	"tags_src":        "description.Tags",
	"title":           "description.Namespace.Name",
	"type":            "description.Namespace.Type",
}

func ListServiceDiscoveryNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceDiscoveryNamespace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryNamespace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryNamespace NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceDiscoveryNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceDiscoveryNamespaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryNamespace NewServiceDiscoveryNamespacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceDiscoveryNamespace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceDiscoveryNamespaceFilters = map[string]string{
	"arn":             "description.Namespace.Arn",
	"create_date":     "description.Namespace.CreateDate",
	"description":     "description.Namespace.Description",
	"dns_properties":  "description.Namespace.Properties.DnsProperties",
	"http_properties": "description.Namespace.Properties.HttpProperties",
	"id":              "description.Namespace.Id",
	"og_account_id":   "metadata.SourceID",
	"name":            "description.Namespace.Name",
	"service_count":   "description.Namespace.ServiceCount",
	"tags":            "description.Tags",
	"tags_src":        "description.Tags",
	"title":           "description.Namespace.Name",
	"type":            "description.Namespace.Type",
}

func GetServiceDiscoveryNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceDiscoveryNamespace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceDiscoveryNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceDiscoveryNamespaceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceDiscoveryNamespace =============================

// ==========================  START: ServiceDiscoveryInstance =============================

type ServiceDiscoveryInstance struct {
	Description   aws.ServiceDiscoveryInstanceDescription `json:"description"`
	Metadata      aws.Metadata                            `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type ServiceDiscoveryInstanceHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  ServiceDiscoveryInstance `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type ServiceDiscoveryInstanceHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []ServiceDiscoveryInstanceHit `json:"hits"`
}

type ServiceDiscoveryInstanceSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  ServiceDiscoveryInstanceHits `json:"hits"`
}

type ServiceDiscoveryInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceDiscoveryInstancePaginator(filters []essdk.BoolFilter, limit *int64) (ServiceDiscoveryInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "aws_servicediscovery_instance", filters, limit)
	if err != nil {
		return ServiceDiscoveryInstancePaginator{}, err
	}

	p := ServiceDiscoveryInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceDiscoveryInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceDiscoveryInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceDiscoveryInstancePaginator) NextPage(ctx context.Context) ([]ServiceDiscoveryInstance, error) {
	var response ServiceDiscoveryInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceDiscoveryInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceDiscoveryInstanceFilters = map[string]string{
	"alias_dns_name":     "description.Instance.Attributes.AWS_ALIAS_DNS_NAME",
	"attributes":         "description.Instance.Attributes",
	"ec2_instance_id":    "description.Instance.Attributes.AWS_EC2_INSTANCE_ID",
	"id":                 "description.Instance.Id",
	"init_health_status": "description.Instance.Attributes.AWS_INIT_HEALTH_STATUS",
	"instance_cname":     "description.Instance.Attributes.AWS_INSTANCE_CNAME",
	"instance_ipv4":      "description.Instance.Attributes.AWS_INSTANCE_IPV4",
	"instance_ipv6":      "description.Instance.Attributes.AWS_INSTANCE_IPV6",
	"instance_port":      "description.Instance.Attributes.AWS_INSTANCE_PORT",
	"og_account_id":      "metadata.SourceID",
	"service_id":         "description.ServiceId",
	"title":              "description.Instance.Id",
}

func ListServiceDiscoveryInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceDiscoveryInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceDiscoveryInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceDiscoveryInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceDiscoveryInstance NewServiceDiscoveryInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceDiscoveryInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceDiscoveryInstanceFilters = map[string]string{
	"alias_dns_name":     "description.Instance.Attributes.AWS_ALIAS_DNS_NAME",
	"attributes":         "description.Instance.Attributes",
	"ec2_instance_id":    "description.Instance.Attributes.AWS_EC2_INSTANCE_ID",
	"id":                 "description.Instance.Id",
	"init_health_status": "description.Instance.Attributes.AWS_INIT_HEALTH_STATUS",
	"instance_cname":     "description.Instance.Attributes.AWS_INSTANCE_CNAME",
	"instance_ipv4":      "description.Instance.Attributes.AWS_INSTANCE_IPV4",
	"instance_ipv6":      "description.Instance.Attributes.AWS_INSTANCE_IPV6",
	"instance_port":      "description.Instance.Attributes.AWS_INSTANCE_PORT",
	"og_account_id":      "metadata.SourceID",
	"service_id":         "description.ServiceId",
	"title":              "description.Instance.Id",
}

func GetServiceDiscoveryInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceDiscoveryInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceDiscoveryInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceDiscoveryInstanceFilters, "aws", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceDiscoveryInstance =============================
